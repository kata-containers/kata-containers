// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oci.proto

package grpc

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Spec struct {
	// Version of the Open Container Initiative Runtime Specification with which the bundle complies.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// Process configures the container process.
	Process *Process `protobuf:"bytes,2,opt,name=Process" json:"Process,omitempty"`
	// Root configures the container's root filesystem.
	Root *Root `protobuf:"bytes,3,opt,name=Root" json:"Root,omitempty"`
	// Hostname configures the container's hostname.
	Hostname string `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	// Mounts configures additional mounts (on top of Root).
	Mounts []Mount `protobuf:"bytes,5,rep,name=Mounts" json:"Mounts"`
	// Hooks configures callbacks for container lifecycle events.
	Hooks *Hooks `protobuf:"bytes,6,opt,name=Hooks" json:"Hooks,omitempty"`
	// Annotations contains arbitrary metadata for the container.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=Annotations" json:"Annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Linux is platform-specific configuration for Linux based containers.
	Linux *Linux `protobuf:"bytes,8,opt,name=Linux" json:"Linux,omitempty"`
	// Solaris is platform-specific configuration for Solaris based containers.
	Solaris *Solaris `protobuf:"bytes,9,opt,name=Solaris" json:"Solaris,omitempty"`
	// Windows is platform-specific configuration for Windows based containers.
	Windows *Windows `protobuf:"bytes,10,opt,name=Windows" json:"Windows,omitempty"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{0} }

func (m *Spec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Spec) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Spec) GetRoot() *Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Spec) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Spec) GetMounts() []Mount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *Spec) GetHooks() *Hooks {
	if m != nil {
		return m.Hooks
	}
	return nil
}

func (m *Spec) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Spec) GetLinux() *Linux {
	if m != nil {
		return m.Linux
	}
	return nil
}

func (m *Spec) GetSolaris() *Solaris {
	if m != nil {
		return m.Solaris
	}
	return nil
}

func (m *Spec) GetWindows() *Windows {
	if m != nil {
		return m.Windows
	}
	return nil
}

type Process struct {
	// Terminal creates an interactive terminal for the container.
	Terminal bool `protobuf:"varint,1,opt,name=Terminal,proto3" json:"Terminal,omitempty"`
	// ConsoleSize specifies the size of the console.
	ConsoleSize *Box `protobuf:"bytes,2,opt,name=ConsoleSize" json:"ConsoleSize,omitempty"`
	// User specifies user information for the process.
	User User `protobuf:"bytes,3,opt,name=User" json:"User"`
	// Args specifies the binary and arguments for the application to execute.
	Args []string `protobuf:"bytes,4,rep,name=Args" json:"Args,omitempty"`
	// Env populates the process environment for the process.
	Env []string `protobuf:"bytes,5,rep,name=Env" json:"Env,omitempty"`
	// Cwd is the current working directory for the process and must be
	// relative to the container's root.
	Cwd string `protobuf:"bytes,6,opt,name=Cwd,proto3" json:"Cwd,omitempty"`
	// Capabilities are Linux capabilities that are kept for the process.
	Capabilities *LinuxCapabilities `protobuf:"bytes,7,opt,name=Capabilities" json:"Capabilities,omitempty"`
	// Rlimits specifies rlimit options to apply to the process.
	Rlimits []POSIXRlimit `protobuf:"bytes,8,rep,name=Rlimits" json:"Rlimits"`
	// NoNewPrivileges controls whether additional privileges could be gained by processes in the container.
	NoNewPrivileges bool `protobuf:"varint,9,opt,name=NoNewPrivileges,proto3" json:"NoNewPrivileges,omitempty"`
	// ApparmorProfile specifies the apparmor profile for the container.
	ApparmorProfile string `protobuf:"bytes,10,opt,name=ApparmorProfile,proto3" json:"ApparmorProfile,omitempty"`
	// Specify an oom_score_adj for the container.
	OOMScoreAdj int64 `protobuf:"varint,11,opt,name=OOMScoreAdj,proto3" json:"OOMScoreAdj,omitempty"`
	// SelinuxLabel specifies the selinux context that the container process is run as.
	SelinuxLabel string `protobuf:"bytes,12,opt,name=SelinuxLabel,proto3" json:"SelinuxLabel,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{1} }

func (m *Process) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

func (m *Process) GetConsoleSize() *Box {
	if m != nil {
		return m.ConsoleSize
	}
	return nil
}

func (m *Process) GetUser() User {
	if m != nil {
		return m.User
	}
	return User{}
}

func (m *Process) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Process) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Process) GetCwd() string {
	if m != nil {
		return m.Cwd
	}
	return ""
}

func (m *Process) GetCapabilities() *LinuxCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Process) GetRlimits() []POSIXRlimit {
	if m != nil {
		return m.Rlimits
	}
	return nil
}

func (m *Process) GetNoNewPrivileges() bool {
	if m != nil {
		return m.NoNewPrivileges
	}
	return false
}

func (m *Process) GetApparmorProfile() string {
	if m != nil {
		return m.ApparmorProfile
	}
	return ""
}

func (m *Process) GetOOMScoreAdj() int64 {
	if m != nil {
		return m.OOMScoreAdj
	}
	return 0
}

func (m *Process) GetSelinuxLabel() string {
	if m != nil {
		return m.SelinuxLabel
	}
	return ""
}

type Box struct {
	// Height is the vertical dimension of a box.
	Height uint32 `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	// Width is the horizontal dimension of a box.
	Width uint32 `protobuf:"varint,2,opt,name=Width,proto3" json:"Width,omitempty"`
}

func (m *Box) Reset()                    { *m = Box{} }
func (m *Box) String() string            { return proto.CompactTextString(m) }
func (*Box) ProtoMessage()               {}
func (*Box) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{2} }

func (m *Box) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Box) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type User struct {
	// UID is the user id.
	UID uint32 `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	// GID is the group id.
	GID uint32 `protobuf:"varint,2,opt,name=GID,proto3" json:"GID,omitempty"`
	// AdditionalGids are additional group ids set for the container's process.
	AdditionalGids []uint32 `protobuf:"varint,3,rep,packed,name=AdditionalGids" json:"AdditionalGids,omitempty"`
	// Username is the user name.
	Username string `protobuf:"bytes,4,opt,name=Username,proto3" json:"Username,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{3} }

func (m *User) GetUID() uint32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *User) GetGID() uint32 {
	if m != nil {
		return m.GID
	}
	return 0
}

func (m *User) GetAdditionalGids() []uint32 {
	if m != nil {
		return m.AdditionalGids
	}
	return nil
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type LinuxCapabilities struct {
	// Bounding is the set of capabilities checked by the kernel.
	Bounding []string `protobuf:"bytes,1,rep,name=Bounding" json:"Bounding,omitempty"`
	// Effective is the set of capabilities checked by the kernel.
	Effective []string `protobuf:"bytes,2,rep,name=Effective" json:"Effective,omitempty"`
	// Inheritable is the capabilities preserved across execve.
	Inheritable []string `protobuf:"bytes,3,rep,name=Inheritable" json:"Inheritable,omitempty"`
	// Permitted is the limiting superset for effective capabilities.
	Permitted []string `protobuf:"bytes,4,rep,name=Permitted" json:"Permitted,omitempty"`
	// Ambient is the ambient set of capabilities that are kept.
	Ambient []string `protobuf:"bytes,5,rep,name=Ambient" json:"Ambient,omitempty"`
}

func (m *LinuxCapabilities) Reset()                    { *m = LinuxCapabilities{} }
func (m *LinuxCapabilities) String() string            { return proto.CompactTextString(m) }
func (*LinuxCapabilities) ProtoMessage()               {}
func (*LinuxCapabilities) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{4} }

func (m *LinuxCapabilities) GetBounding() []string {
	if m != nil {
		return m.Bounding
	}
	return nil
}

func (m *LinuxCapabilities) GetEffective() []string {
	if m != nil {
		return m.Effective
	}
	return nil
}

func (m *LinuxCapabilities) GetInheritable() []string {
	if m != nil {
		return m.Inheritable
	}
	return nil
}

func (m *LinuxCapabilities) GetPermitted() []string {
	if m != nil {
		return m.Permitted
	}
	return nil
}

func (m *LinuxCapabilities) GetAmbient() []string {
	if m != nil {
		return m.Ambient
	}
	return nil
}

type POSIXRlimit struct {
	// Type of the rlimit to set
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// Hard is the hard limit for the specified type
	Hard uint64 `protobuf:"varint,2,opt,name=Hard,proto3" json:"Hard,omitempty"`
	// Soft is the soft limit for the specified type
	Soft uint64 `protobuf:"varint,3,opt,name=Soft,proto3" json:"Soft,omitempty"`
}

func (m *POSIXRlimit) Reset()                    { *m = POSIXRlimit{} }
func (m *POSIXRlimit) String() string            { return proto.CompactTextString(m) }
func (*POSIXRlimit) ProtoMessage()               {}
func (*POSIXRlimit) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{5} }

func (m *POSIXRlimit) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *POSIXRlimit) GetHard() uint64 {
	if m != nil {
		return m.Hard
	}
	return 0
}

func (m *POSIXRlimit) GetSoft() uint64 {
	if m != nil {
		return m.Soft
	}
	return 0
}

type Mount struct {
	// destination is the path inside the container expect when it starts with "tmp:/"
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// source is the path inside the container expect when it starts with "vm:/dev/" or "tmp:/"
	// the path which starts with "vm:/dev/" refers the guest vm's "/dev",
	// especially, "vm:/dev/hostfs/" refers to the shared filesystem.
	// "tmp:/" is a temporary directory which is used for temporary mounts.
	Source  string   `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Type    string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Options []string `protobuf:"bytes,4,rep,name=options" json:"options,omitempty"`
}

func (m *Mount) Reset()                    { *m = Mount{} }
func (m *Mount) String() string            { return proto.CompactTextString(m) }
func (*Mount) ProtoMessage()               {}
func (*Mount) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{6} }

func (m *Mount) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Mount) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Mount) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Mount) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

type Root struct {
	// Path is the absolute path to the container's root filesystem.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Readonly makes the root filesystem for the container readonly before the process is executed.
	Readonly bool `protobuf:"varint,2,opt,name=Readonly,proto3" json:"Readonly,omitempty"`
}

func (m *Root) Reset()                    { *m = Root{} }
func (m *Root) String() string            { return proto.CompactTextString(m) }
func (*Root) ProtoMessage()               {}
func (*Root) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{7} }

func (m *Root) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Root) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type Hooks struct {
	// Prestart is a list of hooks to be run before the container process is executed.
	Prestart []Hook `protobuf:"bytes,1,rep,name=Prestart" json:"Prestart"`
	// Poststart is a list of hooks to be run after the container process is started.
	Poststart []Hook `protobuf:"bytes,2,rep,name=Poststart" json:"Poststart"`
	// Poststop is a list of hooks to be run after the container process exits.
	Poststop []Hook `protobuf:"bytes,3,rep,name=Poststop" json:"Poststop"`
}

func (m *Hooks) Reset()                    { *m = Hooks{} }
func (m *Hooks) String() string            { return proto.CompactTextString(m) }
func (*Hooks) ProtoMessage()               {}
func (*Hooks) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{8} }

func (m *Hooks) GetPrestart() []Hook {
	if m != nil {
		return m.Prestart
	}
	return nil
}

func (m *Hooks) GetPoststart() []Hook {
	if m != nil {
		return m.Poststart
	}
	return nil
}

func (m *Hooks) GetPoststop() []Hook {
	if m != nil {
		return m.Poststop
	}
	return nil
}

type Hook struct {
	Path    string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
	Env     []string `protobuf:"bytes,3,rep,name=Env" json:"Env,omitempty"`
	Timeout int64    `protobuf:"varint,4,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
}

func (m *Hook) Reset()                    { *m = Hook{} }
func (m *Hook) String() string            { return proto.CompactTextString(m) }
func (*Hook) ProtoMessage()               {}
func (*Hook) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{9} }

func (m *Hook) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Hook) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Hook) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Hook) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type Linux struct {
	// UIDMapping specifies user mappings for supporting user namespaces.
	UIDMappings []LinuxIDMapping `protobuf:"bytes,1,rep,name=UIDMappings" json:"UIDMappings"`
	// GIDMapping specifies group mappings for supporting user namespaces.
	GIDMappings []LinuxIDMapping `protobuf:"bytes,2,rep,name=GIDMappings" json:"GIDMappings"`
	// Sysctl are a set of key value pairs that are set for the container on start
	Sysctl map[string]string `protobuf:"bytes,3,rep,name=Sysctl" json:"Sysctl,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Resources contain cgroup information for handling resource constraints
	// for the container
	Resources *LinuxResources `protobuf:"bytes,4,opt,name=Resources" json:"Resources,omitempty"`
	// CgroupsPath specifies the path to cgroups that are created and/or joined by the container.
	// The path is expected to be relative to the cgroups mountpoint.
	// If resources are specified, the cgroups at CgroupsPath will be updated based on resources.
	CgroupsPath string `protobuf:"bytes,5,opt,name=CgroupsPath,proto3" json:"CgroupsPath,omitempty"`
	// Namespaces contains the namespaces that are created and/or joined by the container
	Namespaces []LinuxNamespace `protobuf:"bytes,6,rep,name=Namespaces" json:"Namespaces"`
	// Devices are a list of device nodes that are created for the container
	Devices []LinuxDevice `protobuf:"bytes,7,rep,name=Devices" json:"Devices"`
	// Seccomp specifies the seccomp security settings for the container.
	Seccomp *LinuxSeccomp `protobuf:"bytes,8,opt,name=Seccomp" json:"Seccomp,omitempty"`
	// RootfsPropagation is the rootfs mount propagation mode for the container.
	RootfsPropagation string `protobuf:"bytes,9,opt,name=RootfsPropagation,proto3" json:"RootfsPropagation,omitempty"`
	// MaskedPaths masks over the provided paths inside the container.
	MaskedPaths []string `protobuf:"bytes,10,rep,name=MaskedPaths" json:"MaskedPaths,omitempty"`
	// ReadonlyPaths sets the provided paths as RO inside the container.
	ReadonlyPaths []string `protobuf:"bytes,11,rep,name=ReadonlyPaths" json:"ReadonlyPaths,omitempty"`
	// MountLabel specifies the selinux context for the mounts in the container.
	MountLabel string `protobuf:"bytes,12,opt,name=MountLabel,proto3" json:"MountLabel,omitempty"`
	// IntelRdt contains Intel Resource Director Technology (RDT) information
	// for handling resource constraints (e.g., L3 cache) for the container
	IntelRdt *LinuxIntelRdt `protobuf:"bytes,13,opt,name=IntelRdt" json:"IntelRdt,omitempty"`
}

func (m *Linux) Reset()                    { *m = Linux{} }
func (m *Linux) String() string            { return proto.CompactTextString(m) }
func (*Linux) ProtoMessage()               {}
func (*Linux) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{10} }

func (m *Linux) GetUIDMappings() []LinuxIDMapping {
	if m != nil {
		return m.UIDMappings
	}
	return nil
}

func (m *Linux) GetGIDMappings() []LinuxIDMapping {
	if m != nil {
		return m.GIDMappings
	}
	return nil
}

func (m *Linux) GetSysctl() map[string]string {
	if m != nil {
		return m.Sysctl
	}
	return nil
}

func (m *Linux) GetResources() *LinuxResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Linux) GetCgroupsPath() string {
	if m != nil {
		return m.CgroupsPath
	}
	return ""
}

func (m *Linux) GetNamespaces() []LinuxNamespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *Linux) GetDevices() []LinuxDevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *Linux) GetSeccomp() *LinuxSeccomp {
	if m != nil {
		return m.Seccomp
	}
	return nil
}

func (m *Linux) GetRootfsPropagation() string {
	if m != nil {
		return m.RootfsPropagation
	}
	return ""
}

func (m *Linux) GetMaskedPaths() []string {
	if m != nil {
		return m.MaskedPaths
	}
	return nil
}

func (m *Linux) GetReadonlyPaths() []string {
	if m != nil {
		return m.ReadonlyPaths
	}
	return nil
}

func (m *Linux) GetMountLabel() string {
	if m != nil {
		return m.MountLabel
	}
	return ""
}

func (m *Linux) GetIntelRdt() *LinuxIntelRdt {
	if m != nil {
		return m.IntelRdt
	}
	return nil
}

type Windows struct {
	// Dummy string, never used.
	Dummy string `protobuf:"bytes,1,opt,name=dummy,proto3" json:"dummy,omitempty"`
}

func (m *Windows) Reset()                    { *m = Windows{} }
func (m *Windows) String() string            { return proto.CompactTextString(m) }
func (*Windows) ProtoMessage()               {}
func (*Windows) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{11} }

func (m *Windows) GetDummy() string {
	if m != nil {
		return m.Dummy
	}
	return ""
}

type Solaris struct {
	// Dummy string, never used.
	Dummy string `protobuf:"bytes,1,opt,name=dummy,proto3" json:"dummy,omitempty"`
}

func (m *Solaris) Reset()                    { *m = Solaris{} }
func (m *Solaris) String() string            { return proto.CompactTextString(m) }
func (*Solaris) ProtoMessage()               {}
func (*Solaris) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{12} }

func (m *Solaris) GetDummy() string {
	if m != nil {
		return m.Dummy
	}
	return ""
}

type LinuxIDMapping struct {
	// HostID is the starting UID/GID on the host to be mapped to 'ContainerID'
	HostID uint32 `protobuf:"varint,1,opt,name=HostID,proto3" json:"HostID,omitempty"`
	// ContainerID is the starting UID/GID in the container
	ContainerID uint32 `protobuf:"varint,2,opt,name=ContainerID,proto3" json:"ContainerID,omitempty"`
	// Size is the number of IDs to be mapped
	Size_ uint32 `protobuf:"varint,3,opt,name=Size,proto3" json:"Size,omitempty"`
}

func (m *LinuxIDMapping) Reset()                    { *m = LinuxIDMapping{} }
func (m *LinuxIDMapping) String() string            { return proto.CompactTextString(m) }
func (*LinuxIDMapping) ProtoMessage()               {}
func (*LinuxIDMapping) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{13} }

func (m *LinuxIDMapping) GetHostID() uint32 {
	if m != nil {
		return m.HostID
	}
	return 0
}

func (m *LinuxIDMapping) GetContainerID() uint32 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *LinuxIDMapping) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type LinuxNamespace struct {
	// Type is the type of namespace
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// Path is a path to an existing namespace persisted on disk that can be joined
	// and is of the same type
	Path string `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *LinuxNamespace) Reset()                    { *m = LinuxNamespace{} }
func (m *LinuxNamespace) String() string            { return proto.CompactTextString(m) }
func (*LinuxNamespace) ProtoMessage()               {}
func (*LinuxNamespace) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{14} }

func (m *LinuxNamespace) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxNamespace) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type LinuxDevice struct {
	// Path to the device.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Device type, block, char, etc.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	// Major is the device's major number.
	Major int64 `protobuf:"varint,3,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,4,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// FileMode permission bits for the device.
	FileMode uint32 `protobuf:"varint,5,opt,name=FileMode,proto3" json:"FileMode,omitempty"`
	// UID of the device.
	UID uint32 `protobuf:"varint,6,opt,name=UID,proto3" json:"UID,omitempty"`
	// Gid of the device.
	GID uint32 `protobuf:"varint,7,opt,name=GID,proto3" json:"GID,omitempty"`
}

func (m *LinuxDevice) Reset()                    { *m = LinuxDevice{} }
func (m *LinuxDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxDevice) ProtoMessage()               {}
func (*LinuxDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{15} }

func (m *LinuxDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LinuxDevice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxDevice) GetFileMode() uint32 {
	if m != nil {
		return m.FileMode
	}
	return 0
}

func (m *LinuxDevice) GetUID() uint32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *LinuxDevice) GetGID() uint32 {
	if m != nil {
		return m.GID
	}
	return 0
}

type LinuxResources struct {
	// Devices configures the device whitelist.
	Devices []LinuxDeviceCgroup `protobuf:"bytes,1,rep,name=Devices" json:"Devices"`
	// Memory restriction configuration
	Memory *LinuxMemory `protobuf:"bytes,2,opt,name=Memory" json:"Memory,omitempty"`
	// CPU resource restriction configuration
	CPU *LinuxCPU `protobuf:"bytes,3,opt,name=CPU" json:"CPU,omitempty"`
	// Task resource restriction configuration.
	Pids *LinuxPids `protobuf:"bytes,4,opt,name=Pids" json:"Pids,omitempty"`
	// BlockIO restriction configuration
	BlockIO *LinuxBlockIO `protobuf:"bytes,5,opt,name=BlockIO" json:"BlockIO,omitempty"`
	// Hugetlb limit (in bytes)
	HugepageLimits []LinuxHugepageLimit `protobuf:"bytes,6,rep,name=HugepageLimits" json:"HugepageLimits"`
	// Network restriction configuration
	Network *LinuxNetwork `protobuf:"bytes,7,opt,name=Network" json:"Network,omitempty"`
}

func (m *LinuxResources) Reset()                    { *m = LinuxResources{} }
func (m *LinuxResources) String() string            { return proto.CompactTextString(m) }
func (*LinuxResources) ProtoMessage()               {}
func (*LinuxResources) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{16} }

func (m *LinuxResources) GetDevices() []LinuxDeviceCgroup {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *LinuxResources) GetMemory() *LinuxMemory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *LinuxResources) GetCPU() *LinuxCPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *LinuxResources) GetPids() *LinuxPids {
	if m != nil {
		return m.Pids
	}
	return nil
}

func (m *LinuxResources) GetBlockIO() *LinuxBlockIO {
	if m != nil {
		return m.BlockIO
	}
	return nil
}

func (m *LinuxResources) GetHugepageLimits() []LinuxHugepageLimit {
	if m != nil {
		return m.HugepageLimits
	}
	return nil
}

func (m *LinuxResources) GetNetwork() *LinuxNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

type LinuxMemory struct {
	// Memory limit (in bytes).
	Limit int64 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// Memory reservation or soft_limit (in bytes).
	Reservation int64 `protobuf:"varint,2,opt,name=Reservation,proto3" json:"Reservation,omitempty"`
	// Total memory limit (memory + swap).
	Swap int64 `protobuf:"varint,3,opt,name=Swap,proto3" json:"Swap,omitempty"`
	// Kernel memory limit (in bytes).
	Kernel int64 `protobuf:"varint,4,opt,name=Kernel,proto3" json:"Kernel,omitempty"`
	// Kernel memory limit for tcp (in bytes)
	KernelTCP int64 `protobuf:"varint,5,opt,name=KernelTCP,proto3" json:"KernelTCP,omitempty"`
	// How aggressive the kernel will swap memory pages.
	Swappiness uint64 `protobuf:"varint,6,opt,name=Swappiness,proto3" json:"Swappiness,omitempty"`
	// DisableOOMKiller disables the OOM killer for out of memory conditions
	DisableOOMKiller bool `protobuf:"varint,7,opt,name=DisableOOMKiller,proto3" json:"DisableOOMKiller,omitempty"`
}

func (m *LinuxMemory) Reset()                    { *m = LinuxMemory{} }
func (m *LinuxMemory) String() string            { return proto.CompactTextString(m) }
func (*LinuxMemory) ProtoMessage()               {}
func (*LinuxMemory) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{17} }

func (m *LinuxMemory) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *LinuxMemory) GetReservation() int64 {
	if m != nil {
		return m.Reservation
	}
	return 0
}

func (m *LinuxMemory) GetSwap() int64 {
	if m != nil {
		return m.Swap
	}
	return 0
}

func (m *LinuxMemory) GetKernel() int64 {
	if m != nil {
		return m.Kernel
	}
	return 0
}

func (m *LinuxMemory) GetKernelTCP() int64 {
	if m != nil {
		return m.KernelTCP
	}
	return 0
}

func (m *LinuxMemory) GetSwappiness() uint64 {
	if m != nil {
		return m.Swappiness
	}
	return 0
}

func (m *LinuxMemory) GetDisableOOMKiller() bool {
	if m != nil {
		return m.DisableOOMKiller
	}
	return false
}

type LinuxCPU struct {
	// CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
	Shares uint64 `protobuf:"varint,1,opt,name=Shares,proto3" json:"Shares,omitempty"`
	// CPU hardcap limit (in usecs). Allowed cpu time in a given period.
	Quota int64 `protobuf:"varint,2,opt,name=Quota,proto3" json:"Quota,omitempty"`
	// CPU period to be used for hardcapping (in usecs).
	Period uint64 `protobuf:"varint,3,opt,name=Period,proto3" json:"Period,omitempty"`
	// How much time realtime scheduling may use (in usecs).
	RealtimeRuntime int64 `protobuf:"varint,4,opt,name=RealtimeRuntime,proto3" json:"RealtimeRuntime,omitempty"`
	// CPU period to be used for realtime scheduling (in usecs).
	RealtimePeriod uint64 `protobuf:"varint,5,opt,name=RealtimePeriod,proto3" json:"RealtimePeriod,omitempty"`
	// CPUs to use within the cpuset. Default is to use any CPU available.
	Cpus string `protobuf:"bytes,6,opt,name=Cpus,proto3" json:"Cpus,omitempty"`
	// List of memory nodes in the cpuset. Default is to use any available memory node.
	Mems string `protobuf:"bytes,7,opt,name=Mems,proto3" json:"Mems,omitempty"`
}

func (m *LinuxCPU) Reset()                    { *m = LinuxCPU{} }
func (m *LinuxCPU) String() string            { return proto.CompactTextString(m) }
func (*LinuxCPU) ProtoMessage()               {}
func (*LinuxCPU) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{18} }

func (m *LinuxCPU) GetShares() uint64 {
	if m != nil {
		return m.Shares
	}
	return 0
}

func (m *LinuxCPU) GetQuota() int64 {
	if m != nil {
		return m.Quota
	}
	return 0
}

func (m *LinuxCPU) GetPeriod() uint64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *LinuxCPU) GetRealtimeRuntime() int64 {
	if m != nil {
		return m.RealtimeRuntime
	}
	return 0
}

func (m *LinuxCPU) GetRealtimePeriod() uint64 {
	if m != nil {
		return m.RealtimePeriod
	}
	return 0
}

func (m *LinuxCPU) GetCpus() string {
	if m != nil {
		return m.Cpus
	}
	return ""
}

func (m *LinuxCPU) GetMems() string {
	if m != nil {
		return m.Mems
	}
	return ""
}

type LinuxWeightDevice struct {
	// Major is the device's major number.
	Major int64 `protobuf:"varint,1,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,2,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Weight is the bandwidth rate for the device.
	Weight uint32 `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
	// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint32 `protobuf:"varint,4,opt,name=LeafWeight,proto3" json:"LeafWeight,omitempty"`
}

func (m *LinuxWeightDevice) Reset()                    { *m = LinuxWeightDevice{} }
func (m *LinuxWeightDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxWeightDevice) ProtoMessage()               {}
func (*LinuxWeightDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{19} }

func (m *LinuxWeightDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxWeightDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxWeightDevice) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *LinuxWeightDevice) GetLeafWeight() uint32 {
	if m != nil {
		return m.LeafWeight
	}
	return 0
}

type LinuxThrottleDevice struct {
	// Major is the device's major number.
	Major int64 `protobuf:"varint,1,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,2,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `protobuf:"varint,3,opt,name=Rate,proto3" json:"Rate,omitempty"`
}

func (m *LinuxThrottleDevice) Reset()                    { *m = LinuxThrottleDevice{} }
func (m *LinuxThrottleDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxThrottleDevice) ProtoMessage()               {}
func (*LinuxThrottleDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{20} }

func (m *LinuxThrottleDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxThrottleDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxThrottleDevice) GetRate() uint64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type LinuxBlockIO struct {
	// Specifies per cgroup weight
	Weight uint32 `protobuf:"varint,1,opt,name=Weight,proto3" json:"Weight,omitempty"`
	// Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint32 `protobuf:"varint,2,opt,name=LeafWeight,proto3" json:"LeafWeight,omitempty"`
	// Weight per cgroup per device, can override BlkioWeight
	WeightDevice []LinuxWeightDevice `protobuf:"bytes,3,rep,name=WeightDevice" json:"WeightDevice"`
	// IO read rate limit per cgroup per device, bytes per second
	ThrottleReadBpsDevice []LinuxThrottleDevice `protobuf:"bytes,4,rep,name=ThrottleReadBpsDevice" json:"ThrottleReadBpsDevice"`
	// IO write rate limit per cgroup per device, bytes per second
	ThrottleWriteBpsDevice []LinuxThrottleDevice `protobuf:"bytes,5,rep,name=ThrottleWriteBpsDevice" json:"ThrottleWriteBpsDevice"`
	// IO read rate limit per cgroup per device, IO per second
	ThrottleReadIOPSDevice []LinuxThrottleDevice `protobuf:"bytes,6,rep,name=ThrottleReadIOPSDevice" json:"ThrottleReadIOPSDevice"`
	// IO write rate limit per cgroup per device, IO per second
	ThrottleWriteIOPSDevice []LinuxThrottleDevice `protobuf:"bytes,7,rep,name=ThrottleWriteIOPSDevice" json:"ThrottleWriteIOPSDevice"`
}

func (m *LinuxBlockIO) Reset()                    { *m = LinuxBlockIO{} }
func (m *LinuxBlockIO) String() string            { return proto.CompactTextString(m) }
func (*LinuxBlockIO) ProtoMessage()               {}
func (*LinuxBlockIO) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{21} }

func (m *LinuxBlockIO) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *LinuxBlockIO) GetLeafWeight() uint32 {
	if m != nil {
		return m.LeafWeight
	}
	return 0
}

func (m *LinuxBlockIO) GetWeightDevice() []LinuxWeightDevice {
	if m != nil {
		return m.WeightDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleReadBpsDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleReadBpsDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleWriteBpsDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleWriteBpsDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleReadIOPSDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleReadIOPSDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleWriteIOPSDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleWriteIOPSDevice
	}
	return nil
}

type LinuxPids struct {
	// Maximum number of PIDs. Default is "no limit".
	Limit int64 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *LinuxPids) Reset()                    { *m = LinuxPids{} }
func (m *LinuxPids) String() string            { return proto.CompactTextString(m) }
func (*LinuxPids) ProtoMessage()               {}
func (*LinuxPids) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{22} }

func (m *LinuxPids) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LinuxDeviceCgroup struct {
	// Allow or deny
	Allow bool `protobuf:"varint,1,opt,name=Allow,proto3" json:"Allow,omitempty"`
	// Device type, block, char, etc.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	// Major is the device's major number.
	Major int64 `protobuf:"varint,3,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,4,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Cgroup access permissions format, rwm.
	Access string `protobuf:"bytes,5,opt,name=Access,proto3" json:"Access,omitempty"`
}

func (m *LinuxDeviceCgroup) Reset()                    { *m = LinuxDeviceCgroup{} }
func (m *LinuxDeviceCgroup) String() string            { return proto.CompactTextString(m) }
func (*LinuxDeviceCgroup) ProtoMessage()               {}
func (*LinuxDeviceCgroup) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{23} }

func (m *LinuxDeviceCgroup) GetAllow() bool {
	if m != nil {
		return m.Allow
	}
	return false
}

func (m *LinuxDeviceCgroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxDeviceCgroup) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxDeviceCgroup) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxDeviceCgroup) GetAccess() string {
	if m != nil {
		return m.Access
	}
	return ""
}

type LinuxNetwork struct {
	// Set class identifier for container's network packets
	ClassID uint32 `protobuf:"varint,1,opt,name=ClassID,proto3" json:"ClassID,omitempty"`
	// Set priority of network traffic for container
	Priorities []LinuxInterfacePriority `protobuf:"bytes,2,rep,name=Priorities" json:"Priorities"`
}

func (m *LinuxNetwork) Reset()                    { *m = LinuxNetwork{} }
func (m *LinuxNetwork) String() string            { return proto.CompactTextString(m) }
func (*LinuxNetwork) ProtoMessage()               {}
func (*LinuxNetwork) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{24} }

func (m *LinuxNetwork) GetClassID() uint32 {
	if m != nil {
		return m.ClassID
	}
	return 0
}

func (m *LinuxNetwork) GetPriorities() []LinuxInterfacePriority {
	if m != nil {
		return m.Priorities
	}
	return nil
}

type LinuxHugepageLimit struct {
	// Pagesize is the hugepage size
	Pagesize string `protobuf:"bytes,1,opt,name=Pagesize,proto3" json:"Pagesize,omitempty"`
	// Limit is the limit of "hugepagesize" hugetlb usage
	Limit uint64 `protobuf:"varint,2,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *LinuxHugepageLimit) Reset()                    { *m = LinuxHugepageLimit{} }
func (m *LinuxHugepageLimit) String() string            { return proto.CompactTextString(m) }
func (*LinuxHugepageLimit) ProtoMessage()               {}
func (*LinuxHugepageLimit) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{25} }

func (m *LinuxHugepageLimit) GetPagesize() string {
	if m != nil {
		return m.Pagesize
	}
	return ""
}

func (m *LinuxHugepageLimit) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LinuxInterfacePriority struct {
	// Name is the name of the network interface
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Priority for the interface
	Priority uint32 `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty"`
}

func (m *LinuxInterfacePriority) Reset()                    { *m = LinuxInterfacePriority{} }
func (m *LinuxInterfacePriority) String() string            { return proto.CompactTextString(m) }
func (*LinuxInterfacePriority) ProtoMessage()               {}
func (*LinuxInterfacePriority) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{26} }

func (m *LinuxInterfacePriority) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LinuxInterfacePriority) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

type LinuxSeccomp struct {
	DefaultAction string         `protobuf:"bytes,1,opt,name=DefaultAction,proto3" json:"DefaultAction,omitempty"`
	Architectures []string       `protobuf:"bytes,2,rep,name=Architectures" json:"Architectures,omitempty"`
	Syscalls      []LinuxSyscall `protobuf:"bytes,3,rep,name=Syscalls" json:"Syscalls"`
}

func (m *LinuxSeccomp) Reset()                    { *m = LinuxSeccomp{} }
func (m *LinuxSeccomp) String() string            { return proto.CompactTextString(m) }
func (*LinuxSeccomp) ProtoMessage()               {}
func (*LinuxSeccomp) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{27} }

func (m *LinuxSeccomp) GetDefaultAction() string {
	if m != nil {
		return m.DefaultAction
	}
	return ""
}

func (m *LinuxSeccomp) GetArchitectures() []string {
	if m != nil {
		return m.Architectures
	}
	return nil
}

func (m *LinuxSeccomp) GetSyscalls() []LinuxSyscall {
	if m != nil {
		return m.Syscalls
	}
	return nil
}

type LinuxSeccompArg struct {
	Index    uint64 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	Value    uint64 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	ValueTwo uint64 `protobuf:"varint,3,opt,name=ValueTwo,proto3" json:"ValueTwo,omitempty"`
	Op       string `protobuf:"bytes,4,opt,name=Op,proto3" json:"Op,omitempty"`
}

func (m *LinuxSeccompArg) Reset()                    { *m = LinuxSeccompArg{} }
func (m *LinuxSeccompArg) String() string            { return proto.CompactTextString(m) }
func (*LinuxSeccompArg) ProtoMessage()               {}
func (*LinuxSeccompArg) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{28} }

func (m *LinuxSeccompArg) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LinuxSeccompArg) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *LinuxSeccompArg) GetValueTwo() uint64 {
	if m != nil {
		return m.ValueTwo
	}
	return 0
}

func (m *LinuxSeccompArg) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

type LinuxSyscall struct {
	Names  []string          `protobuf:"bytes,1,rep,name=Names" json:"Names,omitempty"`
	Action string            `protobuf:"bytes,2,opt,name=Action,proto3" json:"Action,omitempty"`
	Args   []LinuxSeccompArg `protobuf:"bytes,3,rep,name=Args" json:"Args"`
}

func (m *LinuxSyscall) Reset()                    { *m = LinuxSyscall{} }
func (m *LinuxSyscall) String() string            { return proto.CompactTextString(m) }
func (*LinuxSyscall) ProtoMessage()               {}
func (*LinuxSyscall) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{29} }

func (m *LinuxSyscall) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *LinuxSyscall) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *LinuxSyscall) GetArgs() []LinuxSeccompArg {
	if m != nil {
		return m.Args
	}
	return nil
}

type LinuxIntelRdt struct {
	// The schema for L3 cache id and capacity bitmask (CBM)
	// Format: "L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;..."
	L3CacheSchema string `protobuf:"bytes,1,opt,name=L3CacheSchema,proto3" json:"L3CacheSchema,omitempty"`
}

func (m *LinuxIntelRdt) Reset()                    { *m = LinuxIntelRdt{} }
func (m *LinuxIntelRdt) String() string            { return proto.CompactTextString(m) }
func (*LinuxIntelRdt) ProtoMessage()               {}
func (*LinuxIntelRdt) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{30} }

func (m *LinuxIntelRdt) GetL3CacheSchema() string {
	if m != nil {
		return m.L3CacheSchema
	}
	return ""
}

func init() {
	proto.RegisterType((*Spec)(nil), "grpc.Spec")
	proto.RegisterType((*Process)(nil), "grpc.Process")
	proto.RegisterType((*Box)(nil), "grpc.Box")
	proto.RegisterType((*User)(nil), "grpc.User")
	proto.RegisterType((*LinuxCapabilities)(nil), "grpc.LinuxCapabilities")
	proto.RegisterType((*POSIXRlimit)(nil), "grpc.POSIXRlimit")
	proto.RegisterType((*Mount)(nil), "grpc.Mount")
	proto.RegisterType((*Root)(nil), "grpc.Root")
	proto.RegisterType((*Hooks)(nil), "grpc.Hooks")
	proto.RegisterType((*Hook)(nil), "grpc.Hook")
	proto.RegisterType((*Linux)(nil), "grpc.Linux")
	proto.RegisterType((*Windows)(nil), "grpc.Windows")
	proto.RegisterType((*Solaris)(nil), "grpc.Solaris")
	proto.RegisterType((*LinuxIDMapping)(nil), "grpc.LinuxIDMapping")
	proto.RegisterType((*LinuxNamespace)(nil), "grpc.LinuxNamespace")
	proto.RegisterType((*LinuxDevice)(nil), "grpc.LinuxDevice")
	proto.RegisterType((*LinuxResources)(nil), "grpc.LinuxResources")
	proto.RegisterType((*LinuxMemory)(nil), "grpc.LinuxMemory")
	proto.RegisterType((*LinuxCPU)(nil), "grpc.LinuxCPU")
	proto.RegisterType((*LinuxWeightDevice)(nil), "grpc.LinuxWeightDevice")
	proto.RegisterType((*LinuxThrottleDevice)(nil), "grpc.LinuxThrottleDevice")
	proto.RegisterType((*LinuxBlockIO)(nil), "grpc.LinuxBlockIO")
	proto.RegisterType((*LinuxPids)(nil), "grpc.LinuxPids")
	proto.RegisterType((*LinuxDeviceCgroup)(nil), "grpc.LinuxDeviceCgroup")
	proto.RegisterType((*LinuxNetwork)(nil), "grpc.LinuxNetwork")
	proto.RegisterType((*LinuxHugepageLimit)(nil), "grpc.LinuxHugepageLimit")
	proto.RegisterType((*LinuxInterfacePriority)(nil), "grpc.LinuxInterfacePriority")
	proto.RegisterType((*LinuxSeccomp)(nil), "grpc.LinuxSeccomp")
	proto.RegisterType((*LinuxSeccompArg)(nil), "grpc.LinuxSeccompArg")
	proto.RegisterType((*LinuxSyscall)(nil), "grpc.LinuxSyscall")
	proto.RegisterType((*LinuxIntelRdt)(nil), "grpc.LinuxIntelRdt")
}
func (this *Spec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Spec)
	if !ok {
		that2, ok := that.(Spec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Process.Equal(that1.Process) {
		return false
	}
	if !this.Root.Equal(that1.Root) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Mounts) != len(that1.Mounts) {
		return false
	}
	for i := range this.Mounts {
		if !this.Mounts[i].Equal(&that1.Mounts[i]) {
			return false
		}
	}
	if !this.Hooks.Equal(that1.Hooks) {
		return false
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if !this.Linux.Equal(that1.Linux) {
		return false
	}
	if !this.Solaris.Equal(that1.Solaris) {
		return false
	}
	if !this.Windows.Equal(that1.Windows) {
		return false
	}
	return true
}
func (this *Process) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Process)
	if !ok {
		that2, ok := that.(Process)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Terminal != that1.Terminal {
		return false
	}
	if !this.ConsoleSize.Equal(that1.ConsoleSize) {
		return false
	}
	if !this.User.Equal(&that1.User) {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Cwd != that1.Cwd {
		return false
	}
	if !this.Capabilities.Equal(that1.Capabilities) {
		return false
	}
	if len(this.Rlimits) != len(that1.Rlimits) {
		return false
	}
	for i := range this.Rlimits {
		if !this.Rlimits[i].Equal(&that1.Rlimits[i]) {
			return false
		}
	}
	if this.NoNewPrivileges != that1.NoNewPrivileges {
		return false
	}
	if this.ApparmorProfile != that1.ApparmorProfile {
		return false
	}
	if this.OOMScoreAdj != that1.OOMScoreAdj {
		return false
	}
	if this.SelinuxLabel != that1.SelinuxLabel {
		return false
	}
	return true
}
func (this *Box) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Box)
	if !ok {
		that2, ok := that.(Box)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UID != that1.UID {
		return false
	}
	if this.GID != that1.GID {
		return false
	}
	if len(this.AdditionalGids) != len(that1.AdditionalGids) {
		return false
	}
	for i := range this.AdditionalGids {
		if this.AdditionalGids[i] != that1.AdditionalGids[i] {
			return false
		}
	}
	if this.Username != that1.Username {
		return false
	}
	return true
}
func (this *LinuxCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxCapabilities)
	if !ok {
		that2, ok := that.(LinuxCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Bounding) != len(that1.Bounding) {
		return false
	}
	for i := range this.Bounding {
		if this.Bounding[i] != that1.Bounding[i] {
			return false
		}
	}
	if len(this.Effective) != len(that1.Effective) {
		return false
	}
	for i := range this.Effective {
		if this.Effective[i] != that1.Effective[i] {
			return false
		}
	}
	if len(this.Inheritable) != len(that1.Inheritable) {
		return false
	}
	for i := range this.Inheritable {
		if this.Inheritable[i] != that1.Inheritable[i] {
			return false
		}
	}
	if len(this.Permitted) != len(that1.Permitted) {
		return false
	}
	for i := range this.Permitted {
		if this.Permitted[i] != that1.Permitted[i] {
			return false
		}
	}
	if len(this.Ambient) != len(that1.Ambient) {
		return false
	}
	for i := range this.Ambient {
		if this.Ambient[i] != that1.Ambient[i] {
			return false
		}
	}
	return true
}
func (this *POSIXRlimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*POSIXRlimit)
	if !ok {
		that2, ok := that.(POSIXRlimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hard != that1.Hard {
		return false
	}
	if this.Soft != that1.Soft {
		return false
	}
	return true
}
func (this *Mount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mount)
	if !ok {
		that2, ok := that.(Mount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *Root) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Root)
	if !ok {
		that2, ok := that.(Root)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Readonly != that1.Readonly {
		return false
	}
	return true
}
func (this *Hooks) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Hooks)
	if !ok {
		that2, ok := that.(Hooks)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prestart) != len(that1.Prestart) {
		return false
	}
	for i := range this.Prestart {
		if !this.Prestart[i].Equal(&that1.Prestart[i]) {
			return false
		}
	}
	if len(this.Poststart) != len(that1.Poststart) {
		return false
	}
	for i := range this.Poststart {
		if !this.Poststart[i].Equal(&that1.Poststart[i]) {
			return false
		}
	}
	if len(this.Poststop) != len(that1.Poststop) {
		return false
	}
	for i := range this.Poststop {
		if !this.Poststop[i].Equal(&that1.Poststop[i]) {
			return false
		}
	}
	return true
}
func (this *Hook) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Hook)
	if !ok {
		that2, ok := that.(Hook)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *Linux) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Linux)
	if !ok {
		that2, ok := that.(Linux)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UIDMappings) != len(that1.UIDMappings) {
		return false
	}
	for i := range this.UIDMappings {
		if !this.UIDMappings[i].Equal(&that1.UIDMappings[i]) {
			return false
		}
	}
	if len(this.GIDMappings) != len(that1.GIDMappings) {
		return false
	}
	for i := range this.GIDMappings {
		if !this.GIDMappings[i].Equal(&that1.GIDMappings[i]) {
			return false
		}
	}
	if len(this.Sysctl) != len(that1.Sysctl) {
		return false
	}
	for i := range this.Sysctl {
		if this.Sysctl[i] != that1.Sysctl[i] {
			return false
		}
	}
	if !this.Resources.Equal(that1.Resources) {
		return false
	}
	if this.CgroupsPath != that1.CgroupsPath {
		return false
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if !this.Namespaces[i].Equal(&that1.Namespaces[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(&that1.Devices[i]) {
			return false
		}
	}
	if !this.Seccomp.Equal(that1.Seccomp) {
		return false
	}
	if this.RootfsPropagation != that1.RootfsPropagation {
		return false
	}
	if len(this.MaskedPaths) != len(that1.MaskedPaths) {
		return false
	}
	for i := range this.MaskedPaths {
		if this.MaskedPaths[i] != that1.MaskedPaths[i] {
			return false
		}
	}
	if len(this.ReadonlyPaths) != len(that1.ReadonlyPaths) {
		return false
	}
	for i := range this.ReadonlyPaths {
		if this.ReadonlyPaths[i] != that1.ReadonlyPaths[i] {
			return false
		}
	}
	if this.MountLabel != that1.MountLabel {
		return false
	}
	if !this.IntelRdt.Equal(that1.IntelRdt) {
		return false
	}
	return true
}
func (this *Windows) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Windows)
	if !ok {
		that2, ok := that.(Windows)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dummy != that1.Dummy {
		return false
	}
	return true
}
func (this *Solaris) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Solaris)
	if !ok {
		that2, ok := that.(Solaris)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dummy != that1.Dummy {
		return false
	}
	return true
}
func (this *LinuxIDMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxIDMapping)
	if !ok {
		that2, ok := that.(LinuxIDMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostID != that1.HostID {
		return false
	}
	if this.ContainerID != that1.ContainerID {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	return true
}
func (this *LinuxNamespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxNamespace)
	if !ok {
		that2, ok := that.(LinuxNamespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *LinuxDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxDevice)
	if !ok {
		that2, ok := that.(LinuxDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.UID != that1.UID {
		return false
	}
	if this.GID != that1.GID {
		return false
	}
	return true
}
func (this *LinuxResources) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxResources)
	if !ok {
		that2, ok := that.(LinuxResources)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(&that1.Devices[i]) {
			return false
		}
	}
	if !this.Memory.Equal(that1.Memory) {
		return false
	}
	if !this.CPU.Equal(that1.CPU) {
		return false
	}
	if !this.Pids.Equal(that1.Pids) {
		return false
	}
	if !this.BlockIO.Equal(that1.BlockIO) {
		return false
	}
	if len(this.HugepageLimits) != len(that1.HugepageLimits) {
		return false
	}
	for i := range this.HugepageLimits {
		if !this.HugepageLimits[i].Equal(&that1.HugepageLimits[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	return true
}
func (this *LinuxMemory) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxMemory)
	if !ok {
		that2, ok := that.(LinuxMemory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Reservation != that1.Reservation {
		return false
	}
	if this.Swap != that1.Swap {
		return false
	}
	if this.Kernel != that1.Kernel {
		return false
	}
	if this.KernelTCP != that1.KernelTCP {
		return false
	}
	if this.Swappiness != that1.Swappiness {
		return false
	}
	if this.DisableOOMKiller != that1.DisableOOMKiller {
		return false
	}
	return true
}
func (this *LinuxCPU) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxCPU)
	if !ok {
		that2, ok := that.(LinuxCPU)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Shares != that1.Shares {
		return false
	}
	if this.Quota != that1.Quota {
		return false
	}
	if this.Period != that1.Period {
		return false
	}
	if this.RealtimeRuntime != that1.RealtimeRuntime {
		return false
	}
	if this.RealtimePeriod != that1.RealtimePeriod {
		return false
	}
	if this.Cpus != that1.Cpus {
		return false
	}
	if this.Mems != that1.Mems {
		return false
	}
	return true
}
func (this *LinuxWeightDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxWeightDevice)
	if !ok {
		that2, ok := that.(LinuxWeightDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.LeafWeight != that1.LeafWeight {
		return false
	}
	return true
}
func (this *LinuxThrottleDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxThrottleDevice)
	if !ok {
		that2, ok := that.(LinuxThrottleDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *LinuxBlockIO) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxBlockIO)
	if !ok {
		that2, ok := that.(LinuxBlockIO)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.LeafWeight != that1.LeafWeight {
		return false
	}
	if len(this.WeightDevice) != len(that1.WeightDevice) {
		return false
	}
	for i := range this.WeightDevice {
		if !this.WeightDevice[i].Equal(&that1.WeightDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleReadBpsDevice) != len(that1.ThrottleReadBpsDevice) {
		return false
	}
	for i := range this.ThrottleReadBpsDevice {
		if !this.ThrottleReadBpsDevice[i].Equal(&that1.ThrottleReadBpsDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleWriteBpsDevice) != len(that1.ThrottleWriteBpsDevice) {
		return false
	}
	for i := range this.ThrottleWriteBpsDevice {
		if !this.ThrottleWriteBpsDevice[i].Equal(&that1.ThrottleWriteBpsDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleReadIOPSDevice) != len(that1.ThrottleReadIOPSDevice) {
		return false
	}
	for i := range this.ThrottleReadIOPSDevice {
		if !this.ThrottleReadIOPSDevice[i].Equal(&that1.ThrottleReadIOPSDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleWriteIOPSDevice) != len(that1.ThrottleWriteIOPSDevice) {
		return false
	}
	for i := range this.ThrottleWriteIOPSDevice {
		if !this.ThrottleWriteIOPSDevice[i].Equal(&that1.ThrottleWriteIOPSDevice[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxPids) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxPids)
	if !ok {
		that2, ok := that.(LinuxPids)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *LinuxDeviceCgroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxDeviceCgroup)
	if !ok {
		that2, ok := that.(LinuxDeviceCgroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Allow != that1.Allow {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Access != that1.Access {
		return false
	}
	return true
}
func (this *LinuxNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxNetwork)
	if !ok {
		that2, ok := that.(LinuxNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClassID != that1.ClassID {
		return false
	}
	if len(this.Priorities) != len(that1.Priorities) {
		return false
	}
	for i := range this.Priorities {
		if !this.Priorities[i].Equal(&that1.Priorities[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxHugepageLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxHugepageLimit)
	if !ok {
		that2, ok := that.(LinuxHugepageLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pagesize != that1.Pagesize {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *LinuxInterfacePriority) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxInterfacePriority)
	if !ok {
		that2, ok := that.(LinuxInterfacePriority)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (this *LinuxSeccomp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxSeccomp)
	if !ok {
		that2, ok := that.(LinuxSeccomp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefaultAction != that1.DefaultAction {
		return false
	}
	if len(this.Architectures) != len(that1.Architectures) {
		return false
	}
	for i := range this.Architectures {
		if this.Architectures[i] != that1.Architectures[i] {
			return false
		}
	}
	if len(this.Syscalls) != len(that1.Syscalls) {
		return false
	}
	for i := range this.Syscalls {
		if !this.Syscalls[i].Equal(&that1.Syscalls[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxSeccompArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxSeccompArg)
	if !ok {
		that2, ok := that.(LinuxSeccompArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.ValueTwo != that1.ValueTwo {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	return true
}
func (this *LinuxSyscall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxSyscall)
	if !ok {
		that2, ok := that.(LinuxSyscall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Names) != len(that1.Names) {
		return false
	}
	for i := range this.Names {
		if this.Names[i] != that1.Names[i] {
			return false
		}
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(&that1.Args[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxIntelRdt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinuxIntelRdt)
	if !ok {
		that2, ok := that.(LinuxIntelRdt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.L3CacheSchema != that1.L3CacheSchema {
		return false
	}
	return true
}
func (m *Spec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Process != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Process.Size()))
		n1, err := m.Process.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Root != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Root.Size()))
		n2, err := m.Root.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Hooks != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Hooks.Size()))
		n3, err := m.Hooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x3a
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovOci(uint64(len(k))) + 1 + len(v) + sovOci(uint64(len(v)))
			i = encodeVarintOci(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintOci(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintOci(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Linux != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Linux.Size()))
		n4, err := m.Linux.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Solaris != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Solaris.Size()))
		n5, err := m.Solaris.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Windows != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Windows.Size()))
		n6, err := m.Windows.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Terminal {
		dAtA[i] = 0x8
		i++
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConsoleSize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.ConsoleSize.Size()))
		n7, err := m.ConsoleSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintOci(dAtA, i, uint64(m.User.Size()))
	n8, err := m.User.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Cwd) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Cwd)))
		i += copy(dAtA[i:], m.Cwd)
	}
	if m.Capabilities != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Capabilities.Size()))
		n9, err := m.Capabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Rlimits) > 0 {
		for _, msg := range m.Rlimits {
			dAtA[i] = 0x42
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NoNewPrivileges {
		dAtA[i] = 0x48
		i++
		if m.NoNewPrivileges {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ApparmorProfile) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.ApparmorProfile)))
		i += copy(dAtA[i:], m.ApparmorProfile)
	}
	if m.OOMScoreAdj != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.OOMScoreAdj))
	}
	if len(m.SelinuxLabel) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.SelinuxLabel)))
		i += copy(dAtA[i:], m.SelinuxLabel)
	}
	return i, nil
}

func (m *Box) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Box) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Height))
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Width))
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.UID))
	}
	if m.GID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.GID))
	}
	if len(m.AdditionalGids) > 0 {
		dAtA11 := make([]byte, len(m.AdditionalGids)*10)
		var j10 int
		for _, num := range m.AdditionalGids {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOci(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *LinuxCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxCapabilities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bounding) > 0 {
		for _, s := range m.Bounding {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Effective) > 0 {
		for _, s := range m.Effective {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Inheritable) > 0 {
		for _, s := range m.Inheritable {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Permitted) > 0 {
		for _, s := range m.Permitted {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ambient) > 0 {
		for _, s := range m.Ambient {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *POSIXRlimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *POSIXRlimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Hard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Hard))
	}
	if m.Soft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Soft))
	}
	return i, nil
}

func (m *Mount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Root) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Root) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Readonly {
		dAtA[i] = 0x10
		i++
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Hooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prestart) > 0 {
		for _, msg := range m.Prestart {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Poststart) > 0 {
		for _, msg := range m.Poststart {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Poststop) > 0 {
		for _, msg := range m.Poststop {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Hook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Timeout))
	}
	return i, nil
}

func (m *Linux) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Linux) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UIDMappings) > 0 {
		for _, msg := range m.UIDMappings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GIDMappings) > 0 {
		for _, msg := range m.GIDMappings {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Sysctl) > 0 {
		for k, _ := range m.Sysctl {
			dAtA[i] = 0x1a
			i++
			v := m.Sysctl[k]
			mapSize := 1 + len(k) + sovOci(uint64(len(k))) + 1 + len(v) + sovOci(uint64(len(v)))
			i = encodeVarintOci(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintOci(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintOci(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Resources.Size()))
		n12, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.CgroupsPath) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.CgroupsPath)))
		i += copy(dAtA[i:], m.CgroupsPath)
	}
	if len(m.Namespaces) > 0 {
		for _, msg := range m.Namespaces {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seccomp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Seccomp.Size()))
		n13, err := m.Seccomp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.RootfsPropagation) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.RootfsPropagation)))
		i += copy(dAtA[i:], m.RootfsPropagation)
	}
	if len(m.MaskedPaths) > 0 {
		for _, s := range m.MaskedPaths {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReadonlyPaths) > 0 {
		for _, s := range m.ReadonlyPaths {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MountLabel) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.MountLabel)))
		i += copy(dAtA[i:], m.MountLabel)
	}
	if m.IntelRdt != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.IntelRdt.Size()))
		n14, err := m.IntelRdt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *Windows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Windows) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dummy) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Dummy)))
		i += copy(dAtA[i:], m.Dummy)
	}
	return i, nil
}

func (m *Solaris) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Solaris) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dummy) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Dummy)))
		i += copy(dAtA[i:], m.Dummy)
	}
	return i, nil
}

func (m *LinuxIDMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxIDMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.HostID))
	}
	if m.ContainerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.ContainerID))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *LinuxNamespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxNamespace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *LinuxDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Major != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Minor))
	}
	if m.FileMode != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.FileMode))
	}
	if m.UID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.UID))
	}
	if m.GID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.GID))
	}
	return i, nil
}

func (m *LinuxResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxResources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Memory != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Memory.Size()))
		n15, err := m.Memory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.CPU != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.CPU.Size()))
		n16, err := m.CPU.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Pids != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Pids.Size()))
		n17, err := m.Pids.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.BlockIO != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.BlockIO.Size()))
		n18, err := m.BlockIO.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.HugepageLimits) > 0 {
		for _, msg := range m.HugepageLimits {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Network != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Network.Size()))
		n19, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *LinuxMemory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxMemory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Limit))
	}
	if m.Reservation != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Reservation))
	}
	if m.Swap != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Swap))
	}
	if m.Kernel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Kernel))
	}
	if m.KernelTCP != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.KernelTCP))
	}
	if m.Swappiness != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Swappiness))
	}
	if m.DisableOOMKiller {
		dAtA[i] = 0x38
		i++
		if m.DisableOOMKiller {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LinuxCPU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxCPU) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shares != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Shares))
	}
	if m.Quota != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Quota))
	}
	if m.Period != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Period))
	}
	if m.RealtimeRuntime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.RealtimeRuntime))
	}
	if m.RealtimePeriod != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.RealtimePeriod))
	}
	if len(m.Cpus) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Cpus)))
		i += copy(dAtA[i:], m.Cpus)
	}
	if len(m.Mems) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Mems)))
		i += copy(dAtA[i:], m.Mems)
	}
	return i, nil
}

func (m *LinuxWeightDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxWeightDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Minor))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Weight))
	}
	if m.LeafWeight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.LeafWeight))
	}
	return i, nil
}

func (m *LinuxThrottleDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxThrottleDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Minor))
	}
	if m.Rate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *LinuxBlockIO) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxBlockIO) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Weight))
	}
	if m.LeafWeight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.LeafWeight))
	}
	if len(m.WeightDevice) > 0 {
		for _, msg := range m.WeightDevice {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ThrottleReadBpsDevice) > 0 {
		for _, msg := range m.ThrottleReadBpsDevice {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ThrottleWriteBpsDevice) > 0 {
		for _, msg := range m.ThrottleWriteBpsDevice {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ThrottleReadIOPSDevice) > 0 {
		for _, msg := range m.ThrottleReadIOPSDevice {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ThrottleWriteIOPSDevice) > 0 {
		for _, msg := range m.ThrottleWriteIOPSDevice {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinuxPids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxPids) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *LinuxDeviceCgroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxDeviceCgroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Allow {
		dAtA[i] = 0x8
		i++
		if m.Allow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Major != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Minor))
	}
	if len(m.Access) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Access)))
		i += copy(dAtA[i:], m.Access)
	}
	return i, nil
}

func (m *LinuxNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClassID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.ClassID))
	}
	if len(m.Priorities) > 0 {
		for _, msg := range m.Priorities {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinuxHugepageLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxHugepageLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pagesize) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Pagesize)))
		i += copy(dAtA[i:], m.Pagesize)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *LinuxInterfacePriority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxInterfacePriority) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Priority))
	}
	return i, nil
}

func (m *LinuxSeccomp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxSeccomp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefaultAction) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.DefaultAction)))
		i += copy(dAtA[i:], m.DefaultAction)
	}
	if len(m.Architectures) > 0 {
		for _, s := range m.Architectures {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Syscalls) > 0 {
		for _, msg := range m.Syscalls {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinuxSeccompArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxSeccompArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Index))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.Value))
	}
	if m.ValueTwo != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOci(dAtA, i, uint64(m.ValueTwo))
	}
	if len(m.Op) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Op)))
		i += copy(dAtA[i:], m.Op)
	}
	return i, nil
}

func (m *LinuxSyscall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxSyscall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.Args) > 0 {
		for _, msg := range m.Args {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOci(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinuxIntelRdt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxIntelRdt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.L3CacheSchema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOci(dAtA, i, uint64(len(m.L3CacheSchema)))
		i += copy(dAtA[i:], m.L3CacheSchema)
	}
	return i, nil
}

func encodeVarintOci(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedSpec(r randyOci, easy bool) *Spec {
	this := &Spec{}
	this.Version = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.Process = NewPopulatedProcess(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Root = NewPopulatedRoot(r, easy)
	}
	this.Hostname = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Mounts = make([]Mount, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedMount(r, easy)
			this.Mounts[i] = *v2
		}
	}
	if r.Intn(10) != 0 {
		this.Hooks = NewPopulatedHooks(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v3; i++ {
			this.Annotations[randStringOci(r)] = randStringOci(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Linux = NewPopulatedLinux(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Solaris = NewPopulatedSolaris(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Windows = NewPopulatedWindows(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProcess(r randyOci, easy bool) *Process {
	this := &Process{}
	this.Terminal = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.ConsoleSize = NewPopulatedBox(r, easy)
	}
	v4 := NewPopulatedUser(r, easy)
	this.User = *v4
	v5 := r.Intn(10)
	this.Args = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.Args[i] = string(randStringOci(r))
	}
	v6 := r.Intn(10)
	this.Env = make([]string, v6)
	for i := 0; i < v6; i++ {
		this.Env[i] = string(randStringOci(r))
	}
	this.Cwd = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.Capabilities = NewPopulatedLinuxCapabilities(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Rlimits = make([]POSIXRlimit, v7)
		for i := 0; i < v7; i++ {
			v8 := NewPopulatedPOSIXRlimit(r, easy)
			this.Rlimits[i] = *v8
		}
	}
	this.NoNewPrivileges = bool(bool(r.Intn(2) == 0))
	this.ApparmorProfile = string(randStringOci(r))
	this.OOMScoreAdj = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.OOMScoreAdj *= -1
	}
	this.SelinuxLabel = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBox(r randyOci, easy bool) *Box {
	this := &Box{}
	this.Height = uint32(r.Uint32())
	this.Width = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUser(r randyOci, easy bool) *User {
	this := &User{}
	this.UID = uint32(r.Uint32())
	this.GID = uint32(r.Uint32())
	v9 := r.Intn(10)
	this.AdditionalGids = make([]uint32, v9)
	for i := 0; i < v9; i++ {
		this.AdditionalGids[i] = uint32(r.Uint32())
	}
	this.Username = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxCapabilities(r randyOci, easy bool) *LinuxCapabilities {
	this := &LinuxCapabilities{}
	v10 := r.Intn(10)
	this.Bounding = make([]string, v10)
	for i := 0; i < v10; i++ {
		this.Bounding[i] = string(randStringOci(r))
	}
	v11 := r.Intn(10)
	this.Effective = make([]string, v11)
	for i := 0; i < v11; i++ {
		this.Effective[i] = string(randStringOci(r))
	}
	v12 := r.Intn(10)
	this.Inheritable = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.Inheritable[i] = string(randStringOci(r))
	}
	v13 := r.Intn(10)
	this.Permitted = make([]string, v13)
	for i := 0; i < v13; i++ {
		this.Permitted[i] = string(randStringOci(r))
	}
	v14 := r.Intn(10)
	this.Ambient = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.Ambient[i] = string(randStringOci(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPOSIXRlimit(r randyOci, easy bool) *POSIXRlimit {
	this := &POSIXRlimit{}
	this.Type = string(randStringOci(r))
	this.Hard = uint64(uint64(r.Uint32()))
	this.Soft = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMount(r randyOci, easy bool) *Mount {
	this := &Mount{}
	this.Destination = string(randStringOci(r))
	this.Source = string(randStringOci(r))
	this.Type = string(randStringOci(r))
	v15 := r.Intn(10)
	this.Options = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.Options[i] = string(randStringOci(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRoot(r randyOci, easy bool) *Root {
	this := &Root{}
	this.Path = string(randStringOci(r))
	this.Readonly = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHooks(r randyOci, easy bool) *Hooks {
	this := &Hooks{}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Prestart = make([]Hook, v16)
		for i := 0; i < v16; i++ {
			v17 := NewPopulatedHook(r, easy)
			this.Prestart[i] = *v17
		}
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Poststart = make([]Hook, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedHook(r, easy)
			this.Poststart[i] = *v19
		}
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Poststop = make([]Hook, v20)
		for i := 0; i < v20; i++ {
			v21 := NewPopulatedHook(r, easy)
			this.Poststop[i] = *v21
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHook(r randyOci, easy bool) *Hook {
	this := &Hook{}
	this.Path = string(randStringOci(r))
	v22 := r.Intn(10)
	this.Args = make([]string, v22)
	for i := 0; i < v22; i++ {
		this.Args[i] = string(randStringOci(r))
	}
	v23 := r.Intn(10)
	this.Env = make([]string, v23)
	for i := 0; i < v23; i++ {
		this.Env[i] = string(randStringOci(r))
	}
	this.Timeout = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinux(r randyOci, easy bool) *Linux {
	this := &Linux{}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.UIDMappings = make([]LinuxIDMapping, v24)
		for i := 0; i < v24; i++ {
			v25 := NewPopulatedLinuxIDMapping(r, easy)
			this.UIDMappings[i] = *v25
		}
	}
	if r.Intn(10) != 0 {
		v26 := r.Intn(5)
		this.GIDMappings = make([]LinuxIDMapping, v26)
		for i := 0; i < v26; i++ {
			v27 := NewPopulatedLinuxIDMapping(r, easy)
			this.GIDMappings[i] = *v27
		}
	}
	if r.Intn(10) != 0 {
		v28 := r.Intn(10)
		this.Sysctl = make(map[string]string)
		for i := 0; i < v28; i++ {
			this.Sysctl[randStringOci(r)] = randStringOci(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Resources = NewPopulatedLinuxResources(r, easy)
	}
	this.CgroupsPath = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v29 := r.Intn(5)
		this.Namespaces = make([]LinuxNamespace, v29)
		for i := 0; i < v29; i++ {
			v30 := NewPopulatedLinuxNamespace(r, easy)
			this.Namespaces[i] = *v30
		}
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(5)
		this.Devices = make([]LinuxDevice, v31)
		for i := 0; i < v31; i++ {
			v32 := NewPopulatedLinuxDevice(r, easy)
			this.Devices[i] = *v32
		}
	}
	if r.Intn(10) != 0 {
		this.Seccomp = NewPopulatedLinuxSeccomp(r, easy)
	}
	this.RootfsPropagation = string(randStringOci(r))
	v33 := r.Intn(10)
	this.MaskedPaths = make([]string, v33)
	for i := 0; i < v33; i++ {
		this.MaskedPaths[i] = string(randStringOci(r))
	}
	v34 := r.Intn(10)
	this.ReadonlyPaths = make([]string, v34)
	for i := 0; i < v34; i++ {
		this.ReadonlyPaths[i] = string(randStringOci(r))
	}
	this.MountLabel = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.IntelRdt = NewPopulatedLinuxIntelRdt(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWindows(r randyOci, easy bool) *Windows {
	this := &Windows{}
	this.Dummy = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSolaris(r randyOci, easy bool) *Solaris {
	this := &Solaris{}
	this.Dummy = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxIDMapping(r randyOci, easy bool) *LinuxIDMapping {
	this := &LinuxIDMapping{}
	this.HostID = uint32(r.Uint32())
	this.ContainerID = uint32(r.Uint32())
	this.Size_ = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxNamespace(r randyOci, easy bool) *LinuxNamespace {
	this := &LinuxNamespace{}
	this.Type = string(randStringOci(r))
	this.Path = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxDevice(r randyOci, easy bool) *LinuxDevice {
	this := &LinuxDevice{}
	this.Path = string(randStringOci(r))
	this.Type = string(randStringOci(r))
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.FileMode = uint32(r.Uint32())
	this.UID = uint32(r.Uint32())
	this.GID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxResources(r randyOci, easy bool) *LinuxResources {
	this := &LinuxResources{}
	if r.Intn(10) != 0 {
		v35 := r.Intn(5)
		this.Devices = make([]LinuxDeviceCgroup, v35)
		for i := 0; i < v35; i++ {
			v36 := NewPopulatedLinuxDeviceCgroup(r, easy)
			this.Devices[i] = *v36
		}
	}
	if r.Intn(10) != 0 {
		this.Memory = NewPopulatedLinuxMemory(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CPU = NewPopulatedLinuxCPU(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Pids = NewPopulatedLinuxPids(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BlockIO = NewPopulatedLinuxBlockIO(r, easy)
	}
	if r.Intn(10) != 0 {
		v37 := r.Intn(5)
		this.HugepageLimits = make([]LinuxHugepageLimit, v37)
		for i := 0; i < v37; i++ {
			v38 := NewPopulatedLinuxHugepageLimit(r, easy)
			this.HugepageLimits[i] = *v38
		}
	}
	if r.Intn(10) != 0 {
		this.Network = NewPopulatedLinuxNetwork(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxMemory(r randyOci, easy bool) *LinuxMemory {
	this := &LinuxMemory{}
	this.Limit = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Limit *= -1
	}
	this.Reservation = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Reservation *= -1
	}
	this.Swap = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Swap *= -1
	}
	this.Kernel = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Kernel *= -1
	}
	this.KernelTCP = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KernelTCP *= -1
	}
	this.Swappiness = uint64(uint64(r.Uint32()))
	this.DisableOOMKiller = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxCPU(r randyOci, easy bool) *LinuxCPU {
	this := &LinuxCPU{}
	this.Shares = uint64(uint64(r.Uint32()))
	this.Quota = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Quota *= -1
	}
	this.Period = uint64(uint64(r.Uint32()))
	this.RealtimeRuntime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.RealtimeRuntime *= -1
	}
	this.RealtimePeriod = uint64(uint64(r.Uint32()))
	this.Cpus = string(randStringOci(r))
	this.Mems = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxWeightDevice(r randyOci, easy bool) *LinuxWeightDevice {
	this := &LinuxWeightDevice{}
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Weight = uint32(r.Uint32())
	this.LeafWeight = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxThrottleDevice(r randyOci, easy bool) *LinuxThrottleDevice {
	this := &LinuxThrottleDevice{}
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Rate = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxBlockIO(r randyOci, easy bool) *LinuxBlockIO {
	this := &LinuxBlockIO{}
	this.Weight = uint32(r.Uint32())
	this.LeafWeight = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v39 := r.Intn(5)
		this.WeightDevice = make([]LinuxWeightDevice, v39)
		for i := 0; i < v39; i++ {
			v40 := NewPopulatedLinuxWeightDevice(r, easy)
			this.WeightDevice[i] = *v40
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(5)
		this.ThrottleReadBpsDevice = make([]LinuxThrottleDevice, v41)
		for i := 0; i < v41; i++ {
			v42 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleReadBpsDevice[i] = *v42
		}
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(5)
		this.ThrottleWriteBpsDevice = make([]LinuxThrottleDevice, v43)
		for i := 0; i < v43; i++ {
			v44 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleWriteBpsDevice[i] = *v44
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(5)
		this.ThrottleReadIOPSDevice = make([]LinuxThrottleDevice, v45)
		for i := 0; i < v45; i++ {
			v46 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleReadIOPSDevice[i] = *v46
		}
	}
	if r.Intn(10) != 0 {
		v47 := r.Intn(5)
		this.ThrottleWriteIOPSDevice = make([]LinuxThrottleDevice, v47)
		for i := 0; i < v47; i++ {
			v48 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleWriteIOPSDevice[i] = *v48
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxPids(r randyOci, easy bool) *LinuxPids {
	this := &LinuxPids{}
	this.Limit = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Limit *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxDeviceCgroup(r randyOci, easy bool) *LinuxDeviceCgroup {
	this := &LinuxDeviceCgroup{}
	this.Allow = bool(bool(r.Intn(2) == 0))
	this.Type = string(randStringOci(r))
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Access = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxNetwork(r randyOci, easy bool) *LinuxNetwork {
	this := &LinuxNetwork{}
	this.ClassID = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v49 := r.Intn(5)
		this.Priorities = make([]LinuxInterfacePriority, v49)
		for i := 0; i < v49; i++ {
			v50 := NewPopulatedLinuxInterfacePriority(r, easy)
			this.Priorities[i] = *v50
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxHugepageLimit(r randyOci, easy bool) *LinuxHugepageLimit {
	this := &LinuxHugepageLimit{}
	this.Pagesize = string(randStringOci(r))
	this.Limit = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxInterfacePriority(r randyOci, easy bool) *LinuxInterfacePriority {
	this := &LinuxInterfacePriority{}
	this.Name = string(randStringOci(r))
	this.Priority = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSeccomp(r randyOci, easy bool) *LinuxSeccomp {
	this := &LinuxSeccomp{}
	this.DefaultAction = string(randStringOci(r))
	v51 := r.Intn(10)
	this.Architectures = make([]string, v51)
	for i := 0; i < v51; i++ {
		this.Architectures[i] = string(randStringOci(r))
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(5)
		this.Syscalls = make([]LinuxSyscall, v52)
		for i := 0; i < v52; i++ {
			v53 := NewPopulatedLinuxSyscall(r, easy)
			this.Syscalls[i] = *v53
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSeccompArg(r randyOci, easy bool) *LinuxSeccompArg {
	this := &LinuxSeccompArg{}
	this.Index = uint64(uint64(r.Uint32()))
	this.Value = uint64(uint64(r.Uint32()))
	this.ValueTwo = uint64(uint64(r.Uint32()))
	this.Op = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSyscall(r randyOci, easy bool) *LinuxSyscall {
	this := &LinuxSyscall{}
	v54 := r.Intn(10)
	this.Names = make([]string, v54)
	for i := 0; i < v54; i++ {
		this.Names[i] = string(randStringOci(r))
	}
	this.Action = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v55 := r.Intn(5)
		this.Args = make([]LinuxSeccompArg, v55)
		for i := 0; i < v55; i++ {
			v56 := NewPopulatedLinuxSeccompArg(r, easy)
			this.Args[i] = *v56
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxIntelRdt(r randyOci, easy bool) *LinuxIntelRdt {
	this := &LinuxIntelRdt{}
	this.L3CacheSchema = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyOci interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOci(r randyOci) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOci(r randyOci) string {
	v57 := r.Intn(100)
	tmps := make([]rune, v57)
	for i := 0; i < v57; i++ {
		tmps[i] = randUTF8RuneOci(r)
	}
	return string(tmps)
}
func randUnrecognizedOci(r randyOci, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldOci(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldOci(dAtA []byte, r randyOci, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		v58 := r.Int63()
		if r.Intn(2) == 0 {
			v58 *= -1
		}
		dAtA = encodeVarintPopulateOci(dAtA, uint64(v58))
	case 1:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateOci(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateOci(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Spec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Process != nil {
		l = m.Process.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Root != nil {
		l = m.Root.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.Hooks != nil {
		l = m.Hooks.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOci(uint64(len(k))) + 1 + len(v) + sovOci(uint64(len(v)))
			n += mapEntrySize + 1 + sovOci(uint64(mapEntrySize))
		}
	}
	if m.Linux != nil {
		l = m.Linux.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Solaris != nil {
		l = m.Solaris.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	if m.Terminal {
		n += 2
	}
	if m.ConsoleSize != nil {
		l = m.ConsoleSize.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	l = m.User.Size()
	n += 1 + l + sovOci(uint64(l))
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	l = len(m.Cwd)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Capabilities != nil {
		l = m.Capabilities.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Rlimits) > 0 {
		for _, e := range m.Rlimits {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.NoNewPrivileges {
		n += 2
	}
	l = len(m.ApparmorProfile)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.OOMScoreAdj != 0 {
		n += 1 + sovOci(uint64(m.OOMScoreAdj))
	}
	l = len(m.SelinuxLabel)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *Box) Size() (n int) {
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovOci(uint64(m.Height))
	}
	if m.Width != 0 {
		n += 1 + sovOci(uint64(m.Width))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovOci(uint64(m.UID))
	}
	if m.GID != 0 {
		n += 1 + sovOci(uint64(m.GID))
	}
	if len(m.AdditionalGids) > 0 {
		l = 0
		for _, e := range m.AdditionalGids {
			l += sovOci(uint64(e))
		}
		n += 1 + sovOci(uint64(l)) + l
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxCapabilities) Size() (n int) {
	var l int
	_ = l
	if len(m.Bounding) > 0 {
		for _, s := range m.Bounding {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Effective) > 0 {
		for _, s := range m.Effective {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Inheritable) > 0 {
		for _, s := range m.Inheritable {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Permitted) > 0 {
		for _, s := range m.Permitted {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Ambient) > 0 {
		for _, s := range m.Ambient {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *POSIXRlimit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Hard != 0 {
		n += 1 + sovOci(uint64(m.Hard))
	}
	if m.Soft != 0 {
		n += 1 + sovOci(uint64(m.Soft))
	}
	return n
}

func (m *Mount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *Root) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Readonly {
		n += 2
	}
	return n
}

func (m *Hooks) Size() (n int) {
	var l int
	_ = l
	if len(m.Prestart) > 0 {
		for _, e := range m.Prestart {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Poststart) > 0 {
		for _, e := range m.Poststart {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Poststop) > 0 {
		for _, e := range m.Poststop {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *Hook) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.Timeout != 0 {
		n += 1 + sovOci(uint64(m.Timeout))
	}
	return n
}

func (m *Linux) Size() (n int) {
	var l int
	_ = l
	if len(m.UIDMappings) > 0 {
		for _, e := range m.UIDMappings {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.GIDMappings) > 0 {
		for _, e := range m.GIDMappings {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Sysctl) > 0 {
		for k, v := range m.Sysctl {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOci(uint64(len(k))) + 1 + len(v) + sovOci(uint64(len(v)))
			n += mapEntrySize + 1 + sovOci(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.CgroupsPath)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.Seccomp != nil {
		l = m.Seccomp.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.RootfsPropagation)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.MaskedPaths) > 0 {
		for _, s := range m.MaskedPaths {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.ReadonlyPaths) > 0 {
		for _, s := range m.ReadonlyPaths {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	l = len(m.MountLabel)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.IntelRdt != nil {
		l = m.IntelRdt.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *Windows) Size() (n int) {
	var l int
	_ = l
	l = len(m.Dummy)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *Solaris) Size() (n int) {
	var l int
	_ = l
	l = len(m.Dummy)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxIDMapping) Size() (n int) {
	var l int
	_ = l
	if m.HostID != 0 {
		n += 1 + sovOci(uint64(m.HostID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovOci(uint64(m.ContainerID))
	}
	if m.Size_ != 0 {
		n += 1 + sovOci(uint64(m.Size_))
	}
	return n
}

func (m *LinuxNamespace) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Major != 0 {
		n += 1 + sovOci(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovOci(uint64(m.Minor))
	}
	if m.FileMode != 0 {
		n += 1 + sovOci(uint64(m.FileMode))
	}
	if m.UID != 0 {
		n += 1 + sovOci(uint64(m.UID))
	}
	if m.GID != 0 {
		n += 1 + sovOci(uint64(m.GID))
	}
	return n
}

func (m *LinuxResources) Size() (n int) {
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.CPU != nil {
		l = m.CPU.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Pids != nil {
		l = m.Pids.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if m.BlockIO != nil {
		l = m.BlockIO.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.HugepageLimits) > 0 {
		for _, e := range m.HugepageLimits {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxMemory) Size() (n int) {
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovOci(uint64(m.Limit))
	}
	if m.Reservation != 0 {
		n += 1 + sovOci(uint64(m.Reservation))
	}
	if m.Swap != 0 {
		n += 1 + sovOci(uint64(m.Swap))
	}
	if m.Kernel != 0 {
		n += 1 + sovOci(uint64(m.Kernel))
	}
	if m.KernelTCP != 0 {
		n += 1 + sovOci(uint64(m.KernelTCP))
	}
	if m.Swappiness != 0 {
		n += 1 + sovOci(uint64(m.Swappiness))
	}
	if m.DisableOOMKiller {
		n += 2
	}
	return n
}

func (m *LinuxCPU) Size() (n int) {
	var l int
	_ = l
	if m.Shares != 0 {
		n += 1 + sovOci(uint64(m.Shares))
	}
	if m.Quota != 0 {
		n += 1 + sovOci(uint64(m.Quota))
	}
	if m.Period != 0 {
		n += 1 + sovOci(uint64(m.Period))
	}
	if m.RealtimeRuntime != 0 {
		n += 1 + sovOci(uint64(m.RealtimeRuntime))
	}
	if m.RealtimePeriod != 0 {
		n += 1 + sovOci(uint64(m.RealtimePeriod))
	}
	l = len(m.Cpus)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	l = len(m.Mems)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxWeightDevice) Size() (n int) {
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovOci(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovOci(uint64(m.Minor))
	}
	if m.Weight != 0 {
		n += 1 + sovOci(uint64(m.Weight))
	}
	if m.LeafWeight != 0 {
		n += 1 + sovOci(uint64(m.LeafWeight))
	}
	return n
}

func (m *LinuxThrottleDevice) Size() (n int) {
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovOci(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovOci(uint64(m.Minor))
	}
	if m.Rate != 0 {
		n += 1 + sovOci(uint64(m.Rate))
	}
	return n
}

func (m *LinuxBlockIO) Size() (n int) {
	var l int
	_ = l
	if m.Weight != 0 {
		n += 1 + sovOci(uint64(m.Weight))
	}
	if m.LeafWeight != 0 {
		n += 1 + sovOci(uint64(m.LeafWeight))
	}
	if len(m.WeightDevice) > 0 {
		for _, e := range m.WeightDevice {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.ThrottleReadBpsDevice) > 0 {
		for _, e := range m.ThrottleReadBpsDevice {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.ThrottleWriteBpsDevice) > 0 {
		for _, e := range m.ThrottleWriteBpsDevice {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.ThrottleReadIOPSDevice) > 0 {
		for _, e := range m.ThrottleReadIOPSDevice {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.ThrottleWriteIOPSDevice) > 0 {
		for _, e := range m.ThrottleWriteIOPSDevice {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *LinuxPids) Size() (n int) {
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovOci(uint64(m.Limit))
	}
	return n
}

func (m *LinuxDeviceCgroup) Size() (n int) {
	var l int
	_ = l
	if m.Allow {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Major != 0 {
		n += 1 + sovOci(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovOci(uint64(m.Minor))
	}
	l = len(m.Access)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxNetwork) Size() (n int) {
	var l int
	_ = l
	if m.ClassID != 0 {
		n += 1 + sovOci(uint64(m.ClassID))
	}
	if len(m.Priorities) > 0 {
		for _, e := range m.Priorities {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *LinuxHugepageLimit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pagesize)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovOci(uint64(m.Limit))
	}
	return n
}

func (m *LinuxInterfacePriority) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovOci(uint64(m.Priority))
	}
	return n
}

func (m *LinuxSeccomp) Size() (n int) {
	var l int
	_ = l
	l = len(m.DefaultAction)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Architectures) > 0 {
		for _, s := range m.Architectures {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	if len(m.Syscalls) > 0 {
		for _, e := range m.Syscalls {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *LinuxSeccompArg) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovOci(uint64(m.Index))
	}
	if m.Value != 0 {
		n += 1 + sovOci(uint64(m.Value))
	}
	if m.ValueTwo != 0 {
		n += 1 + sovOci(uint64(m.ValueTwo))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func (m *LinuxSyscall) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovOci(uint64(l))
		}
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovOci(uint64(l))
		}
	}
	return n
}

func (m *LinuxIntelRdt) Size() (n int) {
	var l int
	_ = l
	l = len(m.L3CacheSchema)
	if l > 0 {
		n += 1 + l + sovOci(uint64(l))
	}
	return n
}

func sovOci(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOci(x uint64) (n int) {
	return sovOci(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Process == nil {
				m.Process = &Process{}
			}
			if err := m.Process.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Root == nil {
				m.Root = &Root{}
			}
			if err := m.Root.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, Mount{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hooks == nil {
				m.Hooks = &Hooks{}
			}
			if err := m.Hooks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOci
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOci
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOci
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOci
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOci
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOci(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOci
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linux", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Linux == nil {
				m.Linux = &Linux{}
			}
			if err := m.Linux.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Solaris", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Solaris == nil {
				m.Solaris = &Solaris{}
			}
			if err := m.Solaris.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &Windows{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsoleSize == nil {
				m.ConsoleSize = &Box{}
			}
			if err := m.ConsoleSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capabilities == nil {
				m.Capabilities = &LinuxCapabilities{}
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rlimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rlimits = append(m.Rlimits, POSIXRlimit{})
			if err := m.Rlimits[len(m.Rlimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoNewPrivileges", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoNewPrivileges = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApparmorProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApparmorProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OOMScoreAdj", wireType)
			}
			m.OOMScoreAdj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OOMScoreAdj |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelinuxLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelinuxLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Box) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Box: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Box: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			m.GID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOci
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AdditionalGids = append(m.AdditionalGids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOci
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOci
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOci
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AdditionalGids = append(m.AdditionalGids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalGids", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bounding = append(m.Bounding, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effective", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effective = append(m.Effective, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inheritable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inheritable = append(m.Inheritable, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permitted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permitted = append(m.Permitted, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ambient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ambient = append(m.Ambient, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *POSIXRlimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: POSIXRlimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: POSIXRlimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hard", wireType)
			}
			m.Hard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hard |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			m.Soft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soft |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Root) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Root: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Root: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prestart = append(m.Prestart, Hook{})
			if err := m.Prestart[len(m.Prestart)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poststart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poststart = append(m.Poststart, Hook{})
			if err := m.Poststart[len(m.Poststart)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poststop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poststop = append(m.Poststop, Hook{})
			if err := m.Poststop[len(m.Poststop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Linux) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Linux: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Linux: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UIDMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UIDMappings = append(m.UIDMappings, LinuxIDMapping{})
			if err := m.UIDMappings[len(m.UIDMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GIDMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GIDMappings = append(m.GIDMappings, LinuxIDMapping{})
			if err := m.GIDMappings[len(m.GIDMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sysctl == nil {
				m.Sysctl = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOci
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOci
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOci
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOci
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOci
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOci(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOci
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sysctl[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &LinuxResources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, LinuxNamespace{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, LinuxDevice{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seccomp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seccomp == nil {
				m.Seccomp = &LinuxSeccomp{}
			}
			if err := m.Seccomp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootfsPropagation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootfsPropagation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskedPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaskedPaths = append(m.MaskedPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadonlyPaths = append(m.ReadonlyPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntelRdt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntelRdt == nil {
				m.IntelRdt = &LinuxIntelRdt{}
			}
			if err := m.IntelRdt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Windows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Windows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Windows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dummy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Solaris) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Solaris: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Solaris: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dummy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxIDMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxIDMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxIDMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			m.HostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxNamespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxNamespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxNamespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			m.GID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, LinuxDeviceCgroup{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &LinuxMemory{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CPU == nil {
				m.CPU = &LinuxCPU{}
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pids == nil {
				m.Pids = &LinuxPids{}
			}
			if err := m.Pids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockIO", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockIO == nil {
				m.BlockIO = &LinuxBlockIO{}
			}
			if err := m.BlockIO.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugepageLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HugepageLimits = append(m.HugepageLimits, LinuxHugepageLimit{})
			if err := m.HugepageLimits[len(m.HugepageLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &LinuxNetwork{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxMemory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxMemory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxMemory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservation", wireType)
			}
			m.Reservation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reservation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Swap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			m.Kernel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kernel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTCP", wireType)
			}
			m.KernelTCP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTCP |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swappiness", wireType)
			}
			m.Swappiness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Swappiness |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOOMKiller", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOOMKiller = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxCPU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxCPU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxCPU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			m.Shares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shares |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			m.Quota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealtimeRuntime", wireType)
			}
			m.RealtimeRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealtimeRuntime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealtimePeriod", wireType)
			}
			m.RealtimePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealtimePeriod |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxWeightDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxWeightDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxWeightDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafWeight", wireType)
			}
			m.LeafWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafWeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxThrottleDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxThrottleDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxThrottleDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxBlockIO) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxBlockIO: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxBlockIO: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafWeight", wireType)
			}
			m.LeafWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafWeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightDevice = append(m.WeightDevice, LinuxWeightDevice{})
			if err := m.WeightDevice[len(m.WeightDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottleReadBpsDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottleReadBpsDevice = append(m.ThrottleReadBpsDevice, LinuxThrottleDevice{})
			if err := m.ThrottleReadBpsDevice[len(m.ThrottleReadBpsDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottleWriteBpsDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottleWriteBpsDevice = append(m.ThrottleWriteBpsDevice, LinuxThrottleDevice{})
			if err := m.ThrottleWriteBpsDevice[len(m.ThrottleWriteBpsDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottleReadIOPSDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottleReadIOPSDevice = append(m.ThrottleReadIOPSDevice, LinuxThrottleDevice{})
			if err := m.ThrottleReadIOPSDevice[len(m.ThrottleReadIOPSDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottleWriteIOPSDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottleWriteIOPSDevice = append(m.ThrottleWriteIOPSDevice, LinuxThrottleDevice{})
			if err := m.ThrottleWriteIOPSDevice[len(m.ThrottleWriteIOPSDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxPids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxPids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxPids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxDeviceCgroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxDeviceCgroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxDeviceCgroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allow = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Access = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassID", wireType)
			}
			m.ClassID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priorities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Priorities = append(m.Priorities, LinuxInterfacePriority{})
			if err := m.Priorities[len(m.Priorities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxHugepageLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxHugepageLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxHugepageLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagesize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pagesize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxInterfacePriority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxInterfacePriority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxInterfacePriority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxSeccomp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxSeccomp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxSeccomp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architectures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architectures = append(m.Architectures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Syscalls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Syscalls = append(m.Syscalls, LinuxSyscall{})
			if err := m.Syscalls[len(m.Syscalls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxSeccompArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxSeccompArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxSeccompArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueTwo", wireType)
			}
			m.ValueTwo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueTwo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxSyscall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxSyscall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxSyscall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, LinuxSeccompArg{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxIntelRdt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOci
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxIntelRdt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxIntelRdt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3CacheSchema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOci
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOci
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L3CacheSchema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOci(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOci
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOci(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOci
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOci
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOci
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOci
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOci
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOci(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOci = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOci   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("oci.proto", fileDescriptorOci) }

var fileDescriptorOci = []byte{
	// 2035 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x18, 0x4b, 0x6f, 0x23, 0x49,
	0x99, 0xb6, 0x1d, 0xc7, 0x2e, 0x27, 0x99, 0x99, 0xda, 0xd9, 0x6c, 0x13, 0x46, 0xde, 0x6c, 0x33,
	0x82, 0x00, 0x43, 0x22, 0x66, 0x78, 0x2c, 0xcb, 0x43, 0x72, 0x92, 0x99, 0x89, 0xb5, 0xc9, 0xc4,
	0x94, 0x93, 0x0d, 0x70, 0x40, 0xea, 0xb4, 0x2b, 0x76, 0x6d, 0xda, 0x5d, 0xad, 0xea, 0x72, 0x32,
	0xe1, 0xc6, 0x3f, 0x40, 0xe2, 0x17, 0x70, 0x02, 0xfe, 0x01, 0xe2, 0xc4, 0x8d, 0x15, 0x27, 0xee,
	0x48, 0x3c, 0x72, 0xe7, 0xce, 0x11, 0x7d, 0x55, 0x5f, 0xb5, 0xcb, 0x4e, 0x02, 0x3b, 0xec, 0xc9,
	0xf5, 0x3d, 0xab, 0xbe, 0xf7, 0xd7, 0x26, 0x4d, 0x99, 0x88, 0xcd, 0x5c, 0x49, 0x2d, 0x69, 0x6d,
	0xa8, 0xf2, 0x64, 0xed, 0xeb, 0x43, 0xa1, 0x47, 0x93, 0xd3, 0xcd, 0x44, 0x8e, 0xb7, 0x86, 0x72,
	0x28, 0xb7, 0x0c, 0xf1, 0x74, 0x72, 0x66, 0x20, 0x03, 0x98, 0x93, 0x15, 0x5a, 0x6b, 0x0f, 0xa5,
	0x1c, 0xa6, 0x7c, 0xca, 0x75, 0xa9, 0xe2, 0x3c, 0xe7, 0xaa, 0xb0, 0xf4, 0xe8, 0x4f, 0x55, 0x52,
	0xeb, 0xe7, 0x3c, 0xa1, 0x21, 0x59, 0xfc, 0x88, 0xab, 0x42, 0xc8, 0x2c, 0x0c, 0xd6, 0x83, 0x8d,
	0x26, 0x73, 0x20, 0xfd, 0x32, 0x59, 0xec, 0x29, 0x99, 0xf0, 0xa2, 0x08, 0x2b, 0xeb, 0xc1, 0x46,
	0xeb, 0xe9, 0xf2, 0x26, 0xbc, 0x64, 0x13, 0x91, 0xcc, 0x51, 0x69, 0x9b, 0xd4, 0x98, 0x94, 0x3a,
	0xac, 0x1a, 0x2e, 0x62, 0xb9, 0x00, 0xc3, 0x0c, 0x9e, 0xae, 0x91, 0xc6, 0x9e, 0x2c, 0x74, 0x16,
	0x8f, 0x79, 0x58, 0x33, 0x77, 0x94, 0x30, 0xfd, 0x0a, 0xa9, 0x1f, 0xc8, 0x49, 0xa6, 0x8b, 0x70,
	0x61, 0xbd, 0xba, 0xd1, 0x7a, 0xda, 0xb2, 0xd2, 0x06, 0xb7, 0x5d, 0xfb, 0xe4, 0x6f, 0xef, 0x7e,
	0x8e, 0x21, 0x03, 0x7d, 0x8f, 0x2c, 0xec, 0x49, 0x79, 0x5e, 0x84, 0x75, 0x73, 0x0f, 0x72, 0x1a,
	0x14, 0xb3, 0x14, 0xfa, 0x03, 0xd2, 0xea, 0x64, 0x99, 0xd4, 0xb1, 0x16, 0x32, 0x2b, 0xc2, 0x45,
	0xa3, 0xf2, 0x0b, 0x96, 0x11, 0xac, 0xdd, 0xf4, 0xa8, 0xcf, 0x33, 0xad, 0xae, 0x98, 0xcf, 0x0f,
	0x37, 0xec, 0x8b, 0x6c, 0xf2, 0x3a, 0x6c, 0xf8, 0x37, 0x18, 0x14, 0xb3, 0x14, 0x70, 0x4a, 0x5f,
	0xa6, 0xb1, 0x12, 0x45, 0xd8, 0xf4, 0x9d, 0x82, 0x48, 0xe6, 0xa8, 0xc0, 0x78, 0x22, 0xb2, 0x81,
	0xbc, 0x2c, 0x42, 0xe2, 0x33, 0x22, 0x92, 0x39, 0xea, 0xda, 0x0f, 0xc9, 0xfd, 0xf9, 0x57, 0xd1,
	0xfb, 0xa4, 0x7a, 0xce, 0xaf, 0x30, 0x20, 0x70, 0xa4, 0x0f, 0xc9, 0xc2, 0x45, 0x9c, 0x4e, 0xb8,
	0x09, 0x45, 0x93, 0x59, 0xe0, 0x83, 0xca, 0xfb, 0x41, 0xf4, 0x87, 0x6a, 0x19, 0x27, 0xf0, 0xf4,
	0x11, 0x57, 0x63, 0x91, 0xc5, 0xa9, 0x11, 0x6e, 0xb0, 0x12, 0xa6, 0x5f, 0x23, 0xad, 0x1d, 0x99,
	0x15, 0x32, 0xe5, 0x7d, 0xf1, 0x73, 0x8e, 0x21, 0x6d, 0xda, 0x47, 0x6d, 0xcb, 0xd7, 0xcc, 0xa7,
	0xd2, 0xc7, 0xa4, 0x76, 0x5c, 0x70, 0x35, 0x1b, 0x52, 0xc0, 0x60, 0x4c, 0x0c, 0x95, 0x52, 0x52,
	0xeb, 0xa8, 0x61, 0x11, 0xd6, 0xd6, 0xab, 0x1b, 0x4d, 0x66, 0xce, 0xf0, 0xf4, 0xe7, 0xd9, 0x85,
	0x89, 0x66, 0x93, 0xc1, 0x11, 0x30, 0x3b, 0x97, 0x03, 0x13, 0xb5, 0x26, 0x83, 0x23, 0xfd, 0x1e,
	0x59, 0xda, 0x89, 0xf3, 0xf8, 0x54, 0xa4, 0x42, 0x0b, 0x0e, 0x71, 0x82, 0x5b, 0xde, 0xf1, 0xdc,
	0xed, 0x93, 0xd9, 0x0c, 0x33, 0xfd, 0x06, 0x59, 0x64, 0xa9, 0x18, 0x0b, 0x5d, 0x84, 0x0d, 0x13,
	0xdf, 0x07, 0x98, 0x96, 0x87, 0xfd, 0xee, 0x8f, 0x2d, 0x05, 0x1f, 0xe9, 0xf8, 0xe8, 0x06, 0xb9,
	0xf7, 0x4a, 0xbe, 0xe2, 0x97, 0x3d, 0x25, 0x2e, 0x44, 0xca, 0x87, 0xdc, 0x06, 0xaf, 0xc1, 0xe6,
	0xd1, 0xc0, 0xd9, 0xc9, 0xf3, 0x58, 0x8d, 0xa5, 0xea, 0x29, 0x79, 0x26, 0x52, 0x6e, 0xa2, 0xd7,
	0x64, 0xf3, 0x68, 0xba, 0x4e, 0x5a, 0x87, 0x87, 0x07, 0xfd, 0x44, 0x2a, 0xde, 0x19, 0x7c, 0x1c,
	0xb6, 0xd6, 0x83, 0x8d, 0x2a, 0xf3, 0x51, 0x34, 0x22, 0x4b, 0x7d, 0x9e, 0x82, 0x35, 0xfb, 0xf1,
	0x29, 0x4f, 0xc3, 0x25, 0xa3, 0x68, 0x06, 0x17, 0x3d, 0x23, 0xd5, 0x6d, 0xf9, 0x9a, 0xae, 0x92,
	0xfa, 0x1e, 0x17, 0xc3, 0x91, 0x36, 0x51, 0x5b, 0x66, 0x08, 0x41, 0xd4, 0x4f, 0xc4, 0x40, 0x8f,
	0x4c, 0xb4, 0x96, 0x99, 0x05, 0xa2, 0xcc, 0x06, 0x07, 0x1c, 0x7b, 0xdc, 0xdd, 0x45, 0x11, 0x38,
	0x02, 0xe6, 0x65, 0x77, 0x17, 0xb9, 0xe1, 0x48, 0xbf, 0x44, 0x56, 0x3a, 0x83, 0x81, 0x80, 0xdc,
	0x8a, 0xd3, 0x97, 0x62, 0x50, 0x84, 0xd5, 0xf5, 0xea, 0xc6, 0x32, 0x9b, 0xc3, 0x42, 0xe6, 0x80,
	0x4e, 0xbf, 0x46, 0x1d, 0x1c, 0xfd, 0x26, 0x20, 0x0f, 0x6e, 0x44, 0x05, 0x24, 0xb6, 0xe5, 0x24,
	0x1b, 0x88, 0x6c, 0x18, 0x06, 0x26, 0xda, 0x25, 0x4c, 0x1f, 0x91, 0xe6, 0xf3, 0xb3, 0x33, 0x9e,
	0x68, 0x71, 0x01, 0x99, 0x06, 0xc4, 0x29, 0x02, 0x5c, 0xd7, 0xcd, 0x46, 0x5c, 0x09, 0x1d, 0x9f,
	0xa6, 0xdc, 0x3c, 0xa8, 0xc9, 0x7c, 0x14, 0xc8, 0xf7, 0x20, 0x6f, 0xb5, 0xe6, 0x03, 0xcc, 0xae,
	0x29, 0x02, 0x5a, 0x56, 0x67, 0x7c, 0x2a, 0x78, 0xa6, 0x31, 0xcd, 0x1c, 0x18, 0x75, 0x49, 0xcb,
	0x4b, 0x03, 0xc8, 0xcf, 0xa3, 0xab, 0x9c, 0x63, 0x1d, 0x99, 0x33, 0xe0, 0xf6, 0x62, 0x35, 0x30,
	0x3e, 0xaa, 0x31, 0x73, 0x06, 0x5c, 0x5f, 0x9e, 0xd9, 0x06, 0x56, 0x63, 0xe6, 0x1c, 0x49, 0xb2,
	0x60, 0xfa, 0x0e, 0xbc, 0x76, 0xc0, 0x0b, 0x2d, 0x32, 0x53, 0xa0, 0xa8, 0xcb, 0x47, 0x41, 0xf4,
	0x0a, 0x39, 0x51, 0x89, 0x2b, 0x4e, 0x84, 0x40, 0xad, 0x86, 0xeb, 0xab, 0xf6, 0x7a, 0x38, 0xc3,
	0xdb, 0x65, 0x6e, 0xbb, 0x93, 0xb5, 0xcb, 0x81, 0xd1, 0xb7, 0x6d, 0x17, 0x05, 0xa9, 0x5e, 0xac,
	0x47, 0xee, 0xd1, 0x70, 0x06, 0x5f, 0x33, 0x1e, 0x0f, 0x64, 0x96, 0x5e, 0x99, 0x3b, 0x1a, 0xac,
	0x84, 0xa3, 0x5f, 0x05, 0xd8, 0x17, 0xe9, 0x13, 0xd2, 0xe8, 0x29, 0x5e, 0xe8, 0x58, 0x69, 0x13,
	0x91, 0xb2, 0x70, 0x81, 0x8c, 0x35, 0x51, 0x72, 0xd0, 0x4d, 0xd2, 0xec, 0xc9, 0x42, 0x5b, 0xf6,
	0xca, 0x1d, 0xec, 0x53, 0x16, 0xa3, 0xdd, 0x00, 0x32, 0x37, 0x21, 0xbb, 0x5d, 0x3b, 0x72, 0x44,
	0x3f, 0x25, 0x35, 0xc0, 0xdf, 0x6a, 0x8d, 0x6b, 0x1b, 0x95, 0x9b, 0x6d, 0xa3, 0x3a, 0x6d, 0x1b,
	0x21, 0x59, 0x3c, 0x12, 0x63, 0x2e, 0x27, 0xda, 0x24, 0x64, 0x95, 0x39, 0x30, 0xfa, 0xdd, 0x02,
	0xf6, 0x69, 0xfa, 0x7d, 0xd2, 0x3a, 0xee, 0xee, 0x1e, 0xc4, 0x79, 0x2e, 0xb2, 0x61, 0x81, 0x46,
	0x3f, 0xf4, 0xfa, 0x48, 0x49, 0xc4, 0x07, 0xfa, 0xec, 0x20, 0xfd, 0xd2, 0x93, 0xae, 0xfc, 0x6f,
	0x69, 0x8f, 0x9d, 0x6e, 0x91, 0x7a, 0xff, 0xaa, 0x48, 0x74, 0x8a, 0xde, 0xf0, 0xdb, 0xd7, 0xa6,
	0xa5, 0xd8, 0x11, 0x83, 0x6c, 0xf4, 0x29, 0x69, 0x32, 0x6e, 0x53, 0xa3, 0x30, 0x26, 0xcd, 0x5e,
	0x56, 0xd2, 0xd8, 0x94, 0x0d, 0x92, 0x6f, 0x67, 0xa8, 0xe4, 0x24, 0x2f, 0x8c, 0x17, 0x17, 0x6c,
	0xf2, 0x79, 0x28, 0xfa, 0x01, 0x21, 0xaf, 0xe2, 0x31, 0x2f, 0xf2, 0x18, 0xd4, 0xd6, 0x6f, 0xd8,
	0x50, 0x12, 0xd1, 0x06, 0x8f, 0x1b, 0x5a, 0xe9, 0x2e, 0xbf, 0x10, 0x09, 0x77, 0xa3, 0xf2, 0x81,
	0x27, 0x68, 0x29, 0xae, 0x95, 0x22, 0x1f, 0x7d, 0x42, 0x16, 0xfb, 0x3c, 0x49, 0xe4, 0x38, 0xc7,
	0x21, 0x49, 0x3d, 0x11, 0xa4, 0x30, 0xc7, 0x42, 0x9f, 0x90, 0x07, 0x90, 0xd3, 0x67, 0x45, 0x4f,
	0xc9, 0x3c, 0x1e, 0xda, 0x0a, 0x6a, 0x1a, 0x23, 0x6e, 0x12, 0xc0, 0xd8, 0x83, 0xb8, 0x38, 0xe7,
	0x03, 0x30, 0x0c, 0xc6, 0xa6, 0xe9, 0x0b, 0x1e, 0x8a, 0x3e, 0x26, 0xcb, 0x2e, 0xef, 0x2d, 0x4f,
	0xcb, 0xf0, 0xcc, 0x22, 0x69, 0x9b, 0x10, 0x53, 0xba, 0x7e, 0xdb, 0xf5, 0x30, 0x74, 0x8b, 0x34,
	0xba, 0x99, 0xe6, 0x29, 0x1b, 0xe8, 0x70, 0xd9, 0x18, 0xf1, 0x96, 0x1f, 0x74, 0x24, 0xb1, 0x92,
	0x69, 0xed, 0xbb, 0xa4, 0xe5, 0x05, 0xf4, 0x8d, 0xa6, 0xf3, 0xbb, 0xe5, 0x1a, 0x00, 0x4c, 0x83,
	0xc9, 0x78, 0xec, 0x04, 0x2d, 0x00, 0x0c, 0x6e, 0x65, 0xb8, 0x9d, 0xe1, 0x67, 0x64, 0x65, 0x36,
	0x19, 0xcd, 0xb4, 0x90, 0x85, 0x2e, 0x5b, 0x3f, 0x42, 0x26, 0x59, 0x64, 0xa6, 0x63, 0x91, 0x71,
	0x55, 0x4e, 0x01, 0x1f, 0x65, 0x1a, 0x1d, 0x0c, 0xff, 0xaa, 0x21, 0x99, 0x73, 0xf4, 0x3e, 0xea,
	0x2f, 0xf3, 0xe2, 0xae, 0xb6, 0x69, 0x32, 0xb0, 0x32, 0xad, 0xe3, 0xe8, 0xd7, 0x01, 0x69, 0x79,
	0xa9, 0x72, 0x57, 0xad, 0x1b, 0x5d, 0x15, 0x4f, 0xd7, 0x43, 0xb2, 0x70, 0x10, 0x7f, 0x2c, 0xed,
	0x76, 0x51, 0x65, 0x16, 0x30, 0x58, 0x91, 0x49, 0x85, 0xd5, 0x6e, 0x01, 0xe8, 0x7c, 0x2f, 0x44,
	0xca, 0x0f, 0xe4, 0x80, 0x9b, 0xec, 0x5f, 0x66, 0x25, 0xec, 0xe6, 0x5f, 0xfd, 0xc6, 0xfc, 0x5b,
	0x2c, 0xe7, 0x5f, 0xf4, 0xf7, 0x0a, 0x9a, 0x37, 0xad, 0xa9, 0xef, 0x4c, 0xb3, 0x3e, 0xb8, 0x51,
	0xb9, 0x96, 0x62, 0x0b, 0x6c, 0x3e, 0xf7, 0x61, 0x57, 0xe5, 0x63, 0xa9, 0xae, 0x70, 0x79, 0xf2,
	0xab, 0xc5, 0x12, 0x18, 0x32, 0xd0, 0x75, 0x52, 0xdd, 0xe9, 0x1d, 0xe3, 0xfa, 0xb4, 0xe2, 0x2f,
	0x36, 0xbd, 0x63, 0x06, 0x24, 0xfa, 0x45, 0x52, 0xeb, 0xc1, 0x38, 0xb6, 0x8d, 0xe0, 0x9e, 0xc7,
	0x02, 0x68, 0x66, 0x88, 0x50, 0x6d, 0xdb, 0xa9, 0x4c, 0xce, 0xbb, 0x87, 0xc6, 0xf8, 0xd9, 0x6a,
	0x43, 0x0a, 0x73, 0x2c, 0xf4, 0x05, 0x59, 0xd9, 0x9b, 0x0c, 0x79, 0x1e, 0x0f, 0xf9, 0xbe, 0x5d,
	0x90, 0x6c, 0x3b, 0x08, 0x3d, 0xa1, 0x19, 0x06, 0x34, 0x70, 0x4e, 0x0a, 0x6e, 0x7d, 0xc5, 0xf5,
	0xa5, 0x54, 0xe7, 0xb8, 0x99, 0xf9, 0xb7, 0x22, 0x85, 0x39, 0x96, 0xe8, 0xaf, 0x2e, 0x0b, 0xd0,
	0xf4, 0x87, 0xd0, 0x9c, 0xc7, 0xc2, 0xae, 0x32, 0x55, 0x66, 0x01, 0xc8, 0x4d, 0xc6, 0x0b, 0xae,
	0x2e, 0x6c, 0x0f, 0xa8, 0xd8, 0x75, 0xc9, 0x43, 0x99, 0xdc, 0xbc, 0x8c, 0x73, 0x4c, 0x0a, 0x73,
	0x86, 0x4c, 0xff, 0x90, 0xab, 0x8c, 0xa7, 0x98, 0x14, 0x08, 0xc1, 0x7e, 0x60, 0x4f, 0x47, 0x3b,
	0x3d, 0xe3, 0x99, 0x2a, 0x9b, 0x22, 0xa0, 0xfe, 0x41, 0x3a, 0x17, 0x19, 0x7c, 0xbb, 0xd4, 0xcd,
	0x50, 0xf7, 0x30, 0xf4, 0xab, 0xe4, 0xfe, 0xae, 0x28, 0x60, 0xd1, 0x38, 0x3c, 0x3c, 0xf8, 0x50,
	0xa4, 0x29, 0x57, 0xc6, 0xd0, 0x06, 0xbb, 0x81, 0x8f, 0xfe, 0x1c, 0x90, 0x86, 0x0b, 0x1c, 0x3c,
	0xa7, 0x3f, 0x8a, 0x95, 0x49, 0x1c, 0x50, 0x8a, 0x10, 0x98, 0xfc, 0xa3, 0x89, 0xd4, 0x31, 0x9a,
	0x65, 0x01, 0xe0, 0xee, 0x71, 0x25, 0xe4, 0x00, 0xf7, 0x0a, 0x84, 0x60, 0xc7, 0x64, 0x3c, 0x4e,
	0xb5, 0x18, 0x73, 0x36, 0xc9, 0xe0, 0x07, 0xad, 0x9b, 0x47, 0xc3, 0xf2, 0xe6, 0x50, 0xa8, 0x69,
	0xc1, 0x68, 0x9a, 0xc3, 0x82, 0xeb, 0x76, 0xf2, 0x49, 0x81, 0x2b, 0xb6, 0x39, 0x03, 0xee, 0x80,
	0x8f, 0xed, 0x6e, 0xdd, 0x64, 0xe6, 0x1c, 0x5d, 0xe2, 0x1e, 0x77, 0x62, 0xb6, 0x4b, 0xac, 0xda,
	0xb2, 0x1a, 0x83, 0x5b, 0xab, 0xb1, 0xe2, 0x57, 0xe3, 0x2a, 0xa9, 0x5b, 0x59, 0xec, 0x20, 0x08,
	0x81, 0xc7, 0xf7, 0x79, 0x7c, 0x86, 0xb4, 0x9a, 0xa1, 0x79, 0x98, 0xe8, 0x98, 0xbc, 0x65, 0x2e,
	0x3e, 0x1a, 0x29, 0xa9, 0x75, 0xca, 0xff, 0x8f, 0xab, 0x29, 0xa9, 0xb1, 0x58, 0x73, 0xb7, 0xa3,
	0xc1, 0x39, 0xfa, 0x57, 0x95, 0x2c, 0xf9, 0xa5, 0xe0, 0xbd, 0x2f, 0xf8, 0x2f, 0xef, 0xab, 0xcc,
	0xbf, 0x8f, 0x76, 0xc8, 0x92, 0xef, 0x93, 0x5b, 0x26, 0xba, 0x4f, 0xc6, 0xb2, 0x99, 0x11, 0xa1,
	0xc7, 0xe4, 0x6d, 0x67, 0x1d, 0x4c, 0xa3, 0xed, 0xbc, 0x40, 0x5d, 0x35, 0xa3, 0xeb, 0xf3, 0x9e,
	0xae, 0x59, 0x2f, 0xa0, 0xb6, 0xdb, 0xa5, 0xe9, 0x09, 0x59, 0x75, 0x84, 0x13, 0x25, 0x34, 0x9f,
	0xea, 0x5d, 0xf8, 0x74, 0x7a, 0xef, 0x10, 0xf7, 0x15, 0xc3, 0x8d, 0xdd, 0xc3, 0x5e, 0x1f, 0x15,
	0xd7, 0xdf, 0x50, 0xf1, 0xac, 0x38, 0xfd, 0x09, 0x79, 0x67, 0xe6, 0x4a, 0x4f, 0xf3, 0xe2, 0xa7,
	0xd3, 0x7c, 0x97, 0x7c, 0xf4, 0x1e, 0x69, 0x96, 0x1d, 0xf2, 0xf6, 0x3e, 0x13, 0xfd, 0xc2, 0x7d,
	0xab, 0xf8, 0x8d, 0x1c, 0x78, 0x3b, 0x69, 0x2a, 0x2f, 0xf1, 0xa3, 0xd8, 0x02, 0x9f, 0x79, 0x36,
	0xad, 0x92, 0x7a, 0x27, 0x31, 0xff, 0x8f, 0xd8, 0xbd, 0x0c, 0xa1, 0x28, 0xc5, 0xac, 0xc4, 0x0e,
	0x09, 0x9b, 0xec, 0x4e, 0x1a, 0x17, 0x45, 0x39, 0xb0, 0x1d, 0x48, 0xb7, 0x09, 0xe9, 0x29, 0x21,
	0x95, 0xfd, 0x0c, 0xb6, 0x0b, 0xe8, 0xa3, 0xb9, 0x5d, 0x44, 0x9d, 0xc5, 0x09, 0x47, 0xae, 0x2b,
	0xb7, 0xc4, 0x4d, 0xa5, 0xa2, 0x17, 0x84, 0xde, 0xec, 0xec, 0x30, 0x37, 0x7b, 0xf1, 0x90, 0x17,
	0x30, 0xed, 0xed, 0x3c, 0x2e, 0xe1, 0xa9, 0xe7, 0xec, 0x37, 0x10, 0x7a, 0x6e, 0x8f, 0xac, 0xde,
	0x7e, 0x27, 0xf8, 0x09, 0x96, 0x03, 0x37, 0xd7, 0xe1, 0x6c, 0xf4, 0x23, 0x1d, 0xeb, 0xa9, 0x84,
	0xa3, 0x5f, 0x06, 0xe8, 0x00, 0xb7, 0x06, 0x3e, 0x26, 0xcb, 0xbb, 0xfc, 0x2c, 0x9e, 0xa4, 0xba,
	0x93, 0x78, 0x1f, 0x51, 0xb3, 0x48, 0xe0, 0xea, 0xa8, 0x64, 0x24, 0x34, 0x4f, 0xf4, 0x44, 0x71,
	0xf7, 0x7d, 0x30, 0x8b, 0xa4, 0xdf, 0x24, 0x0d, 0xd8, 0xc5, 0xe2, 0x34, 0x2d, 0xb0, 0x4c, 0x67,
	0x36, 0x50, 0x4b, 0x72, 0x9f, 0x23, 0x8e, 0x33, 0x12, 0xe4, 0x9e, 0xff, 0xa2, 0x8e, 0x1a, 0x82,
	0x17, 0xba, 0xd9, 0x80, 0xbf, 0xc6, 0x5e, 0x6e, 0x01, 0xc0, 0x7e, 0x54, 0x6e, 0x72, 0x35, 0x66,
	0x01, 0xb0, 0xd6, 0x1c, 0x8e, 0x2e, 0x25, 0x36, 0xa0, 0x12, 0xa6, 0x2b, 0xa4, 0x72, 0x98, 0xe3,
	0x37, 0x73, 0xe5, 0x30, 0x8f, 0xc6, 0xce, 0x78, 0x7b, 0x37, 0x68, 0x34, 0xab, 0x15, 0x7e, 0x24,
	0x5b, 0xc0, 0xe6, 0x4e, 0x39, 0x0a, 0x4d, 0xee, 0x18, 0x27, 0x6c, 0xe1, 0xb7, 0x91, 0x35, 0xed,
	0xed, 0x9b, 0xcb, 0x75, 0x47, 0xb9, 0xaf, 0x11, 0xc3, 0x18, 0x7d, 0x8b, 0x2c, 0xcf, 0xac, 0xad,
	0xe0, 0xc6, 0xfd, 0x67, 0x3b, 0x71, 0x32, 0xe2, 0xfd, 0x64, 0xc4, 0xc7, 0xb1, 0x73, 0xf6, 0x0c,
	0x72, 0xfb, 0xd1, 0xbf, 0xff, 0xd9, 0x0e, 0x7e, 0x7b, 0xdd, 0x0e, 0x7e, 0x7f, 0xdd, 0x0e, 0xfe,
	0x78, 0xdd, 0x0e, 0x3e, 0xb9, 0x6e, 0x07, 0x7f, 0xb9, 0x6e, 0x07, 0xff, 0xb8, 0x6e, 0x07, 0xa7,
	0x75, 0xf3, 0x27, 0xe1, 0xb3, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x40, 0x5d, 0x0f, 0x86,
	0x14, 0x00, 0x00,
}
