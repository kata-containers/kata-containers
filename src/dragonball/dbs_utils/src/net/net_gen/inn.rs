// Copyright 2023 Alibaba Cloud. All Rights Reserved.
// Copyright 2017 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the THIRD-PARTY file.
// SPDX-License-Identifier: Apache-2.0

/* automatically generated by rust-bindgen */

pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __UAPI_DEF_IN_ADDR: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN_IPPROTO: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN_PKTINFO: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IP_MREQ: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_SOCKADDR_IN: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN_CLASS: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN6_ADDR: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN6_ADDR_ALT: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_SOCKADDR_IN6: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IPV6_MREQ: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IPPROTO_V6: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IPV6_OPTIONS: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IN6_PKTINFO: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_IP6_MTUINFO: ::std::os::raw::c_uint = 1;
pub const __UAPI_DEF_XATTR: ::std::os::raw::c_uint = 1;
pub const _K_SS_MAXSIZE: ::std::os::raw::c_uint = 128;
pub const IP_TOS: ::std::os::raw::c_uint = 1;
pub const IP_TTL: ::std::os::raw::c_uint = 2;
pub const IP_HDRINCL: ::std::os::raw::c_uint = 3;
pub const IP_OPTIONS: ::std::os::raw::c_uint = 4;
pub const IP_ROUTER_ALERT: ::std::os::raw::c_uint = 5;
pub const IP_RECVOPTS: ::std::os::raw::c_uint = 6;
pub const IP_RETOPTS: ::std::os::raw::c_uint = 7;
pub const IP_PKTINFO: ::std::os::raw::c_uint = 8;
pub const IP_PKTOPTIONS: ::std::os::raw::c_uint = 9;
pub const IP_MTU_DISCOVER: ::std::os::raw::c_uint = 10;
pub const IP_RECVERR: ::std::os::raw::c_uint = 11;
pub const IP_RECVTTL: ::std::os::raw::c_uint = 12;
pub const IP_RECVTOS: ::std::os::raw::c_uint = 13;
pub const IP_MTU: ::std::os::raw::c_uint = 14;
pub const IP_FREEBIND: ::std::os::raw::c_uint = 15;
pub const IP_IPSEC_POLICY: ::std::os::raw::c_uint = 16;
pub const IP_XFRM_POLICY: ::std::os::raw::c_uint = 17;
pub const IP_PASSSEC: ::std::os::raw::c_uint = 18;
pub const IP_TRANSPARENT: ::std::os::raw::c_uint = 19;
pub const IP_RECVRETOPTS: ::std::os::raw::c_uint = 7;
pub const IP_ORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_RECVORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_MINTTL: ::std::os::raw::c_uint = 21;
pub const IP_NODEFRAG: ::std::os::raw::c_uint = 22;
pub const IP_CHECKSUM: ::std::os::raw::c_uint = 23;
pub const IP_BIND_ADDRESS_NO_PORT: ::std::os::raw::c_uint = 24;
pub const IP_RECVFRAGSIZE: ::std::os::raw::c_uint = 25;
pub const IP_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IP_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IP_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IP_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IP_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IP_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const IP_MULTICAST_IF: ::std::os::raw::c_uint = 32;
pub const IP_MULTICAST_TTL: ::std::os::raw::c_uint = 33;
pub const IP_MULTICAST_LOOP: ::std::os::raw::c_uint = 34;
pub const IP_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 35;
pub const IP_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 36;
pub const IP_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 37;
pub const IP_BLOCK_SOURCE: ::std::os::raw::c_uint = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 40;
pub const IP_MSFILTER: ::std::os::raw::c_uint = 41;
pub const MCAST_JOIN_GROUP: ::std::os::raw::c_uint = 42;
pub const MCAST_BLOCK_SOURCE: ::std::os::raw::c_uint = 43;
pub const MCAST_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 44;
pub const MCAST_LEAVE_GROUP: ::std::os::raw::c_uint = 45;
pub const MCAST_JOIN_SOURCE_GROUP: ::std::os::raw::c_uint = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: ::std::os::raw::c_uint = 47;
pub const MCAST_MSFILTER: ::std::os::raw::c_uint = 48;
pub const IP_MULTICAST_ALL: ::std::os::raw::c_uint = 49;
pub const IP_UNICAST_IF: ::std::os::raw::c_uint = 50;
pub const MCAST_EXCLUDE: ::std::os::raw::c_uint = 0;
pub const MCAST_INCLUDE: ::std::os::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_TTL: ::std::os::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: ::std::os::raw::c_uint = 1;
pub const __SOCK_SIZE__: ::std::os::raw::c_uint = 16;
pub const IN_CLASSA_NET: ::std::os::raw::c_uint = 4278190080;
pub const IN_CLASSA_NSHIFT: ::std::os::raw::c_uint = 24;
pub const IN_CLASSA_HOST: ::std::os::raw::c_uint = 16777215;
pub const IN_CLASSA_MAX: ::std::os::raw::c_uint = 128;
pub const IN_CLASSB_NET: ::std::os::raw::c_uint = 4294901760;
pub const IN_CLASSB_NSHIFT: ::std::os::raw::c_uint = 16;
pub const IN_CLASSB_HOST: ::std::os::raw::c_uint = 65535;
pub const IN_CLASSB_MAX: ::std::os::raw::c_uint = 65536;
pub const IN_CLASSC_NET: ::std::os::raw::c_uint = 4294967040;
pub const IN_CLASSC_NSHIFT: ::std::os::raw::c_uint = 8;
pub const IN_CLASSC_HOST: ::std::os::raw::c_uint = 255;
pub const IN_MULTICAST_NET: ::std::os::raw::c_uint = 4026531840;
pub const IN_LOOPBACKNET: ::std::os::raw::c_uint = 127;
pub const INADDR_LOOPBACK: ::std::os::raw::c_uint = 2130706433;
pub const INADDR_UNSPEC_GROUP: ::std::os::raw::c_uint = 3758096384;
pub const INADDR_ALLHOSTS_GROUP: ::std::os::raw::c_uint = 3758096385;
pub const INADDR_ALLRTRS_GROUP: ::std::os::raw::c_uint = 3758096386;
pub const INADDR_MAX_LOCAL_GROUP: ::std::os::raw::c_uint = 3758096639;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __kernel_fd_set)).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __kernel_fsid_t)).val as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
pub struct __kernel_sockaddr_storage {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout___kernel_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __kernel_sockaddr_storage)).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__kernel_sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __kernel_sockaddr_storage)).__data as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(__kernel_sockaddr_storage),
            "::",
            stringify!(__data)
        )
    );
}
impl Default for __kernel_sockaddr_storage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IPPROTO_IP: _bindgen_ty_1 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_1 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_1 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_1 = 4;
pub const IPPROTO_TCP: _bindgen_ty_1 = 6;
pub const IPPROTO_EGP: _bindgen_ty_1 = 8;
pub const IPPROTO_PUP: _bindgen_ty_1 = 12;
pub const IPPROTO_UDP: _bindgen_ty_1 = 17;
pub const IPPROTO_IDP: _bindgen_ty_1 = 22;
pub const IPPROTO_TP: _bindgen_ty_1 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_1 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_1 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_1 = 46;
pub const IPPROTO_GRE: _bindgen_ty_1 = 47;
pub const IPPROTO_ESP: _bindgen_ty_1 = 50;
pub const IPPROTO_AH: _bindgen_ty_1 = 51;
pub const IPPROTO_MTP: _bindgen_ty_1 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_1 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_1 = 98;
pub const IPPROTO_PIM: _bindgen_ty_1 = 103;
pub const IPPROTO_COMP: _bindgen_ty_1 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_1 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_1 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_1 = 137;
pub const IPPROTO_RAW: _bindgen_ty_1 = 255;
pub const IPPROTO_MAX: _bindgen_ty_1 = 256;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct in_addr {
    pub s_addr: __be32,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(0 as *const in_addr)).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
impl Clone for in_addr {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreq)).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreq)).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreqn)).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreqn)).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreqn)).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: __be32,
    pub imr_interface: __be32,
    pub imr_sourceaddr: __be32,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreq_source)).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreq_source)).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_mreq_source)).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: __be32,
    pub imsf_interface: __be32,
    pub imsf_fmode: __u32,
    pub imsf_numsrc: __u32,
    pub imsf_slist: [__be32; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_msfilter)).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_msfilter)).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_msfilter)).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_msfilter)).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ip_msfilter)).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct group_req {
    pub gr_interface: __u32,
    pub gr_group: __kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_req)).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_req)).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
impl Default for group_req {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct group_source_req {
    pub gsr_interface: __u32,
    pub gsr_group: __kernel_sockaddr_storage,
    pub gsr_source: __kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_source_req)).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_source_req)).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_source_req)).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
impl Default for group_source_req {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct group_filter {
    pub gf_interface: __u32,
    pub gf_group: __kernel_sockaddr_storage,
    pub gf_fmode: __u32,
    pub gf_numsrc: __u32,
    pub gf_slist: [__kernel_sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_filter)).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_filter)).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_filter)).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_filter)).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const group_filter)).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
impl Default for group_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const in_pktinfo)).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const in_pktinfo)).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const in_pktinfo)).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr_in {
    pub sin_family: __kernel_sa_family_t,
    pub sin_port: __be16,
    pub sin_addr: in_addr,
    pub __pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr_in)).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr_in)).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr_in)).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr_in)).__pad as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(__pad)
        )
    );
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self {
        *self
    }
}
