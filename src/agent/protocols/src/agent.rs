// This file is generated by rust-protobuf 2.6.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CreateContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub string_user: ::protobuf::SingularPtrField<StringUser>,
    pub devices: ::protobuf::RepeatedField<Device>,
    pub storages: ::protobuf::RepeatedField<Storage>,
    pub OCI: ::protobuf::SingularPtrField<super::oci::Spec>,
    pub sandbox_pidns: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContainerRequest {
    fn default() -> &'a CreateContainerRequest {
        <CreateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerRequest {
    pub fn new() -> CreateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;


    pub fn get_string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| StringUser::default_instance())
    }
    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        if self.string_user.is_none() {
            self.string_user.set_default();
        }
        self.string_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // repeated .grpc.Device devices = 4;


    pub fn get_devices(&self) -> &[Device] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<Device> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Storage storages = 5;


    pub fn get_storages(&self) -> &[Storage] {
        &self.storages
    }
    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::protobuf::RepeatedField<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::protobuf::RepeatedField<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::protobuf::RepeatedField<Storage> {
        ::std::mem::replace(&mut self.storages, ::protobuf::RepeatedField::new())
    }

    // .grpc.Spec OCI = 6;


    pub fn get_OCI(&self) -> &super::oci::Spec {
        self.OCI.as_ref().unwrap_or_else(|| super::oci::Spec::default_instance())
    }
    pub fn clear_OCI(&mut self) {
        self.OCI.clear();
    }

    pub fn has_OCI(&self) -> bool {
        self.OCI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OCI(&mut self, v: super::oci::Spec) {
        self.OCI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_OCI(&mut self) -> &mut super::oci::Spec {
        if self.OCI.is_none() {
            self.OCI.set_default();
        }
        self.OCI.as_mut().unwrap()
    }

    // Take field
    pub fn take_OCI(&mut self) -> super::oci::Spec {
        self.OCI.take().unwrap_or_else(|| super::oci::Spec::new())
    }

    // bool sandbox_pidns = 7;


    pub fn get_sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }
    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }
}

impl ::protobuf::Message for CreateContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.string_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.OCI {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.string_user)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storages)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.OCI)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sandbox_pidns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(ref v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.OCI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.sandbox_pidns != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(ref v) = self.string_user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.devices {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storages {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.OCI.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.sandbox_pidns != false {
            os.write_bool(7, self.sandbox_pidns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContainerRequest {
        CreateContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &CreateContainerRequest| { &m.container_id },
                    |m: &mut CreateContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &CreateContainerRequest| { &m.exec_id },
                    |m: &mut CreateContainerRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringUser>>(
                    "string_user",
                    |m: &CreateContainerRequest| { &m.string_user },
                    |m: &mut CreateContainerRequest| { &mut m.string_user },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "devices",
                    |m: &CreateContainerRequest| { &m.devices },
                    |m: &mut CreateContainerRequest| { &mut m.devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Storage>>(
                    "storages",
                    |m: &CreateContainerRequest| { &m.storages },
                    |m: &mut CreateContainerRequest| { &mut m.storages },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::Spec>>(
                    "OCI",
                    |m: &CreateContainerRequest| { &m.OCI },
                    |m: &mut CreateContainerRequest| { &mut m.OCI },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sandbox_pidns",
                    |m: &CreateContainerRequest| { &m.sandbox_pidns },
                    |m: &mut CreateContainerRequest| { &mut m.sandbox_pidns },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateContainerRequest>(
                    "CreateContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateContainerRequest,
        };
        unsafe {
            instance.get(CreateContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.devices.clear();
        self.storages.clear();
        self.OCI.clear();
        self.sandbox_pidns = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartContainerRequest {
    fn default() -> &'a StartContainerRequest {
        <StartContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartContainerRequest {
    pub fn new() -> StartContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StartContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartContainerRequest {
        StartContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &StartContainerRequest| { &m.container_id },
                    |m: &mut StartContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartContainerRequest>(
                    "StartContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartContainerRequest,
        };
        unsafe {
            instance.get(StartContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub timeout: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerRequest {
    fn default() -> &'a RemoveContainerRequest {
        <RemoveContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerRequest {
    pub fn new() -> RemoveContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // uint32 timeout = 2;


    pub fn get_timeout(&self) -> u32 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for RemoveContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.timeout != 0 {
            os.write_uint32(2, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerRequest {
        RemoveContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &RemoveContainerRequest| { &m.container_id },
                    |m: &mut RemoveContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeout",
                    |m: &RemoveContainerRequest| { &m.timeout },
                    |m: &mut RemoveContainerRequest| { &mut m.timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveContainerRequest>(
                    "RemoveContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveContainerRequest,
        };
        unsafe {
            instance.get(RemoveContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub string_user: ::protobuf::SingularPtrField<StringUser>,
    pub process: ::protobuf::SingularPtrField<super::oci::Process>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecProcessRequest {
    fn default() -> &'a ExecProcessRequest {
        <ExecProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecProcessRequest {
    pub fn new() -> ExecProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // .grpc.StringUser string_user = 3;


    pub fn get_string_user(&self) -> &StringUser {
        self.string_user.as_ref().unwrap_or_else(|| StringUser::default_instance())
    }
    pub fn clear_string_user(&mut self) {
        self.string_user.clear();
    }

    pub fn has_string_user(&self) -> bool {
        self.string_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_user(&mut self, v: StringUser) {
        self.string_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_user(&mut self) -> &mut StringUser {
        if self.string_user.is_none() {
            self.string_user.set_default();
        }
        self.string_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_user(&mut self) -> StringUser {
        self.string_user.take().unwrap_or_else(|| StringUser::new())
    }

    // .grpc.Process process = 4;


    pub fn get_process(&self) -> &super::oci::Process {
        self.process.as_ref().unwrap_or_else(|| super::oci::Process::default_instance())
    }
    pub fn clear_process(&mut self) {
        self.process.clear();
    }

    pub fn has_process(&self) -> bool {
        self.process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process(&mut self, v: super::oci::Process) {
        self.process = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process(&mut self) -> &mut super::oci::Process {
        if self.process.is_none() {
            self.process.set_default();
        }
        self.process.as_mut().unwrap()
    }

    // Take field
    pub fn take_process(&mut self) -> super::oci::Process {
        self.process.take().unwrap_or_else(|| super::oci::Process::new())
    }
}

impl ::protobuf::Message for ExecProcessRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.string_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.process {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.string_user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.process)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if let Some(ref v) = self.string_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if let Some(ref v) = self.string_user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.process.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecProcessRequest {
        ExecProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ExecProcessRequest| { &m.container_id },
                    |m: &mut ExecProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &ExecProcessRequest| { &m.exec_id },
                    |m: &mut ExecProcessRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringUser>>(
                    "string_user",
                    |m: &ExecProcessRequest| { &m.string_user },
                    |m: &mut ExecProcessRequest| { &mut m.string_user },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::Process>>(
                    "process",
                    |m: &ExecProcessRequest| { &m.process },
                    |m: &mut ExecProcessRequest| { &mut m.process },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecProcessRequest>(
                    "ExecProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExecProcessRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecProcessRequest,
        };
        unsafe {
            instance.get(ExecProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExecProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.string_user.clear();
        self.process.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignalProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub signal: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignalProcessRequest {
    fn default() -> &'a SignalProcessRequest {
        <SignalProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignalProcessRequest {
    pub fn new() -> SignalProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 signal = 3;


    pub fn get_signal(&self) -> u32 {
        self.signal
    }
    pub fn clear_signal(&mut self) {
        self.signal = 0;
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: u32) {
        self.signal = v;
    }
}

impl ::protobuf::Message for SignalProcessRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.signal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.signal != 0 {
            my_size += ::protobuf::rt::value_size(3, self.signal, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.signal != 0 {
            os.write_uint32(3, self.signal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignalProcessRequest {
        SignalProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &SignalProcessRequest| { &m.container_id },
                    |m: &mut SignalProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &SignalProcessRequest| { &m.exec_id },
                    |m: &mut SignalProcessRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "signal",
                    |m: &SignalProcessRequest| { &m.signal },
                    |m: &mut SignalProcessRequest| { &mut m.signal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignalProcessRequest>(
                    "SignalProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignalProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignalProcessRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignalProcessRequest,
        };
        unsafe {
            instance.get(SignalProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignalProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.signal = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignalProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignalProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitProcessRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitProcessRequest {
    fn default() -> &'a WaitProcessRequest {
        <WaitProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessRequest {
    pub fn new() -> WaitProcessRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WaitProcessRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitProcessRequest {
        WaitProcessRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &WaitProcessRequest| { &m.container_id },
                    |m: &mut WaitProcessRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &WaitProcessRequest| { &m.exec_id },
                    |m: &mut WaitProcessRequest| { &mut m.exec_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WaitProcessRequest>(
                    "WaitProcessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WaitProcessRequest {
        static mut instance: ::protobuf::lazy::Lazy<WaitProcessRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WaitProcessRequest,
        };
        unsafe {
            instance.get(WaitProcessRequest::new)
        }
    }
}

impl ::protobuf::Clear for WaitProcessRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitProcessResponse {
    // message fields
    pub status: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitProcessResponse {
    fn default() -> &'a WaitProcessResponse {
        <WaitProcessResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitProcessResponse {
    pub fn new() -> WaitProcessResponse {
        ::std::default::Default::default()
    }

    // int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }
}

impl ::protobuf::Message for WaitProcessResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitProcessResponse {
        WaitProcessResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &WaitProcessResponse| { &m.status },
                    |m: &mut WaitProcessResponse| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WaitProcessResponse>(
                    "WaitProcessResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WaitProcessResponse {
        static mut instance: ::protobuf::lazy::Lazy<WaitProcessResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WaitProcessResponse,
        };
        unsafe {
            instance.get(WaitProcessResponse::new)
        }
    }
}

impl ::protobuf::Clear for WaitProcessResponse {
    fn clear(&mut self) {
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitProcessResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitProcessResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProcessesRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub format: ::std::string::String,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProcessesRequest {
    fn default() -> &'a ListProcessesRequest {
        <ListProcessesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProcessesRequest {
    pub fn new() -> ListProcessesRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string format = 2;


    pub fn get_format(&self) -> &str {
        &self.format
    }
    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        &mut self.format
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.format, ::std::string::String::new())
    }

    // repeated string args = 3;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListProcessesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.format)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.format);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.format.is_empty() {
            os.write_string(2, &self.format)?;
        }
        for v in &self.args {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProcessesRequest {
        ListProcessesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ListProcessesRequest| { &m.container_id },
                    |m: &mut ListProcessesRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "format",
                    |m: &ListProcessesRequest| { &m.format },
                    |m: &mut ListProcessesRequest| { &mut m.format },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    |m: &ListProcessesRequest| { &m.args },
                    |m: &mut ListProcessesRequest| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListProcessesRequest>(
                    "ListProcessesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListProcessesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListProcessesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListProcessesRequest,
        };
        unsafe {
            instance.get(ListProcessesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListProcessesRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.format.clear();
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProcessesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProcessesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProcessesResponse {
    // message fields
    pub process_list: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProcessesResponse {
    fn default() -> &'a ListProcessesResponse {
        <ListProcessesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProcessesResponse {
    pub fn new() -> ListProcessesResponse {
        ::std::default::Default::default()
    }

    // bytes process_list = 1;


    pub fn get_process_list(&self) -> &[u8] {
        &self.process_list
    }
    pub fn clear_process_list(&mut self) {
        self.process_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_process_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.process_list = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.process_list
    }

    // Take field
    pub fn take_process_list(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.process_list, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListProcessesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.process_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.process_list.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.process_list);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.process_list.is_empty() {
            os.write_bytes(1, &self.process_list)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProcessesResponse {
        ListProcessesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "process_list",
                    |m: &ListProcessesResponse| { &m.process_list },
                    |m: &mut ListProcessesResponse| { &mut m.process_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListProcessesResponse>(
                    "ListProcessesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListProcessesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListProcessesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListProcessesResponse,
        };
        unsafe {
            instance.get(ListProcessesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListProcessesResponse {
    fn clear(&mut self) {
        self.process_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProcessesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProcessesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub resources: ::protobuf::SingularPtrField<super::oci::LinuxResources>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContainerRequest {
    fn default() -> &'a UpdateContainerRequest {
        <UpdateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContainerRequest {
    pub fn new() -> UpdateContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // .grpc.LinuxResources resources = 2;


    pub fn get_resources(&self) -> &super::oci::LinuxResources {
        self.resources.as_ref().unwrap_or_else(|| super::oci::LinuxResources::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: super::oci::LinuxResources) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut super::oci::LinuxResources {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> super::oci::LinuxResources {
        self.resources.take().unwrap_or_else(|| super::oci::LinuxResources::new())
    }
}

impl ::protobuf::Message for UpdateContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContainerRequest {
        UpdateContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &UpdateContainerRequest| { &m.container_id },
                    |m: &mut UpdateContainerRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oci::LinuxResources>>(
                    "resources",
                    |m: &UpdateContainerRequest| { &m.resources },
                    |m: &mut UpdateContainerRequest| { &mut m.resources },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateContainerRequest>(
                    "UpdateContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateContainerRequest,
        };
        unsafe {
            instance.get(UpdateContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.resources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatsContainerRequest {
    fn default() -> &'a StatsContainerRequest {
        <StatsContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerRequest {
    pub fn new() -> StatsContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StatsContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsContainerRequest {
        StatsContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &StatsContainerRequest| { &m.container_id },
                    |m: &mut StatsContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsContainerRequest>(
                    "StatsContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatsContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatsContainerRequest,
        };
        unsafe {
            instance.get(StatsContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatsContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PauseContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PauseContainerRequest {
    fn default() -> &'a PauseContainerRequest {
        <PauseContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseContainerRequest {
    pub fn new() -> PauseContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PauseContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PauseContainerRequest {
        PauseContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &PauseContainerRequest| { &m.container_id },
                    |m: &mut PauseContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PauseContainerRequest>(
                    "PauseContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PauseContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<PauseContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PauseContainerRequest,
        };
        unsafe {
            instance.get(PauseContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for PauseContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PauseContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResumeContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResumeContainerRequest {
    fn default() -> &'a ResumeContainerRequest {
        <ResumeContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeContainerRequest {
    pub fn new() -> ResumeContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResumeContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResumeContainerRequest {
        ResumeContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ResumeContainerRequest| { &m.container_id },
                    |m: &mut ResumeContainerRequest| { &mut m.container_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResumeContainerRequest>(
                    "ResumeContainerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResumeContainerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ResumeContainerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResumeContainerRequest,
        };
        unsafe {
            instance.get(ResumeContainerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ResumeContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResumeContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CpuUsage {
    // message fields
    pub total_usage: u64,
    pub percpu_usage: ::std::vec::Vec<u64>,
    pub usage_in_kernelmode: u64,
    pub usage_in_usermode: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuUsage {
    fn default() -> &'a CpuUsage {
        <CpuUsage as ::protobuf::Message>::default_instance()
    }
}

impl CpuUsage {
    pub fn new() -> CpuUsage {
        ::std::default::Default::default()
    }

    // uint64 total_usage = 1;


    pub fn get_total_usage(&self) -> u64 {
        self.total_usage
    }
    pub fn clear_total_usage(&mut self) {
        self.total_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_usage(&mut self, v: u64) {
        self.total_usage = v;
    }

    // repeated uint64 percpu_usage = 2;


    pub fn get_percpu_usage(&self) -> &[u64] {
        &self.percpu_usage
    }
    pub fn clear_percpu_usage(&mut self) {
        self.percpu_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_percpu_usage(&mut self, v: ::std::vec::Vec<u64>) {
        self.percpu_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_percpu_usage(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.percpu_usage
    }

    // Take field
    pub fn take_percpu_usage(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.percpu_usage, ::std::vec::Vec::new())
    }

    // uint64 usage_in_kernelmode = 3;


    pub fn get_usage_in_kernelmode(&self) -> u64 {
        self.usage_in_kernelmode
    }
    pub fn clear_usage_in_kernelmode(&mut self) {
        self.usage_in_kernelmode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_kernelmode(&mut self, v: u64) {
        self.usage_in_kernelmode = v;
    }

    // uint64 usage_in_usermode = 4;


    pub fn get_usage_in_usermode(&self) -> u64 {
        self.usage_in_usermode
    }
    pub fn clear_usage_in_usermode(&mut self) {
        self.usage_in_usermode = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage_in_usermode(&mut self, v: u64) {
        self.usage_in_usermode = v;
    }
}

impl ::protobuf::Message for CpuUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_usage = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.percpu_usage)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage_in_kernelmode = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage_in_usermode = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.percpu_usage {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.usage_in_kernelmode != 0 {
            my_size += ::protobuf::rt::value_size(3, self.usage_in_kernelmode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.usage_in_usermode != 0 {
            my_size += ::protobuf::rt::value_size(4, self.usage_in_usermode, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total_usage != 0 {
            os.write_uint64(1, self.total_usage)?;
        }
        for v in &self.percpu_usage {
            os.write_uint64(2, *v)?;
        };
        if self.usage_in_kernelmode != 0 {
            os.write_uint64(3, self.usage_in_kernelmode)?;
        }
        if self.usage_in_usermode != 0 {
            os.write_uint64(4, self.usage_in_usermode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuUsage {
        CpuUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "total_usage",
                    |m: &CpuUsage| { &m.total_usage },
                    |m: &mut CpuUsage| { &mut m.total_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "percpu_usage",
                    |m: &CpuUsage| { &m.percpu_usage },
                    |m: &mut CpuUsage| { &mut m.percpu_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage_in_kernelmode",
                    |m: &CpuUsage| { &m.usage_in_kernelmode },
                    |m: &mut CpuUsage| { &mut m.usage_in_kernelmode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage_in_usermode",
                    |m: &CpuUsage| { &m.usage_in_usermode },
                    |m: &mut CpuUsage| { &mut m.usage_in_usermode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CpuUsage>(
                    "CpuUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CpuUsage {
        static mut instance: ::protobuf::lazy::Lazy<CpuUsage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CpuUsage,
        };
        unsafe {
            instance.get(CpuUsage::new)
        }
    }
}

impl ::protobuf::Clear for CpuUsage {
    fn clear(&mut self) {
        self.total_usage = 0;
        self.percpu_usage.clear();
        self.usage_in_kernelmode = 0;
        self.usage_in_usermode = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThrottlingData {
    // message fields
    pub periods: u64,
    pub throttled_periods: u64,
    pub throttled_time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThrottlingData {
    fn default() -> &'a ThrottlingData {
        <ThrottlingData as ::protobuf::Message>::default_instance()
    }
}

impl ThrottlingData {
    pub fn new() -> ThrottlingData {
        ::std::default::Default::default()
    }

    // uint64 periods = 1;


    pub fn get_periods(&self) -> u64 {
        self.periods
    }
    pub fn clear_periods(&mut self) {
        self.periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_periods(&mut self, v: u64) {
        self.periods = v;
    }

    // uint64 throttled_periods = 2;


    pub fn get_throttled_periods(&self) -> u64 {
        self.throttled_periods
    }
    pub fn clear_throttled_periods(&mut self) {
        self.throttled_periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_periods(&mut self, v: u64) {
        self.throttled_periods = v;
    }

    // uint64 throttled_time = 3;


    pub fn get_throttled_time(&self) -> u64 {
        self.throttled_time
    }
    pub fn clear_throttled_time(&mut self) {
        self.throttled_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_time(&mut self, v: u64) {
        self.throttled_time = v;
    }
}

impl ::protobuf::Message for ThrottlingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.periods = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_periods = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.periods != 0 {
            my_size += ::protobuf::rt::value_size(1, self.periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_periods != 0 {
            my_size += ::protobuf::rt::value_size(2, self.throttled_periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.throttled_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.periods != 0 {
            os.write_uint64(1, self.periods)?;
        }
        if self.throttled_periods != 0 {
            os.write_uint64(2, self.throttled_periods)?;
        }
        if self.throttled_time != 0 {
            os.write_uint64(3, self.throttled_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThrottlingData {
        ThrottlingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "periods",
                    |m: &ThrottlingData| { &m.periods },
                    |m: &mut ThrottlingData| { &mut m.periods },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "throttled_periods",
                    |m: &ThrottlingData| { &m.throttled_periods },
                    |m: &mut ThrottlingData| { &mut m.throttled_periods },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "throttled_time",
                    |m: &ThrottlingData| { &m.throttled_time },
                    |m: &mut ThrottlingData| { &mut m.throttled_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThrottlingData>(
                    "ThrottlingData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThrottlingData {
        static mut instance: ::protobuf::lazy::Lazy<ThrottlingData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThrottlingData,
        };
        unsafe {
            instance.get(ThrottlingData::new)
        }
    }
}

impl ::protobuf::Clear for ThrottlingData {
    fn clear(&mut self) {
        self.periods = 0;
        self.throttled_periods = 0;
        self.throttled_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThrottlingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThrottlingData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CpuStats {
    // message fields
    pub cpu_usage: ::protobuf::SingularPtrField<CpuUsage>,
    pub throttling_data: ::protobuf::SingularPtrField<ThrottlingData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuStats {
    fn default() -> &'a CpuStats {
        <CpuStats as ::protobuf::Message>::default_instance()
    }
}

impl CpuStats {
    pub fn new() -> CpuStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuUsage cpu_usage = 1;


    pub fn get_cpu_usage(&self) -> &CpuUsage {
        self.cpu_usage.as_ref().unwrap_or_else(|| CpuUsage::default_instance())
    }
    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage.clear();
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: CpuUsage) {
        self.cpu_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_usage(&mut self) -> &mut CpuUsage {
        if self.cpu_usage.is_none() {
            self.cpu_usage.set_default();
        }
        self.cpu_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_usage(&mut self) -> CpuUsage {
        self.cpu_usage.take().unwrap_or_else(|| CpuUsage::new())
    }

    // .grpc.ThrottlingData throttling_data = 2;


    pub fn get_throttling_data(&self) -> &ThrottlingData {
        self.throttling_data.as_ref().unwrap_or_else(|| ThrottlingData::default_instance())
    }
    pub fn clear_throttling_data(&mut self) {
        self.throttling_data.clear();
    }

    pub fn has_throttling_data(&self) -> bool {
        self.throttling_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_data(&mut self, v: ThrottlingData) {
        self.throttling_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_throttling_data(&mut self) -> &mut ThrottlingData {
        if self.throttling_data.is_none() {
            self.throttling_data.set_default();
        }
        self.throttling_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_throttling_data(&mut self) -> ThrottlingData {
        self.throttling_data.take().unwrap_or_else(|| ThrottlingData::new())
    }
}

impl ::protobuf::Message for CpuStats {
    fn is_initialized(&self) -> bool {
        for v in &self.cpu_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.throttling_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_usage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.throttling_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cpu_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.throttling_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cpu_usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.throttling_data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuStats {
        CpuStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuUsage>>(
                    "cpu_usage",
                    |m: &CpuStats| { &m.cpu_usage },
                    |m: &mut CpuStats| { &mut m.cpu_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThrottlingData>>(
                    "throttling_data",
                    |m: &CpuStats| { &m.throttling_data },
                    |m: &mut CpuStats| { &mut m.throttling_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CpuStats>(
                    "CpuStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CpuStats {
        static mut instance: ::protobuf::lazy::Lazy<CpuStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CpuStats,
        };
        unsafe {
            instance.get(CpuStats::new)
        }
    }
}

impl ::protobuf::Clear for CpuStats {
    fn clear(&mut self) {
        self.cpu_usage.clear();
        self.throttling_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PidsStats {
    // message fields
    pub current: u64,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PidsStats {
    fn default() -> &'a PidsStats {
        <PidsStats as ::protobuf::Message>::default_instance()
    }
}

impl PidsStats {
    pub fn new() -> PidsStats {
        ::std::default::Default::default()
    }

    // uint64 current = 1;


    pub fn get_current(&self) -> u64 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PidsStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PidsStats {
        PidsStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "current",
                    |m: &PidsStats| { &m.current },
                    |m: &mut PidsStats| { &mut m.current },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &PidsStats| { &m.limit },
                    |m: &mut PidsStats| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PidsStats>(
                    "PidsStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PidsStats {
        static mut instance: ::protobuf::lazy::Lazy<PidsStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PidsStats,
        };
        unsafe {
            instance.get(PidsStats::new)
        }
    }
}

impl ::protobuf::Clear for PidsStats {
    fn clear(&mut self) {
        self.current = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PidsStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryData {
    // message fields
    pub usage: u64,
    pub max_usage: u64,
    pub failcnt: u64,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryData {
    fn default() -> &'a MemoryData {
        <MemoryData as ::protobuf::Message>::default_instance()
    }
}

impl MemoryData {
    pub fn new() -> MemoryData {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;


    pub fn get_max_usage(&self) -> u64 {
        self.max_usage
    }
    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    // uint64 limit = 4;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for MemoryData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_usage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryData {
        MemoryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage",
                    |m: &MemoryData| { &m.usage },
                    |m: &mut MemoryData| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_usage",
                    |m: &MemoryData| { &m.max_usage },
                    |m: &mut MemoryData| { &mut m.max_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "failcnt",
                    |m: &MemoryData| { &m.failcnt },
                    |m: &mut MemoryData| { &mut m.failcnt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &MemoryData| { &m.limit },
                    |m: &mut MemoryData| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemoryData>(
                    "MemoryData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemoryData {
        static mut instance: ::protobuf::lazy::Lazy<MemoryData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemoryData,
        };
        unsafe {
            instance.get(MemoryData::new)
        }
    }
}

impl ::protobuf::Clear for MemoryData {
    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryStats {
    // message fields
    pub cache: u64,
    pub usage: ::protobuf::SingularPtrField<MemoryData>,
    pub swap_usage: ::protobuf::SingularPtrField<MemoryData>,
    pub kernel_usage: ::protobuf::SingularPtrField<MemoryData>,
    pub use_hierarchy: bool,
    pub stats: ::std::collections::HashMap<::std::string::String, u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryStats {
    fn default() -> &'a MemoryStats {
        <MemoryStats as ::protobuf::Message>::default_instance()
    }
}

impl MemoryStats {
    pub fn new() -> MemoryStats {
        ::std::default::Default::default()
    }

    // uint64 cache = 1;


    pub fn get_cache(&self) -> u64 {
        self.cache
    }
    pub fn clear_cache(&mut self) {
        self.cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: u64) {
        self.cache = v;
    }

    // .grpc.MemoryData usage = 2;


    pub fn get_usage(&self) -> &MemoryData {
        self.usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: MemoryData) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut MemoryData {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> MemoryData {
        self.usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData swap_usage = 3;


    pub fn get_swap_usage(&self) -> &MemoryData {
        self.swap_usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_swap_usage(&mut self) {
        self.swap_usage.clear();
    }

    pub fn has_swap_usage(&self) -> bool {
        self.swap_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_usage(&mut self, v: MemoryData) {
        self.swap_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap_usage(&mut self) -> &mut MemoryData {
        if self.swap_usage.is_none() {
            self.swap_usage.set_default();
        }
        self.swap_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_swap_usage(&mut self) -> MemoryData {
        self.swap_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // .grpc.MemoryData kernel_usage = 4;


    pub fn get_kernel_usage(&self) -> &MemoryData {
        self.kernel_usage.as_ref().unwrap_or_else(|| MemoryData::default_instance())
    }
    pub fn clear_kernel_usage(&mut self) {
        self.kernel_usage.clear();
    }

    pub fn has_kernel_usage(&self) -> bool {
        self.kernel_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_usage(&mut self, v: MemoryData) {
        self.kernel_usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_usage(&mut self) -> &mut MemoryData {
        if self.kernel_usage.is_none() {
            self.kernel_usage.set_default();
        }
        self.kernel_usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel_usage(&mut self) -> MemoryData {
        self.kernel_usage.take().unwrap_or_else(|| MemoryData::new())
    }

    // bool use_hierarchy = 5;


    pub fn get_use_hierarchy(&self) -> bool {
        self.use_hierarchy
    }
    pub fn clear_use_hierarchy(&mut self) {
        self.use_hierarchy = false;
    }

    // Param is passed by value, moved
    pub fn set_use_hierarchy(&mut self, v: bool) {
        self.use_hierarchy = v;
    }

    // repeated .grpc.MemoryStats.StatsEntry stats = 6;


    pub fn get_stats(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
        ::std::mem::replace(&mut self.stats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MemoryStats {
    fn is_initialized(&self) -> bool {
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.swap_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kernel_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cache = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.swap_usage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kernel_usage)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_hierarchy = tmp;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cache != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cache, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.swap_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kernel_usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_hierarchy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(6, &self.stats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cache != 0 {
            os.write_uint64(1, self.cache)?;
        }
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.swap_usage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kernel_usage.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_hierarchy != false {
            os.write_bool(5, self.use_hierarchy)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(6, &self.stats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryStats {
        MemoryStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cache",
                    |m: &MemoryStats| { &m.cache },
                    |m: &mut MemoryStats| { &mut m.cache },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "usage",
                    |m: &MemoryStats| { &m.usage },
                    |m: &mut MemoryStats| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "swap_usage",
                    |m: &MemoryStats| { &m.swap_usage },
                    |m: &mut MemoryStats| { &mut m.swap_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryData>>(
                    "kernel_usage",
                    |m: &MemoryStats| { &m.kernel_usage },
                    |m: &mut MemoryStats| { &mut m.kernel_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_hierarchy",
                    |m: &MemoryStats| { &m.use_hierarchy },
                    |m: &mut MemoryStats| { &mut m.use_hierarchy },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(
                    "stats",
                    |m: &MemoryStats| { &m.stats },
                    |m: &mut MemoryStats| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemoryStats>(
                    "MemoryStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemoryStats {
        static mut instance: ::protobuf::lazy::Lazy<MemoryStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemoryStats,
        };
        unsafe {
            instance.get(MemoryStats::new)
        }
    }
}

impl ::protobuf::Clear for MemoryStats {
    fn clear(&mut self) {
        self.cache = 0;
        self.usage.clear();
        self.swap_usage.clear();
        self.kernel_usage.clear();
        self.use_hierarchy = false;
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkioStatsEntry {
    // message fields
    pub major: u64,
    pub minor: u64,
    pub op: ::std::string::String,
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkioStatsEntry {
    fn default() -> &'a BlkioStatsEntry {
        <BlkioStatsEntry as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStatsEntry {
    pub fn new() -> BlkioStatsEntry {
        ::std::default::Default::default()
    }

    // uint64 major = 1;


    pub fn get_major(&self) -> u64 {
        self.major
    }
    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u64) {
        self.major = v;
    }

    // uint64 minor = 2;


    pub fn get_minor(&self) -> u64 {
        self.minor
    }
    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u64) {
        self.minor = v;
    }

    // string op = 3;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // uint64 value = 4;


    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for BlkioStatsEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minor = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.op);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(4, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.major != 0 {
            os.write_uint64(1, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint64(2, self.minor)?;
        }
        if !self.op.is_empty() {
            os.write_string(3, &self.op)?;
        }
        if self.value != 0 {
            os.write_uint64(4, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkioStatsEntry {
        BlkioStatsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "major",
                    |m: &BlkioStatsEntry| { &m.major },
                    |m: &mut BlkioStatsEntry| { &mut m.major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minor",
                    |m: &BlkioStatsEntry| { &m.minor },
                    |m: &mut BlkioStatsEntry| { &mut m.minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "op",
                    |m: &BlkioStatsEntry| { &m.op },
                    |m: &mut BlkioStatsEntry| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &BlkioStatsEntry| { &m.value },
                    |m: &mut BlkioStatsEntry| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlkioStatsEntry>(
                    "BlkioStatsEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlkioStatsEntry {
        static mut instance: ::protobuf::lazy::Lazy<BlkioStatsEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlkioStatsEntry,
        };
        unsafe {
            instance.get(BlkioStatsEntry::new)
        }
    }
}

impl ::protobuf::Clear for BlkioStatsEntry {
    fn clear(&mut self) {
        self.major = 0;
        self.minor = 0;
        self.op.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkioStatsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStatsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkioStats {
    // message fields
    pub io_service_bytes_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_serviced_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_queued_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_service_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_wait_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_merged_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub io_time_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    pub sectors_recursive: ::protobuf::RepeatedField<BlkioStatsEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkioStats {
    fn default() -> &'a BlkioStats {
        <BlkioStats as ::protobuf::Message>::default_instance()
    }
}

impl BlkioStats {
    pub fn new() -> BlkioStats {
        ::std::default::Default::default()
    }

    // repeated .grpc.BlkioStatsEntry io_service_bytes_recursive = 1;


    pub fn get_io_service_bytes_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_bytes_recursive
    }
    pub fn clear_io_service_bytes_recursive(&mut self) {
        self.io_service_bytes_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_service_bytes_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_service_bytes_recursive
    }

    // Take field
    pub fn take_io_service_bytes_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_bytes_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_serviced_recursive = 2;


    pub fn get_io_serviced_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_serviced_recursive
    }
    pub fn clear_io_serviced_recursive(&mut self) {
        self.io_serviced_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_serviced_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_serviced_recursive
    }

    // Take field
    pub fn take_io_serviced_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_serviced_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_queued_recursive = 3;


    pub fn get_io_queued_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_queued_recursive
    }
    pub fn clear_io_queued_recursive(&mut self) {
        self.io_queued_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_queued_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_queued_recursive
    }

    // Take field
    pub fn take_io_queued_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_queued_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_service_time_recursive = 4;


    pub fn get_io_service_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_service_time_recursive
    }
    pub fn clear_io_service_time_recursive(&mut self) {
        self.io_service_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_service_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_service_time_recursive
    }

    // Take field
    pub fn take_io_service_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_service_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_wait_time_recursive = 5;


    pub fn get_io_wait_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_wait_time_recursive
    }
    pub fn clear_io_wait_time_recursive(&mut self) {
        self.io_wait_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_wait_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_wait_time_recursive
    }

    // Take field
    pub fn take_io_wait_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_wait_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_merged_recursive = 6;


    pub fn get_io_merged_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_merged_recursive
    }
    pub fn clear_io_merged_recursive(&mut self) {
        self.io_merged_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_merged_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_merged_recursive
    }

    // Take field
    pub fn take_io_merged_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_merged_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry io_time_recursive = 7;


    pub fn get_io_time_recursive(&self) -> &[BlkioStatsEntry] {
        &self.io_time_recursive
    }
    pub fn clear_io_time_recursive(&mut self) {
        self.io_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.io_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.io_time_recursive
    }

    // Take field
    pub fn take_io_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.io_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.BlkioStatsEntry sectors_recursive = 8;


    pub fn get_sectors_recursive(&self) -> &[BlkioStatsEntry] {
        &self.sectors_recursive
    }
    pub fn clear_sectors_recursive(&mut self) {
        self.sectors_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_sectors_recursive(&mut self, v: ::protobuf::RepeatedField<BlkioStatsEntry>) {
        self.sectors_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sectors_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkioStatsEntry> {
        &mut self.sectors_recursive
    }

    // Take field
    pub fn take_sectors_recursive(&mut self) -> ::protobuf::RepeatedField<BlkioStatsEntry> {
        ::std::mem::replace(&mut self.sectors_recursive, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlkioStats {
    fn is_initialized(&self) -> bool {
        for v in &self.io_service_bytes_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_serviced_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_queued_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_wait_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_merged_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectors_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_bytes_recursive)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_serviced_recursive)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_queued_recursive)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_time_recursive)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_wait_time_recursive)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_merged_recursive)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_time_recursive)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sectors_recursive)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.io_service_bytes_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_serviced_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_queued_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_wait_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_merged_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sectors_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.io_service_bytes_recursive {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_serviced_recursive {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_queued_recursive {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_time_recursive {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_wait_time_recursive {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_merged_recursive {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_time_recursive {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sectors_recursive {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkioStats {
        BlkioStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_service_bytes_recursive",
                    |m: &BlkioStats| { &m.io_service_bytes_recursive },
                    |m: &mut BlkioStats| { &mut m.io_service_bytes_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_serviced_recursive",
                    |m: &BlkioStats| { &m.io_serviced_recursive },
                    |m: &mut BlkioStats| { &mut m.io_serviced_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_queued_recursive",
                    |m: &BlkioStats| { &m.io_queued_recursive },
                    |m: &mut BlkioStats| { &mut m.io_queued_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_service_time_recursive",
                    |m: &BlkioStats| { &m.io_service_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_service_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_wait_time_recursive",
                    |m: &BlkioStats| { &m.io_wait_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_wait_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_merged_recursive",
                    |m: &BlkioStats| { &m.io_merged_recursive },
                    |m: &mut BlkioStats| { &mut m.io_merged_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "io_time_recursive",
                    |m: &BlkioStats| { &m.io_time_recursive },
                    |m: &mut BlkioStats| { &mut m.io_time_recursive },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStatsEntry>>(
                    "sectors_recursive",
                    |m: &BlkioStats| { &m.sectors_recursive },
                    |m: &mut BlkioStats| { &mut m.sectors_recursive },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlkioStats>(
                    "BlkioStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlkioStats {
        static mut instance: ::protobuf::lazy::Lazy<BlkioStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlkioStats,
        };
        unsafe {
            instance.get(BlkioStats::new)
        }
    }
}

impl ::protobuf::Clear for BlkioStats {
    fn clear(&mut self) {
        self.io_service_bytes_recursive.clear();
        self.io_serviced_recursive.clear();
        self.io_queued_recursive.clear();
        self.io_service_time_recursive.clear();
        self.io_wait_time_recursive.clear();
        self.io_merged_recursive.clear();
        self.io_time_recursive.clear();
        self.sectors_recursive.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkioStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkioStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HugetlbStats {
    // message fields
    pub usage: u64,
    pub max_usage: u64,
    pub failcnt: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HugetlbStats {
    fn default() -> &'a HugetlbStats {
        <HugetlbStats as ::protobuf::Message>::default_instance()
    }
}

impl HugetlbStats {
    pub fn new() -> HugetlbStats {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max_usage = 2;


    pub fn get_max_usage(&self) -> u64 {
        self.max_usage
    }
    pub fn clear_max_usage(&mut self) {
        self.max_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_usage(&mut self, v: u64) {
        self.max_usage = v;
    }

    // uint64 failcnt = 3;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }
}

impl ::protobuf::Message for HugetlbStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_usage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_usage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max_usage != 0 {
            os.write_uint64(2, self.max_usage)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HugetlbStats {
        HugetlbStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "usage",
                    |m: &HugetlbStats| { &m.usage },
                    |m: &mut HugetlbStats| { &mut m.usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_usage",
                    |m: &HugetlbStats| { &m.max_usage },
                    |m: &mut HugetlbStats| { &mut m.max_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "failcnt",
                    |m: &HugetlbStats| { &m.failcnt },
                    |m: &mut HugetlbStats| { &mut m.failcnt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HugetlbStats>(
                    "HugetlbStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HugetlbStats {
        static mut instance: ::protobuf::lazy::Lazy<HugetlbStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HugetlbStats,
        };
        unsafe {
            instance.get(HugetlbStats::new)
        }
    }
}

impl ::protobuf::Clear for HugetlbStats {
    fn clear(&mut self) {
        self.usage = 0;
        self.max_usage = 0;
        self.failcnt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HugetlbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugetlbStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupStats {
    // message fields
    pub cpu_stats: ::protobuf::SingularPtrField<CpuStats>,
    pub memory_stats: ::protobuf::SingularPtrField<MemoryStats>,
    pub pids_stats: ::protobuf::SingularPtrField<PidsStats>,
    pub blkio_stats: ::protobuf::SingularPtrField<BlkioStats>,
    pub hugetlb_stats: ::std::collections::HashMap<::std::string::String, HugetlbStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CgroupStats {
    fn default() -> &'a CgroupStats {
        <CgroupStats as ::protobuf::Message>::default_instance()
    }
}

impl CgroupStats {
    pub fn new() -> CgroupStats {
        ::std::default::Default::default()
    }

    // .grpc.CpuStats cpu_stats = 1;


    pub fn get_cpu_stats(&self) -> &CpuStats {
        self.cpu_stats.as_ref().unwrap_or_else(|| CpuStats::default_instance())
    }
    pub fn clear_cpu_stats(&mut self) {
        self.cpu_stats.clear();
    }

    pub fn has_cpu_stats(&self) -> bool {
        self.cpu_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_stats(&mut self, v: CpuStats) {
        self.cpu_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_stats(&mut self) -> &mut CpuStats {
        if self.cpu_stats.is_none() {
            self.cpu_stats.set_default();
        }
        self.cpu_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_stats(&mut self) -> CpuStats {
        self.cpu_stats.take().unwrap_or_else(|| CpuStats::new())
    }

    // .grpc.MemoryStats memory_stats = 2;


    pub fn get_memory_stats(&self) -> &MemoryStats {
        self.memory_stats.as_ref().unwrap_or_else(|| MemoryStats::default_instance())
    }
    pub fn clear_memory_stats(&mut self) {
        self.memory_stats.clear();
    }

    pub fn has_memory_stats(&self) -> bool {
        self.memory_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_stats(&mut self, v: MemoryStats) {
        self.memory_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_stats(&mut self) -> &mut MemoryStats {
        if self.memory_stats.is_none() {
            self.memory_stats.set_default();
        }
        self.memory_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory_stats(&mut self) -> MemoryStats {
        self.memory_stats.take().unwrap_or_else(|| MemoryStats::new())
    }

    // .grpc.PidsStats pids_stats = 3;


    pub fn get_pids_stats(&self) -> &PidsStats {
        self.pids_stats.as_ref().unwrap_or_else(|| PidsStats::default_instance())
    }
    pub fn clear_pids_stats(&mut self) {
        self.pids_stats.clear();
    }

    pub fn has_pids_stats(&self) -> bool {
        self.pids_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pids_stats(&mut self, v: PidsStats) {
        self.pids_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pids_stats(&mut self) -> &mut PidsStats {
        if self.pids_stats.is_none() {
            self.pids_stats.set_default();
        }
        self.pids_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_pids_stats(&mut self) -> PidsStats {
        self.pids_stats.take().unwrap_or_else(|| PidsStats::new())
    }

    // .grpc.BlkioStats blkio_stats = 4;


    pub fn get_blkio_stats(&self) -> &BlkioStats {
        self.blkio_stats.as_ref().unwrap_or_else(|| BlkioStats::default_instance())
    }
    pub fn clear_blkio_stats(&mut self) {
        self.blkio_stats.clear();
    }

    pub fn has_blkio_stats(&self) -> bool {
        self.blkio_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio_stats(&mut self, v: BlkioStats) {
        self.blkio_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio_stats(&mut self) -> &mut BlkioStats {
        if self.blkio_stats.is_none() {
            self.blkio_stats.set_default();
        }
        self.blkio_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkio_stats(&mut self) -> BlkioStats {
        self.blkio_stats.take().unwrap_or_else(|| BlkioStats::new())
    }

    // repeated .grpc.CgroupStats.HugetlbStatsEntry hugetlb_stats = 5;


    pub fn get_hugetlb_stats(&self) -> &::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &self.hugetlb_stats
    }
    pub fn clear_hugetlb_stats(&mut self) {
        self.hugetlb_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugetlb_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, HugetlbStats>) {
        self.hugetlb_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugetlb_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        &mut self.hugetlb_stats
    }

    // Take field
    pub fn take_hugetlb_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, HugetlbStats> {
        ::std::mem::replace(&mut self.hugetlb_stats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CgroupStats {
    fn is_initialized(&self) -> bool {
        for v in &self.cpu_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pids_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkio_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pids_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkio_stats)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(wire_type, is, &mut self.hugetlb_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cpu_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pids_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkio_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(5, &self.hugetlb_stats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cpu_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pids_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkio_stats.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(5, &self.hugetlb_stats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CgroupStats {
        CgroupStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuStats>>(
                    "cpu_stats",
                    |m: &CgroupStats| { &m.cpu_stats },
                    |m: &mut CgroupStats| { &mut m.cpu_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryStats>>(
                    "memory_stats",
                    |m: &CgroupStats| { &m.memory_stats },
                    |m: &mut CgroupStats| { &mut m.memory_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PidsStats>>(
                    "pids_stats",
                    |m: &CgroupStats| { &m.pids_stats },
                    |m: &mut CgroupStats| { &mut m.pids_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkioStats>>(
                    "blkio_stats",
                    |m: &CgroupStats| { &m.blkio_stats },
                    |m: &mut CgroupStats| { &mut m.blkio_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<HugetlbStats>>(
                    "hugetlb_stats",
                    |m: &CgroupStats| { &m.hugetlb_stats },
                    |m: &mut CgroupStats| { &mut m.hugetlb_stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupStats>(
                    "CgroupStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CgroupStats {
        static mut instance: ::protobuf::lazy::Lazy<CgroupStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupStats,
        };
        unsafe {
            instance.get(CgroupStats::new)
        }
    }
}

impl ::protobuf::Clear for CgroupStats {
    fn clear(&mut self) {
        self.cpu_stats.clear();
        self.memory_stats.clear();
        self.pids_stats.clear();
        self.blkio_stats.clear();
        self.hugetlb_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStats {
    // message fields
    pub name: ::std::string::String,
    pub rx_bytes: u64,
    pub rx_packets: u64,
    pub rx_errors: u64,
    pub rx_dropped: u64,
    pub tx_bytes: u64,
    pub tx_packets: u64,
    pub tx_errors: u64,
    pub tx_dropped: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStats {
    fn default() -> &'a NetworkStats {
        <NetworkStats as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStats {
    pub fn new() -> NetworkStats {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 rx_bytes = 2;


    pub fn get_rx_bytes(&self) -> u64 {
        self.rx_bytes
    }
    pub fn clear_rx_bytes(&mut self) {
        self.rx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes(&mut self, v: u64) {
        self.rx_bytes = v;
    }

    // uint64 rx_packets = 3;


    pub fn get_rx_packets(&self) -> u64 {
        self.rx_packets
    }
    pub fn clear_rx_packets(&mut self) {
        self.rx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets(&mut self, v: u64) {
        self.rx_packets = v;
    }

    // uint64 rx_errors = 4;


    pub fn get_rx_errors(&self) -> u64 {
        self.rx_errors
    }
    pub fn clear_rx_errors(&mut self) {
        self.rx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_errors(&mut self, v: u64) {
        self.rx_errors = v;
    }

    // uint64 rx_dropped = 5;


    pub fn get_rx_dropped(&self) -> u64 {
        self.rx_dropped
    }
    pub fn clear_rx_dropped(&mut self) {
        self.rx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dropped(&mut self, v: u64) {
        self.rx_dropped = v;
    }

    // uint64 tx_bytes = 6;


    pub fn get_tx_bytes(&self) -> u64 {
        self.tx_bytes
    }
    pub fn clear_tx_bytes(&mut self) {
        self.tx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes(&mut self, v: u64) {
        self.tx_bytes = v;
    }

    // uint64 tx_packets = 7;


    pub fn get_tx_packets(&self) -> u64 {
        self.tx_packets
    }
    pub fn clear_tx_packets(&mut self) {
        self.tx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets(&mut self, v: u64) {
        self.tx_packets = v;
    }

    // uint64 tx_errors = 8;


    pub fn get_tx_errors(&self) -> u64 {
        self.tx_errors
    }
    pub fn clear_tx_errors(&mut self) {
        self.tx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_errors(&mut self, v: u64) {
        self.tx_errors = v;
    }

    // uint64 tx_dropped = 9;


    pub fn get_tx_dropped(&self) -> u64 {
        self.tx_dropped
    }
    pub fn clear_tx_dropped(&mut self) {
        self.tx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_dropped(&mut self, v: u64) {
        self.tx_dropped = v;
    }
}

impl ::protobuf::Message for NetworkStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_packets = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_errors = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_dropped = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_bytes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_packets = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_errors = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_dropped = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.rx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_packets != 0 {
            my_size += ::protobuf::rt::value_size(3, self.rx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_errors != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_packets != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_errors != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.rx_bytes != 0 {
            os.write_uint64(2, self.rx_bytes)?;
        }
        if self.rx_packets != 0 {
            os.write_uint64(3, self.rx_packets)?;
        }
        if self.rx_errors != 0 {
            os.write_uint64(4, self.rx_errors)?;
        }
        if self.rx_dropped != 0 {
            os.write_uint64(5, self.rx_dropped)?;
        }
        if self.tx_bytes != 0 {
            os.write_uint64(6, self.tx_bytes)?;
        }
        if self.tx_packets != 0 {
            os.write_uint64(7, self.tx_packets)?;
        }
        if self.tx_errors != 0 {
            os.write_uint64(8, self.tx_errors)?;
        }
        if self.tx_dropped != 0 {
            os.write_uint64(9, self.tx_dropped)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStats {
        NetworkStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NetworkStats| { &m.name },
                    |m: &mut NetworkStats| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_bytes",
                    |m: &NetworkStats| { &m.rx_bytes },
                    |m: &mut NetworkStats| { &mut m.rx_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_packets",
                    |m: &NetworkStats| { &m.rx_packets },
                    |m: &mut NetworkStats| { &mut m.rx_packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_errors",
                    |m: &NetworkStats| { &m.rx_errors },
                    |m: &mut NetworkStats| { &mut m.rx_errors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rx_dropped",
                    |m: &NetworkStats| { &m.rx_dropped },
                    |m: &mut NetworkStats| { &mut m.rx_dropped },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_bytes",
                    |m: &NetworkStats| { &m.tx_bytes },
                    |m: &mut NetworkStats| { &mut m.tx_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_packets",
                    |m: &NetworkStats| { &m.tx_packets },
                    |m: &mut NetworkStats| { &mut m.tx_packets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_errors",
                    |m: &NetworkStats| { &m.tx_errors },
                    |m: &mut NetworkStats| { &mut m.tx_errors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tx_dropped",
                    |m: &NetworkStats| { &m.tx_dropped },
                    |m: &mut NetworkStats| { &mut m.tx_dropped },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkStats>(
                    "NetworkStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkStats {
        static mut instance: ::protobuf::lazy::Lazy<NetworkStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkStats,
        };
        unsafe {
            instance.get(NetworkStats::new)
        }
    }
}

impl ::protobuf::Clear for NetworkStats {
    fn clear(&mut self) {
        self.name.clear();
        self.rx_bytes = 0;
        self.rx_packets = 0;
        self.rx_errors = 0;
        self.rx_dropped = 0;
        self.tx_bytes = 0;
        self.tx_packets = 0;
        self.tx_errors = 0;
        self.tx_dropped = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsContainerResponse {
    // message fields
    pub cgroup_stats: ::protobuf::SingularPtrField<CgroupStats>,
    pub network_stats: ::protobuf::RepeatedField<NetworkStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatsContainerResponse {
    fn default() -> &'a StatsContainerResponse {
        <StatsContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsContainerResponse {
    pub fn new() -> StatsContainerResponse {
        ::std::default::Default::default()
    }

    // .grpc.CgroupStats cgroup_stats = 1;


    pub fn get_cgroup_stats(&self) -> &CgroupStats {
        self.cgroup_stats.as_ref().unwrap_or_else(|| CgroupStats::default_instance())
    }
    pub fn clear_cgroup_stats(&mut self) {
        self.cgroup_stats.clear();
    }

    pub fn has_cgroup_stats(&self) -> bool {
        self.cgroup_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_stats(&mut self, v: CgroupStats) {
        self.cgroup_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_stats(&mut self) -> &mut CgroupStats {
        if self.cgroup_stats.is_none() {
            self.cgroup_stats.set_default();
        }
        self.cgroup_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_cgroup_stats(&mut self) -> CgroupStats {
        self.cgroup_stats.take().unwrap_or_else(|| CgroupStats::new())
    }

    // repeated .grpc.NetworkStats network_stats = 2;


    pub fn get_network_stats(&self) -> &[NetworkStats] {
        &self.network_stats
    }
    pub fn clear_network_stats(&mut self) {
        self.network_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_stats(&mut self, v: ::protobuf::RepeatedField<NetworkStats>) {
        self.network_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_stats(&mut self) -> &mut ::protobuf::RepeatedField<NetworkStats> {
        &mut self.network_stats
    }

    // Take field
    pub fn take_network_stats(&mut self) -> ::protobuf::RepeatedField<NetworkStats> {
        ::std::mem::replace(&mut self.network_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StatsContainerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.cgroup_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cgroup_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.network_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.network_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsContainerResponse {
        StatsContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupStats>>(
                    "cgroup_stats",
                    |m: &StatsContainerResponse| { &m.cgroup_stats },
                    |m: &mut StatsContainerResponse| { &mut m.cgroup_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStats>>(
                    "network_stats",
                    |m: &StatsContainerResponse| { &m.network_stats },
                    |m: &mut StatsContainerResponse| { &mut m.network_stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsContainerResponse>(
                    "StatsContainerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsContainerResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatsContainerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatsContainerResponse,
        };
        unsafe {
            instance.get(StatsContainerResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatsContainerResponse {
    fn clear(&mut self) {
        self.cgroup_stats.clear();
        self.network_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStreamRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteStreamRequest {
    fn default() -> &'a WriteStreamRequest {
        <WriteStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamRequest {
    pub fn new() -> WriteStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WriteStreamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStreamRequest {
        WriteStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &WriteStreamRequest| { &m.container_id },
                    |m: &mut WriteStreamRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &WriteStreamRequest| { &m.exec_id },
                    |m: &mut WriteStreamRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &WriteStreamRequest| { &m.data },
                    |m: &mut WriteStreamRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteStreamRequest>(
                    "WriteStreamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStreamRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteStreamRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteStreamRequest,
        };
        unsafe {
            instance.get(WriteStreamRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteStreamRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStreamResponse {
    // message fields
    pub len: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteStreamResponse {
    fn default() -> &'a WriteStreamResponse {
        <WriteStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteStreamResponse {
    pub fn new() -> WriteStreamResponse {
        ::std::default::Default::default()
    }

    // uint32 len = 1;


    pub fn get_len(&self) -> u32 {
        self.len
    }
    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }
}

impl ::protobuf::Message for WriteStreamResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.len != 0 {
            my_size += ::protobuf::rt::value_size(1, self.len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.len != 0 {
            os.write_uint32(1, self.len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStreamResponse {
        WriteStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "len",
                    |m: &WriteStreamResponse| { &m.len },
                    |m: &mut WriteStreamResponse| { &mut m.len },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteStreamResponse>(
                    "WriteStreamResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStreamResponse {
        static mut instance: ::protobuf::lazy::Lazy<WriteStreamResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteStreamResponse,
        };
        unsafe {
            instance.get(WriteStreamResponse::new)
        }
    }
}

impl ::protobuf::Clear for WriteStreamResponse {
    fn clear(&mut self) {
        self.len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub len: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamRequest {
    fn default() -> &'a ReadStreamRequest {
        <ReadStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamRequest {
    pub fn new() -> ReadStreamRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 len = 3;


    pub fn get_len(&self) -> u32 {
        self.len
    }
    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }
}

impl ::protobuf::Message for ReadStreamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.len != 0 {
            my_size += ::protobuf::rt::value_size(3, self.len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.len != 0 {
            os.write_uint32(3, self.len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamRequest {
        ReadStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ReadStreamRequest| { &m.container_id },
                    |m: &mut ReadStreamRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &ReadStreamRequest| { &m.exec_id },
                    |m: &mut ReadStreamRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "len",
                    |m: &ReadStreamRequest| { &m.len },
                    |m: &mut ReadStreamRequest| { &mut m.len },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStreamRequest>(
                    "ReadStreamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStreamRequest,
        };
        unsafe {
            instance.get(ReadStreamRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamResponse {
    fn default() -> &'a ReadStreamResponse {
        <ReadStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamResponse {
    pub fn new() -> ReadStreamResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReadStreamResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamResponse {
        ReadStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ReadStreamResponse| { &m.data },
                    |m: &mut ReadStreamResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStreamResponse>(
                    "ReadStreamResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStreamResponse,
        };
        unsafe {
            instance.get(ReadStreamResponse::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseStdinRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseStdinRequest {
    fn default() -> &'a CloseStdinRequest {
        <CloseStdinRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseStdinRequest {
    pub fn new() -> CloseStdinRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CloseStdinRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStdinRequest {
        CloseStdinRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &CloseStdinRequest| { &m.container_id },
                    |m: &mut CloseStdinRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &CloseStdinRequest| { &m.exec_id },
                    |m: &mut CloseStdinRequest| { &mut m.exec_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseStdinRequest>(
                    "CloseStdinRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseStdinRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseStdinRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseStdinRequest,
        };
        unsafe {
            instance.get(CloseStdinRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseStdinRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStdinRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStdinRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TtyWinResizeRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub exec_id: ::std::string::String,
    pub row: u32,
    pub column: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TtyWinResizeRequest {
    fn default() -> &'a TtyWinResizeRequest {
        <TtyWinResizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl TtyWinResizeRequest {
    pub fn new() -> TtyWinResizeRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // string exec_id = 2;


    pub fn get_exec_id(&self) -> &str {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 row = 3;


    pub fn get_row(&self) -> u32 {
        self.row
    }
    pub fn clear_row(&mut self) {
        self.row = 0;
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: u32) {
        self.row = v;
    }

    // uint32 column = 4;


    pub fn get_column(&self) -> u32 {
        self.column
    }
    pub fn clear_column(&mut self) {
        self.column = 0;
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = v;
    }
}

impl ::protobuf::Message for TtyWinResizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.row = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.column = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.row != 0 {
            my_size += ::protobuf::rt::value_size(3, self.row, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column != 0 {
            my_size += ::protobuf::rt::value_size(4, self.column, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.row != 0 {
            os.write_uint32(3, self.row)?;
        }
        if self.column != 0 {
            os.write_uint32(4, self.column)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TtyWinResizeRequest {
        TtyWinResizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &TtyWinResizeRequest| { &m.container_id },
                    |m: &mut TtyWinResizeRequest| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exec_id",
                    |m: &TtyWinResizeRequest| { &m.exec_id },
                    |m: &mut TtyWinResizeRequest| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "row",
                    |m: &TtyWinResizeRequest| { &m.row },
                    |m: &mut TtyWinResizeRequest| { &mut m.row },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "column",
                    |m: &TtyWinResizeRequest| { &m.column },
                    |m: &mut TtyWinResizeRequest| { &mut m.column },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TtyWinResizeRequest>(
                    "TtyWinResizeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TtyWinResizeRequest {
        static mut instance: ::protobuf::lazy::Lazy<TtyWinResizeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TtyWinResizeRequest,
        };
        unsafe {
            instance.get(TtyWinResizeRequest::new)
        }
    }
}

impl ::protobuf::Clear for TtyWinResizeRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.exec_id.clear();
        self.row = 0;
        self.column = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TtyWinResizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TtyWinResizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSandboxRequest {
    // message fields
    pub hostname: ::std::string::String,
    pub dns: ::protobuf::RepeatedField<::std::string::String>,
    pub storages: ::protobuf::RepeatedField<Storage>,
    pub sandbox_pidns: bool,
    pub sandbox_id: ::std::string::String,
    pub guest_hook_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSandboxRequest {
    fn default() -> &'a CreateSandboxRequest {
        <CreateSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSandboxRequest {
    pub fn new() -> CreateSandboxRequest {
        ::std::default::Default::default()
    }

    // string hostname = 1;


    pub fn get_hostname(&self) -> &str {
        &self.hostname
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        &mut self.hostname
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hostname, ::std::string::String::new())
    }

    // repeated string dns = 2;


    pub fn get_dns(&self) -> &[::std::string::String] {
        &self.dns
    }
    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dns
    }

    // Take field
    pub fn take_dns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dns, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Storage storages = 3;


    pub fn get_storages(&self) -> &[Storage] {
        &self.storages
    }
    pub fn clear_storages(&mut self) {
        self.storages.clear();
    }

    // Param is passed by value, moved
    pub fn set_storages(&mut self, v: ::protobuf::RepeatedField<Storage>) {
        self.storages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storages(&mut self) -> &mut ::protobuf::RepeatedField<Storage> {
        &mut self.storages
    }

    // Take field
    pub fn take_storages(&mut self) -> ::protobuf::RepeatedField<Storage> {
        ::std::mem::replace(&mut self.storages, ::protobuf::RepeatedField::new())
    }

    // bool sandbox_pidns = 4;


    pub fn get_sandbox_pidns(&self) -> bool {
        self.sandbox_pidns
    }
    pub fn clear_sandbox_pidns(&mut self) {
        self.sandbox_pidns = false;
    }

    // Param is passed by value, moved
    pub fn set_sandbox_pidns(&mut self, v: bool) {
        self.sandbox_pidns = v;
    }

    // string sandbox_id = 5;


    pub fn get_sandbox_id(&self) -> &str {
        &self.sandbox_id
    }
    pub fn clear_sandbox_id(&mut self) {
        self.sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sandbox_id(&mut self, v: ::std::string::String) {
        self.sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.sandbox_id
    }

    // Take field
    pub fn take_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sandbox_id, ::std::string::String::new())
    }

    // string guest_hook_path = 6;


    pub fn get_guest_hook_path(&self) -> &str {
        &self.guest_hook_path
    }
    pub fn clear_guest_hook_path(&mut self) {
        self.guest_hook_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_guest_hook_path(&mut self, v: ::std::string::String) {
        self.guest_hook_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guest_hook_path(&mut self) -> &mut ::std::string::String {
        &mut self.guest_hook_path
    }

    // Take field
    pub fn take_guest_hook_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.guest_hook_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSandboxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.storages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hostname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dns)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sandbox_pidns = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sandbox_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.guest_hook_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hostname);
        }
        for value in &self.dns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.storages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.sandbox_pidns != false {
            my_size += 2;
        }
        if !self.sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sandbox_id);
        }
        if !self.guest_hook_path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.guest_hook_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hostname.is_empty() {
            os.write_string(1, &self.hostname)?;
        }
        for v in &self.dns {
            os.write_string(2, &v)?;
        };
        for v in &self.storages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.sandbox_pidns != false {
            os.write_bool(4, self.sandbox_pidns)?;
        }
        if !self.sandbox_id.is_empty() {
            os.write_string(5, &self.sandbox_id)?;
        }
        if !self.guest_hook_path.is_empty() {
            os.write_string(6, &self.guest_hook_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSandboxRequest {
        CreateSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    |m: &CreateSandboxRequest| { &m.hostname },
                    |m: &mut CreateSandboxRequest| { &mut m.hostname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dns",
                    |m: &CreateSandboxRequest| { &m.dns },
                    |m: &mut CreateSandboxRequest| { &mut m.dns },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Storage>>(
                    "storages",
                    |m: &CreateSandboxRequest| { &m.storages },
                    |m: &mut CreateSandboxRequest| { &mut m.storages },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sandbox_pidns",
                    |m: &CreateSandboxRequest| { &m.sandbox_pidns },
                    |m: &mut CreateSandboxRequest| { &mut m.sandbox_pidns },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sandbox_id",
                    |m: &CreateSandboxRequest| { &m.sandbox_id },
                    |m: &mut CreateSandboxRequest| { &mut m.sandbox_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "guest_hook_path",
                    |m: &CreateSandboxRequest| { &m.guest_hook_path },
                    |m: &mut CreateSandboxRequest| { &mut m.guest_hook_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSandboxRequest>(
                    "CreateSandboxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSandboxRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateSandboxRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSandboxRequest,
        };
        unsafe {
            instance.get(CreateSandboxRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateSandboxRequest {
    fn clear(&mut self) {
        self.hostname.clear();
        self.dns.clear();
        self.storages.clear();
        self.sandbox_pidns = false;
        self.sandbox_id.clear();
        self.guest_hook_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DestroySandboxRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestroySandboxRequest {
    fn default() -> &'a DestroySandboxRequest {
        <DestroySandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroySandboxRequest {
    pub fn new() -> DestroySandboxRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DestroySandboxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestroySandboxRequest {
        DestroySandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DestroySandboxRequest>(
                    "DestroySandboxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DestroySandboxRequest {
        static mut instance: ::protobuf::lazy::Lazy<DestroySandboxRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DestroySandboxRequest,
        };
        unsafe {
            instance.get(DestroySandboxRequest::new)
        }
    }
}

impl ::protobuf::Clear for DestroySandboxRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestroySandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroySandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Interfaces {
    // message fields
    pub Interfaces: ::protobuf::RepeatedField<super::types::Interface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Interfaces {
    fn default() -> &'a Interfaces {
        <Interfaces as ::protobuf::Message>::default_instance()
    }
}

impl Interfaces {
    pub fn new() -> Interfaces {
        ::std::default::Default::default()
    }

    // repeated .types.Interface Interfaces = 1;


    pub fn get_Interfaces(&self) -> &[super::types::Interface] {
        &self.Interfaces
    }
    pub fn clear_Interfaces(&mut self) {
        self.Interfaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Interfaces(&mut self, v: ::protobuf::RepeatedField<super::types::Interface>) {
        self.Interfaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Interfaces(&mut self) -> &mut ::protobuf::RepeatedField<super::types::Interface> {
        &mut self.Interfaces
    }

    // Take field
    pub fn take_Interfaces(&mut self) -> ::protobuf::RepeatedField<super::types::Interface> {
        ::std::mem::replace(&mut self.Interfaces, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Interfaces {
    fn is_initialized(&self) -> bool {
        for v in &self.Interfaces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Interfaces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Interfaces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Interfaces {
        Interfaces::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Interface>>(
                    "Interfaces",
                    |m: &Interfaces| { &m.Interfaces },
                    |m: &mut Interfaces| { &mut m.Interfaces },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Interfaces>(
                    "Interfaces",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Interfaces {
        static mut instance: ::protobuf::lazy::Lazy<Interfaces> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Interfaces,
        };
        unsafe {
            instance.get(Interfaces::new)
        }
    }
}

impl ::protobuf::Clear for Interfaces {
    fn clear(&mut self) {
        self.Interfaces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Interfaces {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Interfaces {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Routes {
    // message fields
    pub Routes: ::protobuf::RepeatedField<super::types::Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Routes {
    fn default() -> &'a Routes {
        <Routes as ::protobuf::Message>::default_instance()
    }
}

impl Routes {
    pub fn new() -> Routes {
        ::std::default::Default::default()
    }

    // repeated .types.Route Routes = 1;


    pub fn get_Routes(&self) -> &[super::types::Route] {
        &self.Routes
    }
    pub fn clear_Routes(&mut self) {
        self.Routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_Routes(&mut self, v: ::protobuf::RepeatedField<super::types::Route>) {
        self.Routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Routes(&mut self) -> &mut ::protobuf::RepeatedField<super::types::Route> {
        &mut self.Routes
    }

    // Take field
    pub fn take_Routes(&mut self) -> ::protobuf::RepeatedField<super::types::Route> {
        ::std::mem::replace(&mut self.Routes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Routes {
    fn is_initialized(&self) -> bool {
        for v in &self.Routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Routes {
        Routes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Route>>(
                    "Routes",
                    |m: &Routes| { &m.Routes },
                    |m: &mut Routes| { &mut m.Routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Routes>(
                    "Routes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Routes {
        static mut instance: ::protobuf::lazy::Lazy<Routes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Routes,
        };
        unsafe {
            instance.get(Routes::new)
        }
    }
}

impl ::protobuf::Clear for Routes {
    fn clear(&mut self) {
        self.Routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Routes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Routes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateInterfaceRequest {
    // message fields
    pub interface: ::protobuf::SingularPtrField<super::types::Interface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateInterfaceRequest {
    fn default() -> &'a UpdateInterfaceRequest {
        <UpdateInterfaceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInterfaceRequest {
    pub fn new() -> UpdateInterfaceRequest {
        ::std::default::Default::default()
    }

    // .types.Interface interface = 1;


    pub fn get_interface(&self) -> &super::types::Interface {
        self.interface.as_ref().unwrap_or_else(|| super::types::Interface::default_instance())
    }
    pub fn clear_interface(&mut self) {
        self.interface.clear();
    }

    pub fn has_interface(&self) -> bool {
        self.interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface(&mut self, v: super::types::Interface) {
        self.interface = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface(&mut self) -> &mut super::types::Interface {
        if self.interface.is_none() {
            self.interface.set_default();
        }
        self.interface.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface(&mut self) -> super::types::Interface {
        self.interface.take().unwrap_or_else(|| super::types::Interface::new())
    }
}

impl ::protobuf::Message for UpdateInterfaceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.interface {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interface)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.interface.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.interface.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInterfaceRequest {
        UpdateInterfaceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::types::Interface>>(
                    "interface",
                    |m: &UpdateInterfaceRequest| { &m.interface },
                    |m: &mut UpdateInterfaceRequest| { &mut m.interface },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateInterfaceRequest>(
                    "UpdateInterfaceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateInterfaceRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateInterfaceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateInterfaceRequest,
        };
        unsafe {
            instance.get(UpdateInterfaceRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateInterfaceRequest {
    fn clear(&mut self) {
        self.interface.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInterfaceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInterfaceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRoutesRequest {
    // message fields
    pub routes: ::protobuf::SingularPtrField<Routes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRoutesRequest {
    fn default() -> &'a UpdateRoutesRequest {
        <UpdateRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRoutesRequest {
    pub fn new() -> UpdateRoutesRequest {
        ::std::default::Default::default()
    }

    // .grpc.Routes routes = 1;


    pub fn get_routes(&self) -> &Routes {
        self.routes.as_ref().unwrap_or_else(|| Routes::default_instance())
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: Routes) {
        self.routes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut Routes {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> Routes {
        self.routes.take().unwrap_or_else(|| Routes::new())
    }
}

impl ::protobuf::Message for UpdateRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.routes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRoutesRequest {
        UpdateRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Routes>>(
                    "routes",
                    |m: &UpdateRoutesRequest| { &m.routes },
                    |m: &mut UpdateRoutesRequest| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateRoutesRequest>(
                    "UpdateRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateRoutesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateRoutesRequest,
        };
        unsafe {
            instance.get(UpdateRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateRoutesRequest {
    fn clear(&mut self) {
        self.routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInterfacesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInterfacesRequest {
    fn default() -> &'a ListInterfacesRequest {
        <ListInterfacesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInterfacesRequest {
    pub fn new() -> ListInterfacesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListInterfacesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInterfacesRequest {
        ListInterfacesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListInterfacesRequest>(
                    "ListInterfacesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInterfacesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListInterfacesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInterfacesRequest,
        };
        unsafe {
            instance.get(ListInterfacesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListInterfacesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInterfacesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInterfacesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRoutesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRoutesRequest {
    fn default() -> &'a ListRoutesRequest {
        <ListRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRoutesRequest {
    pub fn new() -> ListRoutesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListRoutesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRoutesRequest {
        ListRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListRoutesRequest>(
                    "ListRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRoutesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRoutesRequest,
        };
        unsafe {
            instance.get(ListRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRoutesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnlineCPUMemRequest {
    // message fields
    pub wait: bool,
    pub nb_cpus: u32,
    pub cpu_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnlineCPUMemRequest {
    fn default() -> &'a OnlineCPUMemRequest {
        <OnlineCPUMemRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnlineCPUMemRequest {
    pub fn new() -> OnlineCPUMemRequest {
        ::std::default::Default::default()
    }

    // bool wait = 1;


    pub fn get_wait(&self) -> bool {
        self.wait
    }
    pub fn clear_wait(&mut self) {
        self.wait = false;
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = v;
    }

    // uint32 nb_cpus = 2;


    pub fn get_nb_cpus(&self) -> u32 {
        self.nb_cpus
    }
    pub fn clear_nb_cpus(&mut self) {
        self.nb_cpus = 0;
    }

    // Param is passed by value, moved
    pub fn set_nb_cpus(&mut self, v: u32) {
        self.nb_cpus = v;
    }

    // bool cpu_only = 3;


    pub fn get_cpu_only(&self) -> bool {
        self.cpu_only
    }
    pub fn clear_cpu_only(&mut self) {
        self.cpu_only = false;
    }

    // Param is passed by value, moved
    pub fn set_cpu_only(&mut self, v: bool) {
        self.cpu_only = v;
    }
}

impl ::protobuf::Message for OnlineCPUMemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nb_cpus = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cpu_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wait != false {
            my_size += 2;
        }
        if self.nb_cpus != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nb_cpus, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.wait != false {
            os.write_bool(1, self.wait)?;
        }
        if self.nb_cpus != 0 {
            os.write_uint32(2, self.nb_cpus)?;
        }
        if self.cpu_only != false {
            os.write_bool(3, self.cpu_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnlineCPUMemRequest {
        OnlineCPUMemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wait",
                    |m: &OnlineCPUMemRequest| { &m.wait },
                    |m: &mut OnlineCPUMemRequest| { &mut m.wait },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nb_cpus",
                    |m: &OnlineCPUMemRequest| { &m.nb_cpus },
                    |m: &mut OnlineCPUMemRequest| { &mut m.nb_cpus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cpu_only",
                    |m: &OnlineCPUMemRequest| { &m.cpu_only },
                    |m: &mut OnlineCPUMemRequest| { &mut m.cpu_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OnlineCPUMemRequest>(
                    "OnlineCPUMemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OnlineCPUMemRequest {
        static mut instance: ::protobuf::lazy::Lazy<OnlineCPUMemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OnlineCPUMemRequest,
        };
        unsafe {
            instance.get(OnlineCPUMemRequest::new)
        }
    }
}

impl ::protobuf::Clear for OnlineCPUMemRequest {
    fn clear(&mut self) {
        self.wait = false;
        self.nb_cpus = 0;
        self.cpu_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnlineCPUMemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineCPUMemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReseedRandomDevRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReseedRandomDevRequest {
    fn default() -> &'a ReseedRandomDevRequest {
        <ReseedRandomDevRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReseedRandomDevRequest {
    pub fn new() -> ReseedRandomDevRequest {
        ::std::default::Default::default()
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReseedRandomDevRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReseedRandomDevRequest {
        ReseedRandomDevRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ReseedRandomDevRequest| { &m.data },
                    |m: &mut ReseedRandomDevRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReseedRandomDevRequest>(
                    "ReseedRandomDevRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReseedRandomDevRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReseedRandomDevRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReseedRandomDevRequest,
        };
        unsafe {
            instance.get(ReseedRandomDevRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReseedRandomDevRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReseedRandomDevRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReseedRandomDevRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentDetails {
    // message fields
    pub version: ::std::string::String,
    pub init_daemon: bool,
    pub device_handlers: ::protobuf::RepeatedField<::std::string::String>,
    pub storage_handlers: ::protobuf::RepeatedField<::std::string::String>,
    pub supports_seccomp: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AgentDetails {
    fn default() -> &'a AgentDetails {
        <AgentDetails as ::protobuf::Message>::default_instance()
    }
}

impl AgentDetails {
    pub fn new() -> AgentDetails {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bool init_daemon = 2;


    pub fn get_init_daemon(&self) -> bool {
        self.init_daemon
    }
    pub fn clear_init_daemon(&mut self) {
        self.init_daemon = false;
    }

    // Param is passed by value, moved
    pub fn set_init_daemon(&mut self, v: bool) {
        self.init_daemon = v;
    }

    // repeated string device_handlers = 3;


    pub fn get_device_handlers(&self) -> &[::std::string::String] {
        &self.device_handlers
    }
    pub fn clear_device_handlers(&mut self) {
        self.device_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_handlers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_handlers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_handlers
    }

    // Take field
    pub fn take_device_handlers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_handlers, ::protobuf::RepeatedField::new())
    }

    // repeated string storage_handlers = 4;


    pub fn get_storage_handlers(&self) -> &[::std::string::String] {
        &self.storage_handlers
    }
    pub fn clear_storage_handlers(&mut self) {
        self.storage_handlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_handlers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storage_handlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storage_handlers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storage_handlers
    }

    // Take field
    pub fn take_storage_handlers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storage_handlers, ::protobuf::RepeatedField::new())
    }

    // bool supports_seccomp = 5;


    pub fn get_supports_seccomp(&self) -> bool {
        self.supports_seccomp
    }
    pub fn clear_supports_seccomp(&mut self) {
        self.supports_seccomp = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_seccomp(&mut self, v: bool) {
        self.supports_seccomp = v;
    }
}

impl ::protobuf::Message for AgentDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.init_daemon = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_handlers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storage_handlers)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_seccomp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.init_daemon != false {
            my_size += 2;
        }
        for value in &self.device_handlers {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.storage_handlers {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.supports_seccomp != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.init_daemon != false {
            os.write_bool(2, self.init_daemon)?;
        }
        for v in &self.device_handlers {
            os.write_string(3, &v)?;
        };
        for v in &self.storage_handlers {
            os.write_string(4, &v)?;
        };
        if self.supports_seccomp != false {
            os.write_bool(5, self.supports_seccomp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentDetails {
        AgentDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &AgentDetails| { &m.version },
                    |m: &mut AgentDetails| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "init_daemon",
                    |m: &AgentDetails| { &m.init_daemon },
                    |m: &mut AgentDetails| { &mut m.init_daemon },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_handlers",
                    |m: &AgentDetails| { &m.device_handlers },
                    |m: &mut AgentDetails| { &mut m.device_handlers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storage_handlers",
                    |m: &AgentDetails| { &m.storage_handlers },
                    |m: &mut AgentDetails| { &mut m.storage_handlers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_seccomp",
                    |m: &AgentDetails| { &m.supports_seccomp },
                    |m: &mut AgentDetails| { &mut m.supports_seccomp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentDetails>(
                    "AgentDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentDetails {
        static mut instance: ::protobuf::lazy::Lazy<AgentDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentDetails,
        };
        unsafe {
            instance.get(AgentDetails::new)
        }
    }
}

impl ::protobuf::Clear for AgentDetails {
    fn clear(&mut self) {
        self.version.clear();
        self.init_daemon = false;
        self.device_handlers.clear();
        self.storage_handlers.clear();
        self.supports_seccomp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuestDetailsRequest {
    // message fields
    pub mem_block_size: bool,
    pub mem_hotplug_probe: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuestDetailsRequest {
    fn default() -> &'a GuestDetailsRequest {
        <GuestDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsRequest {
    pub fn new() -> GuestDetailsRequest {
        ::std::default::Default::default()
    }

    // bool mem_block_size = 1;


    pub fn get_mem_block_size(&self) -> bool {
        self.mem_block_size
    }
    pub fn clear_mem_block_size(&mut self) {
        self.mem_block_size = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size(&mut self, v: bool) {
        self.mem_block_size = v;
    }

    // bool mem_hotplug_probe = 2;


    pub fn get_mem_hotplug_probe(&self) -> bool {
        self.mem_hotplug_probe
    }
    pub fn clear_mem_hotplug_probe(&mut self) {
        self.mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_mem_hotplug_probe(&mut self, v: bool) {
        self.mem_hotplug_probe = v;
    }
}

impl ::protobuf::Message for GuestDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mem_block_size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mem_hotplug_probe = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mem_block_size != false {
            my_size += 2;
        }
        if self.mem_hotplug_probe != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mem_block_size != false {
            os.write_bool(1, self.mem_block_size)?;
        }
        if self.mem_hotplug_probe != false {
            os.write_bool(2, self.mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuestDetailsRequest {
        GuestDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mem_block_size",
                    |m: &GuestDetailsRequest| { &m.mem_block_size },
                    |m: &mut GuestDetailsRequest| { &mut m.mem_block_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mem_hotplug_probe",
                    |m: &GuestDetailsRequest| { &m.mem_hotplug_probe },
                    |m: &mut GuestDetailsRequest| { &mut m.mem_hotplug_probe },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GuestDetailsRequest>(
                    "GuestDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuestDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GuestDetailsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GuestDetailsRequest,
        };
        unsafe {
            instance.get(GuestDetailsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GuestDetailsRequest {
    fn clear(&mut self) {
        self.mem_block_size = false;
        self.mem_hotplug_probe = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuestDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuestDetailsResponse {
    // message fields
    pub mem_block_size_bytes: u64,
    pub agent_details: ::protobuf::SingularPtrField<AgentDetails>,
    pub support_mem_hotplug_probe: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuestDetailsResponse {
    fn default() -> &'a GuestDetailsResponse {
        <GuestDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GuestDetailsResponse {
    pub fn new() -> GuestDetailsResponse {
        ::std::default::Default::default()
    }

    // uint64 mem_block_size_bytes = 1;


    pub fn get_mem_block_size_bytes(&self) -> u64 {
        self.mem_block_size_bytes
    }
    pub fn clear_mem_block_size_bytes(&mut self) {
        self.mem_block_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_mem_block_size_bytes(&mut self, v: u64) {
        self.mem_block_size_bytes = v;
    }

    // .grpc.AgentDetails agent_details = 2;


    pub fn get_agent_details(&self) -> &AgentDetails {
        self.agent_details.as_ref().unwrap_or_else(|| AgentDetails::default_instance())
    }
    pub fn clear_agent_details(&mut self) {
        self.agent_details.clear();
    }

    pub fn has_agent_details(&self) -> bool {
        self.agent_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_details(&mut self, v: AgentDetails) {
        self.agent_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_details(&mut self) -> &mut AgentDetails {
        if self.agent_details.is_none() {
            self.agent_details.set_default();
        }
        self.agent_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_details(&mut self) -> AgentDetails {
        self.agent_details.take().unwrap_or_else(|| AgentDetails::new())
    }

    // bool support_mem_hotplug_probe = 3;


    pub fn get_support_mem_hotplug_probe(&self) -> bool {
        self.support_mem_hotplug_probe
    }
    pub fn clear_support_mem_hotplug_probe(&mut self) {
        self.support_mem_hotplug_probe = false;
    }

    // Param is passed by value, moved
    pub fn set_support_mem_hotplug_probe(&mut self, v: bool) {
        self.support_mem_hotplug_probe = v;
    }
}

impl ::protobuf::Message for GuestDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.agent_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mem_block_size_bytes = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_details)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support_mem_hotplug_probe = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mem_block_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mem_block_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.agent_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.support_mem_hotplug_probe != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mem_block_size_bytes != 0 {
            os.write_uint64(1, self.mem_block_size_bytes)?;
        }
        if let Some(ref v) = self.agent_details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.support_mem_hotplug_probe != false {
            os.write_bool(3, self.support_mem_hotplug_probe)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuestDetailsResponse {
        GuestDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mem_block_size_bytes",
                    |m: &GuestDetailsResponse| { &m.mem_block_size_bytes },
                    |m: &mut GuestDetailsResponse| { &mut m.mem_block_size_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgentDetails>>(
                    "agent_details",
                    |m: &GuestDetailsResponse| { &m.agent_details },
                    |m: &mut GuestDetailsResponse| { &mut m.agent_details },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "support_mem_hotplug_probe",
                    |m: &GuestDetailsResponse| { &m.support_mem_hotplug_probe },
                    |m: &mut GuestDetailsResponse| { &mut m.support_mem_hotplug_probe },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GuestDetailsResponse>(
                    "GuestDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuestDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GuestDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GuestDetailsResponse,
        };
        unsafe {
            instance.get(GuestDetailsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GuestDetailsResponse {
    fn clear(&mut self) {
        self.mem_block_size_bytes = 0;
        self.agent_details.clear();
        self.support_mem_hotplug_probe = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuestDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuestDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemHotplugByProbeRequest {
    // message fields
    pub memHotplugProbeAddr: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemHotplugByProbeRequest {
    fn default() -> &'a MemHotplugByProbeRequest {
        <MemHotplugByProbeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemHotplugByProbeRequest {
    pub fn new() -> MemHotplugByProbeRequest {
        ::std::default::Default::default()
    }

    // repeated uint64 memHotplugProbeAddr = 1;


    pub fn get_memHotplugProbeAddr(&self) -> &[u64] {
        &self.memHotplugProbeAddr
    }
    pub fn clear_memHotplugProbeAddr(&mut self) {
        self.memHotplugProbeAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_memHotplugProbeAddr(&mut self, v: ::std::vec::Vec<u64>) {
        self.memHotplugProbeAddr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memHotplugProbeAddr(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.memHotplugProbeAddr
    }

    // Take field
    pub fn take_memHotplugProbeAddr(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.memHotplugProbeAddr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MemHotplugByProbeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.memHotplugProbeAddr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.memHotplugProbeAddr {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.memHotplugProbeAddr {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemHotplugByProbeRequest {
        MemHotplugByProbeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memHotplugProbeAddr",
                    |m: &MemHotplugByProbeRequest| { &m.memHotplugProbeAddr },
                    |m: &mut MemHotplugByProbeRequest| { &mut m.memHotplugProbeAddr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemHotplugByProbeRequest>(
                    "MemHotplugByProbeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemHotplugByProbeRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemHotplugByProbeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemHotplugByProbeRequest,
        };
        unsafe {
            instance.get(MemHotplugByProbeRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemHotplugByProbeRequest {
    fn clear(&mut self) {
        self.memHotplugProbeAddr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemHotplugByProbeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemHotplugByProbeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetGuestDateTimeRequest {
    // message fields
    pub Sec: i64,
    pub Usec: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetGuestDateTimeRequest {
    fn default() -> &'a SetGuestDateTimeRequest {
        <SetGuestDateTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetGuestDateTimeRequest {
    pub fn new() -> SetGuestDateTimeRequest {
        ::std::default::Default::default()
    }

    // int64 Sec = 1;


    pub fn get_Sec(&self) -> i64 {
        self.Sec
    }
    pub fn clear_Sec(&mut self) {
        self.Sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Sec(&mut self, v: i64) {
        self.Sec = v;
    }

    // int64 Usec = 2;


    pub fn get_Usec(&self) -> i64 {
        self.Usec
    }
    pub fn clear_Usec(&mut self) {
        self.Usec = 0;
    }

    // Param is passed by value, moved
    pub fn set_Usec(&mut self, v: i64) {
        self.Usec = v;
    }
}

impl ::protobuf::Message for SetGuestDateTimeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Sec = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Usec = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Sec != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Sec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Usec != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Usec, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.Sec != 0 {
            os.write_int64(1, self.Sec)?;
        }
        if self.Usec != 0 {
            os.write_int64(2, self.Usec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetGuestDateTimeRequest {
        SetGuestDateTimeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Sec",
                    |m: &SetGuestDateTimeRequest| { &m.Sec },
                    |m: &mut SetGuestDateTimeRequest| { &mut m.Sec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Usec",
                    |m: &SetGuestDateTimeRequest| { &m.Usec },
                    |m: &mut SetGuestDateTimeRequest| { &mut m.Usec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetGuestDateTimeRequest>(
                    "SetGuestDateTimeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetGuestDateTimeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetGuestDateTimeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetGuestDateTimeRequest,
        };
        unsafe {
            instance.get(SetGuestDateTimeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetGuestDateTimeRequest {
    fn clear(&mut self) {
        self.Sec = 0;
        self.Usec = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetGuestDateTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetGuestDateTimeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Storage {
    // message fields
    pub driver: ::std::string::String,
    pub driver_options: ::protobuf::RepeatedField<::std::string::String>,
    pub source: ::std::string::String,
    pub fstype: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    pub mount_point: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Storage {
    fn default() -> &'a Storage {
        <Storage as ::protobuf::Message>::default_instance()
    }
}

impl Storage {
    pub fn new() -> Storage {
        ::std::default::Default::default()
    }

    // string driver = 1;


    pub fn get_driver(&self) -> &str {
        &self.driver
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }

    // repeated string driver_options = 2;


    pub fn get_driver_options(&self) -> &[::std::string::String] {
        &self.driver_options
    }
    pub fn clear_driver_options(&mut self) {
        self.driver_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.driver_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_driver_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.driver_options
    }

    // Take field
    pub fn take_driver_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.driver_options, ::protobuf::RepeatedField::new())
    }

    // string source = 3;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // string fstype = 4;


    pub fn get_fstype(&self) -> &str {
        &self.fstype
    }
    pub fn clear_fstype(&mut self) {
        self.fstype.clear();
    }

    // Param is passed by value, moved
    pub fn set_fstype(&mut self, v: ::std::string::String) {
        self.fstype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fstype(&mut self) -> &mut ::std::string::String {
        &mut self.fstype
    }

    // Take field
    pub fn take_fstype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fstype, ::std::string::String::new())
    }

    // repeated string options = 5;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }

    // string mount_point = 6;


    pub fn get_mount_point(&self) -> &str {
        &self.mount_point
    }
    pub fn clear_mount_point(&mut self) {
        self.mount_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_mount_point(&mut self, v: ::std::string::String) {
        self.mount_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount_point(&mut self) -> &mut ::std::string::String {
        &mut self.mount_point
    }

    // Take field
    pub fn take_mount_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mount_point, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Storage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.driver_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fstype)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mount_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.driver);
        }
        for value in &self.driver_options {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if !self.fstype.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fstype);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.mount_point.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mount_point);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.driver.is_empty() {
            os.write_string(1, &self.driver)?;
        }
        for v in &self.driver_options {
            os.write_string(2, &v)?;
        };
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if !self.fstype.is_empty() {
            os.write_string(4, &self.fstype)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        if !self.mount_point.is_empty() {
            os.write_string(6, &self.mount_point)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Storage {
        Storage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver",
                    |m: &Storage| { &m.driver },
                    |m: &mut Storage| { &mut m.driver },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver_options",
                    |m: &Storage| { &m.driver_options },
                    |m: &mut Storage| { &mut m.driver_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &Storage| { &m.source },
                    |m: &mut Storage| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fstype",
                    |m: &Storage| { &m.fstype },
                    |m: &mut Storage| { &mut m.fstype },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &Storage| { &m.options },
                    |m: &mut Storage| { &mut m.options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mount_point",
                    |m: &Storage| { &m.mount_point },
                    |m: &mut Storage| { &mut m.mount_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Storage>(
                    "Storage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Storage {
        static mut instance: ::protobuf::lazy::Lazy<Storage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Storage,
        };
        unsafe {
            instance.get(Storage::new)
        }
    }
}

impl ::protobuf::Clear for Storage {
    fn clear(&mut self) {
        self.driver.clear();
        self.driver_options.clear();
        self.source.clear();
        self.fstype.clear();
        self.options.clear();
        self.mount_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Storage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub vm_path: ::std::string::String,
    pub container_path: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string vm_path = 3;


    pub fn get_vm_path(&self) -> &str {
        &self.vm_path
    }
    pub fn clear_vm_path(&mut self) {
        self.vm_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm_path(&mut self, v: ::std::string::String) {
        self.vm_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm_path(&mut self) -> &mut ::std::string::String {
        &mut self.vm_path
    }

    // Take field
    pub fn take_vm_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm_path, ::std::string::String::new())
    }

    // string container_path = 4;


    pub fn get_container_path(&self) -> &str {
        &self.container_path
    }
    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        &mut self.container_path
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_path, ::std::string::String::new())
    }

    // repeated string options = 5;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vm_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_path)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if !self.vm_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.vm_path);
        }
        if !self.container_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.container_path);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if !self.vm_path.is_empty() {
            os.write_string(3, &self.vm_path)?;
        }
        if !self.container_path.is_empty() {
            os.write_string(4, &self.container_path)?;
        }
        for v in &self.options {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Device| { &m.id },
                    |m: &mut Device| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Device| { &m.field_type },
                    |m: &mut Device| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vm_path",
                    |m: &Device| { &m.vm_path },
                    |m: &mut Device| { &mut m.vm_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_path",
                    |m: &Device| { &m.container_path },
                    |m: &mut Device| { &mut m.container_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &Device| { &m.options },
                    |m: &mut Device| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device,
        };
        unsafe {
            instance.get(Device::new)
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.vm_path.clear();
        self.container_path.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringUser {
    // message fields
    pub uid: ::std::string::String,
    pub gid: ::std::string::String,
    pub additionalGids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringUser {
    fn default() -> &'a StringUser {
        <StringUser as ::protobuf::Message>::default_instance()
    }
}

impl StringUser {
    pub fn new() -> StringUser {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string gid = 2;


    pub fn get_gid(&self) -> &str {
        &self.gid
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::string::String) {
        self.gid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::string::String {
        &mut self.gid
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gid, ::std::string::String::new())
    }

    // repeated string additionalGids = 3;


    pub fn get_additionalGids(&self) -> &[::std::string::String] {
        &self.additionalGids
    }
    pub fn clear_additionalGids(&mut self) {
        self.additionalGids.clear();
    }

    // Param is passed by value, moved
    pub fn set_additionalGids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additionalGids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additionalGids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additionalGids
    }

    // Take field
    pub fn take_additionalGids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additionalGids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StringUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additionalGids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.gid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.gid);
        }
        for value in &self.additionalGids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.gid.is_empty() {
            os.write_string(2, &self.gid)?;
        }
        for v in &self.additionalGids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringUser {
        StringUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &StringUser| { &m.uid },
                    |m: &mut StringUser| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gid",
                    |m: &StringUser| { &m.gid },
                    |m: &mut StringUser| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "additionalGids",
                    |m: &StringUser| { &m.additionalGids },
                    |m: &mut StringUser| { &mut m.additionalGids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StringUser>(
                    "StringUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringUser {
        static mut instance: ::protobuf::lazy::Lazy<StringUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StringUser,
        };
        unsafe {
            instance.get(StringUser::new)
        }
    }
}

impl ::protobuf::Clear for StringUser {
    fn clear(&mut self) {
        self.uid.clear();
        self.gid.clear();
        self.additionalGids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyFileRequest {
    // message fields
    pub path: ::std::string::String,
    pub file_size: i64,
    pub file_mode: u32,
    pub dir_mode: u32,
    pub uid: i32,
    pub gid: i32,
    pub offset: i64,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyFileRequest {
    fn default() -> &'a CopyFileRequest {
        <CopyFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyFileRequest {
    pub fn new() -> CopyFileRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // int64 file_size = 2;


    pub fn get_file_size(&self) -> i64 {
        self.file_size
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: i64) {
        self.file_size = v;
    }

    // uint32 file_mode = 3;


    pub fn get_file_mode(&self) -> u32 {
        self.file_mode
    }
    pub fn clear_file_mode(&mut self) {
        self.file_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_mode(&mut self, v: u32) {
        self.file_mode = v;
    }

    // uint32 dir_mode = 4;


    pub fn get_dir_mode(&self) -> u32 {
        self.dir_mode
    }
    pub fn clear_dir_mode(&mut self) {
        self.dir_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_dir_mode(&mut self, v: u32) {
        self.dir_mode = v;
    }

    // int32 uid = 5;


    pub fn get_uid(&self) -> i32 {
        self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = v;
    }

    // int32 gid = 6;


    pub fn get_gid(&self) -> i32 {
        self.gid
    }
    pub fn clear_gid(&mut self) {
        self.gid = 0;
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: i32) {
        self.gid = v;
    }

    // int64 offset = 7;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // bytes data = 8;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CopyFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.file_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_mode = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dir_mode = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uid = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gid = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.file_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.file_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.file_mode != 0 {
            my_size += ::protobuf::rt::value_size(3, self.file_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dir_mode != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dir_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::value_size(5, self.uid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gid != 0 {
            my_size += ::protobuf::rt::value_size(6, self.gid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(7, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.file_size != 0 {
            os.write_int64(2, self.file_size)?;
        }
        if self.file_mode != 0 {
            os.write_uint32(3, self.file_mode)?;
        }
        if self.dir_mode != 0 {
            os.write_uint32(4, self.dir_mode)?;
        }
        if self.uid != 0 {
            os.write_int32(5, self.uid)?;
        }
        if self.gid != 0 {
            os.write_int32(6, self.gid)?;
        }
        if self.offset != 0 {
            os.write_int64(7, self.offset)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(8, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyFileRequest {
        CopyFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CopyFileRequest| { &m.path },
                    |m: &mut CopyFileRequest| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "file_size",
                    |m: &CopyFileRequest| { &m.file_size },
                    |m: &mut CopyFileRequest| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_mode",
                    |m: &CopyFileRequest| { &m.file_mode },
                    |m: &mut CopyFileRequest| { &mut m.file_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dir_mode",
                    |m: &CopyFileRequest| { &m.dir_mode },
                    |m: &mut CopyFileRequest| { &mut m.dir_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "uid",
                    |m: &CopyFileRequest| { &m.uid },
                    |m: &mut CopyFileRequest| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gid",
                    |m: &CopyFileRequest| { &m.gid },
                    |m: &mut CopyFileRequest| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &CopyFileRequest| { &m.offset },
                    |m: &mut CopyFileRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &CopyFileRequest| { &m.data },
                    |m: &mut CopyFileRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CopyFileRequest>(
                    "CopyFileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyFileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CopyFileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CopyFileRequest,
        };
        unsafe {
            instance.get(CopyFileRequest::new)
        }
    }
}

impl ::protobuf::Clear for CopyFileRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.file_size = 0;
        self.file_mode = 0;
        self.dir_mode = 0;
        self.uid = 0;
        self.gid = 0;
        self.offset = 0;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartTracingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartTracingRequest {
    fn default() -> &'a StartTracingRequest {
        <StartTracingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartTracingRequest {
    pub fn new() -> StartTracingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartTracingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartTracingRequest {
        StartTracingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StartTracingRequest>(
                    "StartTracingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartTracingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartTracingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartTracingRequest,
        };
        unsafe {
            instance.get(StartTracingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartTracingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartTracingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartTracingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopTracingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopTracingRequest {
    fn default() -> &'a StopTracingRequest {
        <StopTracingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopTracingRequest {
    pub fn new() -> StopTracingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopTracingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopTracingRequest {
        StopTracingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopTracingRequest>(
                    "StopTracingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopTracingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopTracingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopTracingRequest,
        };
        unsafe {
            instance.get(StopTracingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopTracingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopTracingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopTracingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bagent.proto\x12\x04grpc\x1a\toci.proto\x1a6github.com/kata-contain\
    ers/agent/pkg/types/types.proto\x1a\x1bgoogle/protobuf/empty.proto\"\x9d\
    \x02\n\x16CreateContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\
    \tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\
    \x121\n\x0bstring_user\x18\x03\x20\x01(\x0b2\x10.grpc.StringUserR\nstrin\
    gUser\x12&\n\x07devices\x18\x04\x20\x03(\x0b2\x0c.grpc.DeviceR\x07device\
    s\x12)\n\x08storages\x18\x05\x20\x03(\x0b2\r.grpc.StorageR\x08storages\
    \x12\x1c\n\x03OCI\x18\x06\x20\x01(\x0b2\n.grpc.SpecR\x03OCI\x12#\n\rsand\
    box_pidns\x18\x07\x20\x01(\x08R\x0csandboxPidns\":\n\x15StartContainerRe\
    quest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\"U\n\x16\
    RemoveContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcon\
    tainerId\x12\x18\n\x07timeout\x18\x02\x20\x01(\rR\x07timeout\"\xac\x01\n\
    \x12ExecProcessRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcon\
    tainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\x121\n\x0bst\
    ring_user\x18\x03\x20\x01(\x0b2\x10.grpc.StringUserR\nstringUser\x12'\n\
    \x07process\x18\x04\x20\x01(\x0b2\r.grpc.ProcessR\x07process\"j\n\x14Sig\
    nalProcessRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontaine\
    rId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\x12\x16\n\x06sign\
    al\x18\x03\x20\x01(\rR\x06signal\"P\n\x12WaitProcessRequest\x12!\n\x0cco\
    ntainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\
    \x02\x20\x01(\tR\x06execId\"-\n\x13WaitProcessResponse\x12\x16\n\x06stat\
    us\x18\x01\x20\x01(\x05R\x06status\"e\n\x14ListProcessesRequest\x12!\n\
    \x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x16\n\x06format\
    \x18\x02\x20\x01(\tR\x06format\x12\x12\n\x04args\x18\x03\x20\x03(\tR\x04\
    args\":\n\x15ListProcessesResponse\x12!\n\x0cprocess_list\x18\x01\x20\
    \x01(\x0cR\x0bprocessList\"o\n\x16UpdateContainerRequest\x12!\n\x0cconta\
    iner_id\x18\x01\x20\x01(\tR\x0bcontainerId\x122\n\tresources\x18\x02\x20\
    \x01(\x0b2\x14.grpc.LinuxResourcesR\tresources\":\n\x15StatsContainerReq\
    uest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\":\n\x15P\
    auseContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bconta\
    inerId\";\n\x16ResumeContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\
    \x01(\tR\x0bcontainerId\"\xaa\x01\n\x08CpuUsage\x12\x1f\n\x0btotal_usage\
    \x18\x01\x20\x01(\x04R\ntotalUsage\x12!\n\x0cpercpu_usage\x18\x02\x20\
    \x03(\x04R\x0bpercpuUsage\x12.\n\x13usage_in_kernelmode\x18\x03\x20\x01(\
    \x04R\x11usageInKernelmode\x12*\n\x11usage_in_usermode\x18\x04\x20\x01(\
    \x04R\x0fusageInUsermode\"~\n\x0eThrottlingData\x12\x18\n\x07periods\x18\
    \x01\x20\x01(\x04R\x07periods\x12+\n\x11throttled_periods\x18\x02\x20\
    \x01(\x04R\x10throttledPeriods\x12%\n\x0ethrottled_time\x18\x03\x20\x01(\
    \x04R\rthrottledTime\"v\n\x08CpuStats\x12+\n\tcpu_usage\x18\x01\x20\x01(\
    \x0b2\x0e.grpc.CpuUsageR\x08cpuUsage\x12=\n\x0fthrottling_data\x18\x02\
    \x20\x01(\x0b2\x14.grpc.ThrottlingDataR\x0ethrottlingData\";\n\tPidsStat\
    s\x12\x18\n\x07current\x18\x01\x20\x01(\x04R\x07current\x12\x14\n\x05lim\
    it\x18\x02\x20\x01(\x04R\x05limit\"o\n\nMemoryData\x12\x14\n\x05usage\
    \x18\x01\x20\x01(\x04R\x05usage\x12\x1b\n\tmax_usage\x18\x02\x20\x01(\
    \x04R\x08maxUsage\x12\x18\n\x07failcnt\x18\x03\x20\x01(\x04R\x07failcnt\
    \x12\x14\n\x05limit\x18\x04\x20\x01(\x04R\x05limit\"\xc4\x02\n\x0bMemory\
    Stats\x12\x14\n\x05cache\x18\x01\x20\x01(\x04R\x05cache\x12&\n\x05usage\
    \x18\x02\x20\x01(\x0b2\x10.grpc.MemoryDataR\x05usage\x12/\n\nswap_usage\
    \x18\x03\x20\x01(\x0b2\x10.grpc.MemoryDataR\tswapUsage\x123\n\x0ckernel_\
    usage\x18\x04\x20\x01(\x0b2\x10.grpc.MemoryDataR\x0bkernelUsage\x12#\n\r\
    use_hierarchy\x18\x05\x20\x01(\x08R\x0cuseHierarchy\x122\n\x05stats\x18\
    \x06\x20\x03(\x0b2\x1c.grpc.MemoryStats.StatsEntryR\x05stats\x1a8\n\nSta\
    tsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x04R\x05value:\x028\x01\"c\n\x0fBlkioStatsEntry\x12\
    \x14\n\x05major\x18\x01\x20\x01(\x04R\x05major\x12\x14\n\x05minor\x18\
    \x02\x20\x01(\x04R\x05minor\x12\x0e\n\x02op\x18\x03\x20\x01(\tR\x02op\
    \x12\x14\n\x05value\x18\x04\x20\x01(\x04R\x05value\"\xde\x04\n\nBlkioSta\
    ts\x12R\n\x1aio_service_bytes_recursive\x18\x01\x20\x03(\x0b2\x15.grpc.B\
    lkioStatsEntryR\x17ioServiceBytesRecursive\x12I\n\x15io_serviced_recursi\
    ve\x18\x02\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x13ioServicedRecursiv\
    e\x12E\n\x13io_queued_recursive\x18\x03\x20\x03(\x0b2\x15.grpc.BlkioStat\
    sEntryR\x11ioQueuedRecursive\x12P\n\x19io_service_time_recursive\x18\x04\
    \x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x16ioServiceTimeRecursive\x12J\
    \n\x16io_wait_time_recursive\x18\x05\x20\x03(\x0b2\x15.grpc.BlkioStatsEn\
    tryR\x13ioWaitTimeRecursive\x12E\n\x13io_merged_recursive\x18\x06\x20\
    \x03(\x0b2\x15.grpc.BlkioStatsEntryR\x11ioMergedRecursive\x12A\n\x11io_t\
    ime_recursive\x18\x07\x20\x03(\x0b2\x15.grpc.BlkioStatsEntryR\x0fioTimeR\
    ecursive\x12B\n\x11sectors_recursive\x18\x08\x20\x03(\x0b2\x15.grpc.Blki\
    oStatsEntryR\x10sectorsRecursive\"[\n\x0cHugetlbStats\x12\x14\n\x05usage\
    \x18\x01\x20\x01(\x04R\x05usage\x12\x1b\n\tmax_usage\x18\x02\x20\x01(\
    \x04R\x08maxUsage\x12\x18\n\x07failcnt\x18\x03\x20\x01(\x04R\x07failcnt\
    \"\xf2\x02\n\x0bCgroupStats\x12+\n\tcpu_stats\x18\x01\x20\x01(\x0b2\x0e.\
    grpc.CpuStatsR\x08cpuStats\x124\n\x0cmemory_stats\x18\x02\x20\x01(\x0b2\
    \x11.grpc.MemoryStatsR\x0bmemoryStats\x12.\n\npids_stats\x18\x03\x20\x01\
    (\x0b2\x0f.grpc.PidsStatsR\tpidsStats\x121\n\x0bblkio_stats\x18\x04\x20\
    \x01(\x0b2\x10.grpc.BlkioStatsR\nblkioStats\x12H\n\rhugetlb_stats\x18\
    \x05\x20\x03(\x0b2#.grpc.CgroupStats.HugetlbStatsEntryR\x0chugetlbStats\
    \x1aS\n\x11HugetlbStatsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.grpc.HugetlbStatsR\x05value:\
    \x028\x01\"\x8e\x02\n\x0cNetworkStats\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x19\n\x08rx_bytes\x18\x02\x20\x01(\x04R\x07rxBytes\x12\
    \x1d\n\nrx_packets\x18\x03\x20\x01(\x04R\trxPackets\x12\x1b\n\trx_errors\
    \x18\x04\x20\x01(\x04R\x08rxErrors\x12\x1d\n\nrx_dropped\x18\x05\x20\x01\
    (\x04R\trxDropped\x12\x19\n\x08tx_bytes\x18\x06\x20\x01(\x04R\x07txBytes\
    \x12\x1d\n\ntx_packets\x18\x07\x20\x01(\x04R\ttxPackets\x12\x1b\n\ttx_er\
    rors\x18\x08\x20\x01(\x04R\x08txErrors\x12\x1d\n\ntx_dropped\x18\t\x20\
    \x01(\x04R\ttxDropped\"\x87\x01\n\x16StatsContainerResponse\x124\n\x0ccg\
    roup_stats\x18\x01\x20\x01(\x0b2\x11.grpc.CgroupStatsR\x0bcgroupStats\
    \x127\n\rnetwork_stats\x18\x02\x20\x03(\x0b2\x12.grpc.NetworkStatsR\x0cn\
    etworkStats\"d\n\x12WriteStreamRequest\x12!\n\x0ccontainer_id\x18\x01\
    \x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06\
    execId\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"'\n\x13WriteStre\
    amResponse\x12\x10\n\x03len\x18\x01\x20\x01(\rR\x03len\"a\n\x11ReadStrea\
    mRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\
    \x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\x12\x10\n\x03len\x18\x03\
    \x20\x01(\rR\x03len\"(\n\x12ReadStreamResponse\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\"O\n\x11CloseStdinRequest\x12!\n\x0ccontainer_id\
    \x18\x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01\
    (\tR\x06execId\"{\n\x13TtyWinResizeRequest\x12!\n\x0ccontainer_id\x18\
    \x01\x20\x01(\tR\x0bcontainerId\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\
    \x06execId\x12\x10\n\x03row\x18\x03\x20\x01(\rR\x03row\x12\x16\n\x06colu\
    mn\x18\x04\x20\x01(\rR\x06column\"\xdb\x01\n\x14CreateSandboxRequest\x12\
    \x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12\x10\n\x03dns\x18\
    \x02\x20\x03(\tR\x03dns\x12)\n\x08storages\x18\x03\x20\x03(\x0b2\r.grpc.\
    StorageR\x08storages\x12#\n\rsandbox_pidns\x18\x04\x20\x01(\x08R\x0csand\
    boxPidns\x12\x1d\n\nsandbox_id\x18\x05\x20\x01(\tR\tsandboxId\x12&\n\x0f\
    guest_hook_path\x18\x06\x20\x01(\tR\rguestHookPath\"\x17\n\x15DestroySan\
    dboxRequest\">\n\nInterfaces\x120\n\nInterfaces\x18\x01\x20\x03(\x0b2\
    \x10.types.InterfaceR\nInterfaces\".\n\x06Routes\x12$\n\x06Routes\x18\
    \x01\x20\x03(\x0b2\x0c.types.RouteR\x06Routes\"H\n\x16UpdateInterfaceReq\
    uest\x12.\n\tinterface\x18\x01\x20\x01(\x0b2\x10.types.InterfaceR\tinter\
    face\";\n\x13UpdateRoutesRequest\x12$\n\x06routes\x18\x01\x20\x01(\x0b2\
    \x0c.grpc.RoutesR\x06routes\"\x17\n\x15ListInterfacesRequest\"\x13\n\x11\
    ListRoutesRequest\"]\n\x13OnlineCPUMemRequest\x12\x12\n\x04wait\x18\x01\
    \x20\x01(\x08R\x04wait\x12\x17\n\x07nb_cpus\x18\x02\x20\x01(\rR\x06nbCpu\
    s\x12\x19\n\x08cpu_only\x18\x03\x20\x01(\x08R\x07cpuOnly\",\n\x16ReseedR\
    andomDevRequest\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"\xc8\
    \x01\n\x0cAgentDetails\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07versi\
    on\x12\x1f\n\x0binit_daemon\x18\x02\x20\x01(\x08R\ninitDaemon\x12'\n\x0f\
    device_handlers\x18\x03\x20\x03(\tR\x0edeviceHandlers\x12)\n\x10storage_\
    handlers\x18\x04\x20\x03(\tR\x0fstorageHandlers\x12)\n\x10supports_secco\
    mp\x18\x05\x20\x01(\x08R\x0fsupportsSeccomp\"g\n\x13GuestDetailsRequest\
    \x12$\n\x0emem_block_size\x18\x01\x20\x01(\x08R\x0cmemBlockSize\x12*\n\
    \x11mem_hotplug_probe\x18\x02\x20\x01(\x08R\x0fmemHotplugProbe\"\xbb\x01\
    \n\x14GuestDetailsResponse\x12/\n\x14mem_block_size_bytes\x18\x01\x20\
    \x01(\x04R\x11memBlockSizeBytes\x127\n\ragent_details\x18\x02\x20\x01(\
    \x0b2\x12.grpc.AgentDetailsR\x0cagentDetails\x129\n\x19support_mem_hotpl\
    ug_probe\x18\x03\x20\x01(\x08R\x16supportMemHotplugProbe\"L\n\x18MemHotp\
    lugByProbeRequest\x120\n\x13memHotplugProbeAddr\x18\x01\x20\x03(\x04R\
    \x13memHotplugProbeAddr\"?\n\x17SetGuestDateTimeRequest\x12\x10\n\x03Sec\
    \x18\x01\x20\x01(\x03R\x03Sec\x12\x12\n\x04Usec\x18\x02\x20\x01(\x03R\
    \x04Usec\"\xb3\x01\n\x07Storage\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\
    \x06driver\x12%\n\x0edriver_options\x18\x02\x20\x03(\tR\rdriverOptions\
    \x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06source\x12\x16\n\x06fstype\
    \x18\x04\x20\x01(\tR\x06fstype\x12\x18\n\x07options\x18\x05\x20\x03(\tR\
    \x07options\x12\x1f\n\x0bmount_point\x18\x06\x20\x01(\tR\nmountPoint\"\
    \x86\x01\n\x06Device\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\
    \x04type\x18\x02\x20\x01(\tR\x04type\x12\x17\n\x07vm_path\x18\x03\x20\
    \x01(\tR\x06vmPath\x12%\n\x0econtainer_path\x18\x04\x20\x01(\tR\rcontain\
    erPath\x12\x18\n\x07options\x18\x05\x20\x03(\tR\x07options\"X\n\nStringU\
    ser\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\x12\x10\n\x03gid\x18\x02\
    \x20\x01(\tR\x03gid\x12&\n\x0eadditionalGids\x18\x03\x20\x03(\tR\x0eaddi\
    tionalGids\"\xca\x01\n\x0fCopyFileRequest\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12\x1b\n\tfile_size\x18\x02\x20\x01(\x03R\x08fileSize\
    \x12\x1b\n\tfile_mode\x18\x03\x20\x01(\rR\x08fileMode\x12\x19\n\x08dir_m\
    ode\x18\x04\x20\x01(\rR\x07dirMode\x12\x10\n\x03uid\x18\x05\x20\x01(\x05\
    R\x03uid\x12\x10\n\x03gid\x18\x06\x20\x01(\x05R\x03gid\x12\x16\n\x06offs\
    et\x18\x07\x20\x01(\x03R\x06offset\x12\x12\n\x04data\x18\x08\x20\x01(\
    \x0cR\x04data\"\x15\n\x13StartTracingRequest\"\x14\n\x12StopTracingReque\
    st2\x93\x10\n\x0cAgentService\x12G\n\x0fCreateContainer\x12\x1c.grpc.Cre\
    ateContainerRequest\x1a\x16.google.protobuf.Empty\x12E\n\x0eStartContain\
    er\x12\x1b.grpc.StartContainerRequest\x1a\x16.google.protobuf.Empty\x12G\
    \n\x0fRemoveContainer\x12\x1c.grpc.RemoveContainerRequest\x1a\x16.google\
    .protobuf.Empty\x12?\n\x0bExecProcess\x12\x18.grpc.ExecProcessRequest\
    \x1a\x16.google.protobuf.Empty\x12C\n\rSignalProcess\x12\x1a.grpc.Signal\
    ProcessRequest\x1a\x16.google.protobuf.Empty\x12B\n\x0bWaitProcess\x12\
    \x18.grpc.WaitProcessRequest\x1a\x19.grpc.WaitProcessResponse\x12H\n\rLi\
    stProcesses\x12\x1a.grpc.ListProcessesRequest\x1a\x1b.grpc.ListProcesses\
    Response\x12G\n\x0fUpdateContainer\x12\x1c.grpc.UpdateContainerRequest\
    \x1a\x16.google.protobuf.Empty\x12K\n\x0eStatsContainer\x12\x1b.grpc.Sta\
    tsContainerRequest\x1a\x1c.grpc.StatsContainerResponse\x12E\n\x0ePauseCo\
    ntainer\x12\x1b.grpc.PauseContainerRequest\x1a\x16.google.protobuf.Empty\
    \x12G\n\x0fResumeContainer\x12\x1c.grpc.ResumeContainerRequest\x1a\x16.g\
    oogle.protobuf.Empty\x12A\n\nWriteStdin\x12\x18.grpc.WriteStreamRequest\
    \x1a\x19.grpc.WriteStreamResponse\x12?\n\nReadStdout\x12\x17.grpc.ReadSt\
    reamRequest\x1a\x18.grpc.ReadStreamResponse\x12?\n\nReadStderr\x12\x17.g\
    rpc.ReadStreamRequest\x1a\x18.grpc.ReadStreamResponse\x12=\n\nCloseStdin\
    \x12\x17.grpc.CloseStdinRequest\x1a\x16.google.protobuf.Empty\x12A\n\x0c\
    TtyWinResize\x12\x19.grpc.TtyWinResizeRequest\x1a\x16.google.protobuf.Em\
    pty\x12A\n\x0fUpdateInterface\x12\x1c.grpc.UpdateInterfaceRequest\x1a\
    \x10.types.Interface\x127\n\x0cUpdateRoutes\x12\x19.grpc.UpdateRoutesReq\
    uest\x1a\x0c.grpc.Routes\x12?\n\x0eListInterfaces\x12\x1b.grpc.ListInter\
    facesRequest\x1a\x10.grpc.Interfaces\x123\n\nListRoutes\x12\x17.grpc.Lis\
    tRoutesRequest\x1a\x0c.grpc.Routes\x12A\n\x0cStartTracing\x12\x19.grpc.S\
    tartTracingRequest\x1a\x16.google.protobuf.Empty\x12?\n\x0bStopTracing\
    \x12\x18.grpc.StopTracingRequest\x1a\x16.google.protobuf.Empty\x12C\n\rC\
    reateSandbox\x12\x1a.grpc.CreateSandboxRequest\x1a\x16.google.protobuf.E\
    mpty\x12E\n\x0eDestroySandbox\x12\x1b.grpc.DestroySandboxRequest\x1a\x16\
    .google.protobuf.Empty\x12A\n\x0cOnlineCPUMem\x12\x19.grpc.OnlineCPUMemR\
    equest\x1a\x16.google.protobuf.Empty\x12G\n\x0fReseedRandomDev\x12\x1c.g\
    rpc.ReseedRandomDevRequest\x1a\x16.google.protobuf.Empty\x12H\n\x0fGetGu\
    estDetails\x12\x19.grpc.GuestDetailsRequest\x1a\x1a.grpc.GuestDetailsRes\
    ponse\x12K\n\x11MemHotplugByProbe\x12\x1e.grpc.MemHotplugByProbeRequest\
    \x1a\x16.google.protobuf.Empty\x12I\n\x10SetGuestDateTime\x12\x1d.grpc.S\
    etGuestDateTimeRequest\x1a\x16.google.protobuf.Empty\x129\n\x08CopyFile\
    \x12\x15.grpc.CopyFileRequest\x1a\x16.google.protobuf.EmptyJ\xe1\xa4\x01\
    \n\x07\x12\x05\x06\0\xe5\x03\x01\nO\n\x01\x0c\x12\x03\x06\0\x122E\n\x20C\
    opyright\x202017\x20HyperHQ\x20Inc.\n\n\x20SPDX-License-Identifier:\x20A\
    pache-2.0\n\n\n\x08\n\x01\x02\x12\x03\x08\0\r\n\t\n\x02\x03\0\x12\x03\n\
    \0\x13\n\t\n\x02\x03\x01\x12\x03\x0b\0@\n\t\n\x02\x03\x02\x12\x03\x0c\0%\
    \n\x16\n\x02\x06\0\x12\x04\x0f\0>\x01\x1a\n\x20unstable\n\n\n\n\x03\x06\
    \0\x01\x12\x03\x0f\x08\x14\n\x18\n\x04\x06\0\x02\0\x12\x03\x11\x08T\x1a\
    \x0b\x20execution\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x11\x0c\x1b\n\
    \x0c\n\x05\x06\0\x02\0\x02\x12\x03\x11\x1c2\n\x0c\n\x05\x06\0\x02\0\x03\
    \x12\x03\x11=R\n\x0b\n\x04\x06\0\x02\x01\x12\x03\x12\x08R\n\x0c\n\x05\
    \x06\0\x02\x01\x01\x12\x03\x12\x0c\x1a\n\x0c\n\x05\x06\0\x02\x01\x02\x12\
    \x03\x12\x1b0\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x12;P\n\x9c\x03\n\
    \x04\x06\0\x02\x02\x12\x03\x1a\x08T\x1a\x8e\x03\x20RemoveContainer\x20wi\
    ll\x20tear\x20down\x20an\x20existing\x20container\x20by\x20forcibly\x20t\
    erminating\n\x20all\x20processes\x20running\x20inside\x20that\x20contain\
    er\x20and\x20releasing\x20all\x20internal\n\x20resources\x20associated\
    \x20with\x20it.\n\x20RemoveContainer\x20will\x20wait\x20for\x20all\x20pr\
    ocesses\x20termination\x20before\x20returning.\n\x20If\x20any\x20process\
    \x20can\x20not\x20be\x20killed\x20or\x20if\x20it\x20can\x20not\x20be\x20\
    killed\x20after\n\x20the\x20RemoveContainerRequest\x20timeout,\x20Remove\
    Container\x20will\x20return\x20an\x20error.\n\n\x0c\n\x05\x06\0\x02\x02\
    \x01\x12\x03\x1a\x0c\x1b\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1a\x1c2\
    \n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1a=R\n\x0b\n\x04\x06\0\x02\x03\
    \x12\x03\x1b\x08L\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x1b\x0c\x17\n\
    \x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x1b\x18*\n\x0c\n\x05\x06\0\x02\x03\
    \x03\x12\x03\x1b5J\n\x0b\n\x04\x06\0\x02\x04\x12\x03\x1c\x08P\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03\x1c\x0c\x19\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03\x1c\x1a.\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\x1c9N\n*\n\x04\
    \x06\0\x02\x05\x12\x03\x1d\x08J\"\x1d\x20wait\x20&\x20reap\x20like\x20wa\
    itpid(2)\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x1d\x0c\x17\n\x0c\n\x05\
    \x06\0\x02\x05\x02\x12\x03\x1d\x18*\n\x0c\n\x05\x06\0\x02\x05\x03\x12\
    \x03\x1d5H\n\x0b\n\x04\x06\0\x02\x06\x12\x03\x1e\x08P\n\x0c\n\x05\x06\0\
    \x02\x06\x01\x12\x03\x1e\x0c\x19\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\
    \x1e\x1a.\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x1e9N\n\x0b\n\x04\x06\0\
    \x02\x07\x12\x03\x1f\x08T\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\x1f\x0c\
    \x1b\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\x1f\x1c2\n\x0c\n\x05\x06\0\
    \x02\x07\x03\x12\x03\x1f=R\n\x0b\n\x04\x06\0\x02\x08\x12\x03\x20\x08S\n\
    \x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x20\x0c\x1a\n\x0c\n\x05\x06\0\x02\
    \x08\x02\x12\x03\x20\x1b0\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\x20;Q\n\
    \x0b\n\x04\x06\0\x02\t\x12\x03!\x08R\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03\
    !\x0c\x1a\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03!\x1b0\n\x0c\n\x05\x06\0\
    \x02\t\x03\x12\x03!;P\n\x0b\n\x04\x06\0\x02\n\x12\x03\"\x08T\n\x0c\n\x05\
    \x06\0\x02\n\x01\x12\x03\"\x0c\x1b\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03\"\
    \x1c2\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03\"=R\n\x14\n\x04\x06\0\x02\x0b\
    \x12\x03%\x08I\x1a\x07\x20stdio\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03%\
    \x0c\x16\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03%\x17)\n\x0c\n\x05\x06\0\
    \x02\x0b\x03\x12\x03%4G\n\x0b\n\x04\x06\0\x02\x0c\x12\x03&\x08G\n\x0c\n\
    \x05\x06\0\x02\x0c\x01\x12\x03&\x0c\x16\n\x0c\n\x05\x06\0\x02\x0c\x02\
    \x12\x03&\x17(\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03&3E\n\x0b\n\x04\x06\
    \0\x02\r\x12\x03'\x08G\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03'\x0c\x16\n\
    \x0c\n\x05\x06\0\x02\r\x02\x12\x03'\x17(\n\x0c\n\x05\x06\0\x02\r\x03\x12\
    \x03'3E\n\x0b\n\x04\x06\0\x02\x0e\x12\x03(\x08J\n\x0c\n\x05\x06\0\x02\
    \x0e\x01\x12\x03(\x0c\x16\n\x0c\n\x05\x06\0\x02\x0e\x02\x12\x03(\x17(\n\
    \x0c\n\x05\x06\0\x02\x0e\x03\x12\x03(3H\n\x0b\n\x04\x06\0\x02\x0f\x12\
    \x03)\x08N\n\x0c\n\x05\x06\0\x02\x0f\x01\x12\x03)\x0c\x18\n\x0c\n\x05\
    \x06\0\x02\x0f\x02\x12\x03)\x19,\n\x0c\n\x05\x06\0\x02\x0f\x03\x12\x03)7\
    L\n\x19\n\x04\x06\0\x02\x10\x12\x03,\x08N\x1a\x0c\x20networking\n\n\x0c\
    \n\x05\x06\0\x02\x10\x01\x12\x03,\x0c\x1b\n\x0c\n\x05\x06\0\x02\x10\x02\
    \x12\x03,\x1c2\n\x0c\n\x05\x06\0\x02\x10\x03\x12\x03,=L\n\x0b\n\x04\x06\
    \0\x02\x11\x12\x03-\x08?\n\x0c\n\x05\x06\0\x02\x11\x01\x12\x03-\x0c\x18\
    \n\x0c\n\x05\x06\0\x02\x11\x02\x12\x03-\x19,\n\x0c\n\x05\x06\0\x02\x11\
    \x03\x12\x03-7=\n\x0b\n\x04\x06\0\x02\x12\x12\x03.\x08F\n\x0c\n\x05\x06\
    \0\x02\x12\x01\x12\x03.\x0c\x1a\n\x0c\n\x05\x06\0\x02\x12\x02\x12\x03.\
    \x1b0\n\x0c\n\x05\x06\0\x02\x12\x03\x12\x03.:D\n\x0b\n\x04\x06\0\x02\x13\
    \x12\x03/\x08;\n\x0c\n\x05\x06\0\x02\x13\x01\x12\x03/\x0c\x16\n\x0c\n\
    \x05\x06\0\x02\x13\x02\x12\x03/\x17(\n\x0c\n\x05\x06\0\x02\x13\x03\x12\
    \x03/39\n\x16\n\x04\x06\0\x02\x14\x12\x032\x08N\x1a\t\x20tracing\n\n\x0c\
    \n\x05\x06\0\x02\x14\x01\x12\x032\x0c\x18\n\x0c\n\x05\x06\0\x02\x14\x02\
    \x12\x032\x19,\n\x0c\n\x05\x06\0\x02\x14\x03\x12\x0327L\n\x0b\n\x04\x06\
    \0\x02\x15\x12\x033\x08L\n\x0c\n\x05\x06\0\x02\x15\x01\x12\x033\x0c\x17\
    \n\x0c\n\x05\x06\0\x02\x15\x02\x12\x033\x18*\n\x0c\n\x05\x06\0\x02\x15\
    \x03\x12\x0335J\nH\n\x04\x06\0\x02\x16\x12\x036\x08P\x1a;\x20misc\x20(TO\
    DO:\x20some\x20rpcs\x20can\x20be\x20replaced\x20by\x20hyperstart-exec)\n\
    \n\x0c\n\x05\x06\0\x02\x16\x01\x12\x036\x0c\x19\n\x0c\n\x05\x06\0\x02\
    \x16\x02\x12\x036\x1a.\n\x0c\n\x05\x06\0\x02\x16\x03\x12\x0369N\n\x0b\n\
    \x04\x06\0\x02\x17\x12\x037\x08R\n\x0c\n\x05\x06\0\x02\x17\x01\x12\x037\
    \x0c\x1a\n\x0c\n\x05\x06\0\x02\x17\x02\x12\x037\x1b0\n\x0c\n\x05\x06\0\
    \x02\x17\x03\x12\x037;P\n\x0b\n\x04\x06\0\x02\x18\x12\x038\x08N\n\x0c\n\
    \x05\x06\0\x02\x18\x01\x12\x038\x0c\x18\n\x0c\n\x05\x06\0\x02\x18\x02\
    \x12\x038\x19,\n\x0c\n\x05\x06\0\x02\x18\x03\x12\x0387L\n\x0b\n\x04\x06\
    \0\x02\x19\x12\x039\x08T\n\x0c\n\x05\x06\0\x02\x19\x01\x12\x039\x0c\x1b\
    \n\x0c\n\x05\x06\0\x02\x19\x02\x12\x039\x1c2\n\x0c\n\x05\x06\0\x02\x19\
    \x03\x12\x039=R\n\x0b\n\x04\x06\0\x02\x1a\x12\x03:\x08P\n\x0c\n\x05\x06\
    \0\x02\x1a\x01\x12\x03:\x0c\x1b\n\x0c\n\x05\x06\0\x02\x1a\x02\x12\x03:\
    \x1c/\n\x0c\n\x05\x06\0\x02\x1a\x03\x12\x03::N\n\x0b\n\x04\x06\0\x02\x1b\
    \x12\x03;\x08X\n\x0c\n\x05\x06\0\x02\x1b\x01\x12\x03;\x0c\x1d\n\x0c\n\
    \x05\x06\0\x02\x1b\x02\x12\x03;\x1e6\n\x0c\n\x05\x06\0\x02\x1b\x03\x12\
    \x03;AV\n\x0b\n\x04\x06\0\x02\x1c\x12\x03<\x08V\n\x0c\n\x05\x06\0\x02\
    \x1c\x01\x12\x03<\x0c\x1c\n\x0c\n\x05\x06\0\x02\x1c\x02\x12\x03<\x1d4\n\
    \x0c\n\x05\x06\0\x02\x1c\x03\x12\x03<?T\n\x0b\n\x04\x06\0\x02\x1d\x12\
    \x03=\x08F\n\x0c\n\x05\x06\0\x02\x1d\x01\x12\x03=\x0c\x14\n\x0c\n\x05\
    \x06\0\x02\x1d\x02\x12\x03=\x15$\n\x0c\n\x05\x06\0\x02\x1d\x03\x12\x03=/\
    D\n\n\n\x02\x04\0\x12\x04@\0N\x01\n\n\n\x03\x04\0\x01\x12\x03@\x08\x1e\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03A\x08\x20\n\r\n\x05\x04\0\x02\0\x04\x12\
    \x04A\x08@\x20\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03A\x08\x0e\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03A\x0f\x1b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03A\
    \x1e\x1f\n\x0b\n\x04\x04\0\x02\x01\x12\x03B\x08\x1b\n\r\n\x05\x04\0\x02\
    \x01\x04\x12\x04B\x08A\x20\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03B\x08\
    \x0e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03B\x0f\x16\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03B\x19\x1a\n\x0b\n\x04\x04\0\x02\x02\x12\x03C\x08#\n\
    \r\n\x05\x04\0\x02\x02\x04\x12\x04C\x08B\x1b\n\x0c\n\x05\x04\0\x02\x02\
    \x06\x12\x03C\x08\x12\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03C\x13\x1e\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03C!\"\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03D\x08$\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03D\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03D\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03D\x18\x1f\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03D\"#\n\x0b\n\x04\x04\
    \0\x02\x04\x12\x03E\x08&\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03E\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03E\x11\x18\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x03E\x19!\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03E$%\n\x0b\n\
    \x04\x04\0\x02\x05\x12\x03F\x08\x15\n\r\n\x05\x04\0\x02\x05\x04\x12\x04F\
    \x08E&\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03F\x08\x0c\n\x0c\n\x05\x04\0\
    \x02\x05\x01\x12\x03F\r\x10\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03F\x13\
    \x14\n\xba\x02\n\x04\x04\0\x02\x06\x12\x03M\x08\x1f\x1a\xac\x02\x20This\
    \x20field\x20is\x20used\x20to\x20indicate\x20if\x20the\x20container\x20n\
    eeds\x20to\x20join\n\x20sandbox\x20shared\x20pid\x20ns\x20or\x20create\
    \x20a\x20new\x20namespace.\x20This\x20field\x20is\n\x20meant\x20to\x20ov\
    erride\x20the\x20NEWPID\x20config\x20settings\x20in\x20the\x20OCI\x20spe\
    c.\n\x20The\x20agent\x20would\x20receive\x20an\x20OCI\x20spec\x20with\
    \x20PID\x20namespace\x20cleared\n\x20out\x20altogether\x20and\x20not\x20\
    just\x20the\x20pid\x20ns\x20path.\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x04M\
    \x08F\x15\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03M\x08\x0c\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03M\r\x1a\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03M\x1d\
    \x1e\n\n\n\x02\x04\x01\x12\x04P\0R\x01\n\n\n\x03\x04\x01\x01\x12\x03P\
    \x08\x1d\n\x0b\n\x04\x04\x01\x02\0\x12\x03Q\x08\x20\n\r\n\x05\x04\x01\
    \x02\0\x04\x12\x04Q\x08P\x1f\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03Q\x08\
    \x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03Q\x0f\x1b\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03Q\x1e\x1f\n\n\n\x02\x04\x02\x12\x04T\0]\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03T\x08\x1e\n\x0b\n\x04\x04\x02\x02\0\x12\x03U\x08\x20\
    \n\r\n\x05\x04\x02\x02\0\x04\x12\x04U\x08T\x20\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03U\x08\x0e\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03U\x0f\x1b\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03U\x1e\x1f\n\xbc\x01\n\x04\x04\x02\
    \x02\x01\x12\x03\\\x08\x1b\x1a\xae\x01\x20RemoveContainer\x20will\x20ret\
    urn\x20an\x20error\x20if\n\x20it\x20could\x20not\x20kill\x20some\x20cont\
    ainer\x20processes\n\x20after\x20timeout\x20seconds.\n\x20Setting\x20tim\
    eout\x20to\x200\x20means\x20RemoveContainer\x20will\n\x20wait\x20for\x20\
    ever.\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\\\x08U\x20\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x03\\\x08\x0e\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03\\\x0f\x16\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\\\x19\x1a\n\n\n\
    \x02\x04\x03\x12\x04_\0d\x01\n\n\n\x03\x04\x03\x01\x12\x03_\x08\x1a\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03`\x08\x20\n\r\n\x05\x04\x03\x02\0\x04\
    \x12\x04`\x08_\x1c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03`\x08\x0e\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03`\x0f\x1b\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03`\x1e\x1f\n\x0b\n\x04\x04\x03\x02\x01\x12\x03a\x08\x1b\n\r\n\x05\
    \x04\x03\x02\x01\x04\x12\x04a\x08`\x20\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x03a\x08\x0e\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03a\x0f\x16\n\x0c\
    \n\x05\x04\x03\x02\x01\x03\x12\x03a\x19\x1a\n\x0b\n\x04\x04\x03\x02\x02\
    \x12\x03b\x08#\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04b\x08a\x1b\n\x0c\n\
    \x05\x04\x03\x02\x02\x06\x12\x03b\x08\x12\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03b\x13\x1e\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03b!\"\n\x0b\
    \n\x04\x04\x03\x02\x03\x12\x03c\x08\x1c\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04c\x08b#\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03c\x08\x0f\n\x0c\n\
    \x05\x04\x03\x02\x03\x01\x12\x03c\x10\x17\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x03c\x1a\x1b\n\n\n\x02\x04\x04\x12\x04f\0n\x01\n\n\n\x03\x04\
    \x04\x01\x12\x03f\x08\x1c\n\x0b\n\x04\x04\x04\x02\0\x12\x03g\x08\x20\n\r\
    \n\x05\x04\x04\x02\0\x04\x12\x04g\x08f\x1e\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03g\x08\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03g\x0f\x1b\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03g\x1e\x1f\n\xe8\x01\n\x04\x04\x04\x02\x01\
    \x12\x03l\x08\x1b\x1a\xda\x01\x20Special\x20case\x20for\x20SignalProcess\
    ():\x20exec_id\x20can\x20be\x20empty(\"\"),\n\x20which\x20means\x20to\
    \x20send\x20the\x20signal\x20to\x20all\x20the\x20processes\x20including\
    \x20their\x20descendants.\n\x20Other\x20APIs\x20with\x20exec_id\x20shoul\
    d\x20treat\x20empty\x20exec_id\x20as\x20an\x20invalid\x20request.\n\n\r\
    \n\x05\x04\x04\x02\x01\x04\x12\x04l\x08g\x20\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x03l\x08\x0e\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03l\x0f\x16\n\
    \x0c\n\x05\x04\x04\x02\x01\x03\x12\x03l\x19\x1a\n\x0b\n\x04\x04\x04\x02\
    \x02\x12\x03m\x08\x1a\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04m\x08l\x1b\n\
    \x0c\n\x05\x04\x04\x02\x02\x05\x12\x03m\x08\x0e\n\x0c\n\x05\x04\x04\x02\
    \x02\x01\x12\x03m\x0f\x15\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03m\x18\
    \x19\n\n\n\x02\x04\x05\x12\x04p\0s\x01\n\n\n\x03\x04\x05\x01\x12\x03p\
    \x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03q\x08\x20\n\r\n\x05\x04\x05\
    \x02\0\x04\x12\x04q\x08p\x1c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03q\x08\
    \x0e\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03q\x0f\x1b\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03q\x1e\x1f\n\x0b\n\x04\x04\x05\x02\x01\x12\x03r\x08\x1b\
    \n\r\n\x05\x04\x05\x02\x01\x04\x12\x04r\x08q\x20\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03r\x08\x0e\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03r\x0f\
    \x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03r\x19\x1a\n\n\n\x02\x04\x06\
    \x12\x04u\0w\x01\n\n\n\x03\x04\x06\x01\x12\x03u\x08\x1b\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03v\x08\x19\n\r\n\x05\x04\x06\x02\0\x04\x12\x04v\x08u\
    \x1d\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03v\x08\r\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03v\x0e\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03v\x17\
    \x18\nk\n\x02\x04\x07\x12\x04z\0~\x01\x1a_\x20ListProcessesRequest\x20co\
    ntains\x20the\x20options\x20used\x20to\x20list\x20running\x20processes\
    \x20inside\x20the\x20container\n\n\n\n\x03\x04\x07\x01\x12\x03z\x08\x1c\
    \n\x0b\n\x04\x04\x07\x02\0\x12\x03{\x08\x20\n\r\n\x05\x04\x07\x02\0\x04\
    \x12\x04{\x08z\x1e\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03{\x08\x0e\n\x0c\
    \n\x05\x04\x07\x02\0\x01\x12\x03{\x0f\x1b\n\x0c\n\x05\x04\x07\x02\0\x03\
    \x12\x03{\x1e\x1f\n\x0b\n\x04\x04\x07\x02\x01\x12\x03|\x08\x1a\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04|\x08{\x20\n\x0c\n\x05\x04\x07\x02\x01\x05\
    \x12\x03|\x08\x0e\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03|\x0f\x15\n\x0c\
    \n\x05\x04\x07\x02\x01\x03\x12\x03|\x18\x19\n\x0b\n\x04\x04\x07\x02\x02\
    \x12\x03}\x08!\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03}\x08\x10\n\x0c\n\
    \x05\x04\x07\x02\x02\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x07\x02\x02\
    \x01\x12\x03}\x18\x1c\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03}\x1f\x20\n\
    c\n\x02\x04\x08\x12\x06\x81\x01\0\x83\x01\x01\x1aU\x20ListProcessesRespo\
    nse\x20represents\x20the\x20list\x20of\x20running\x20processes\x20inside\
    \x20the\x20container\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x81\x01\x08\x1d\n\
    \x0c\n\x04\x04\x08\x02\0\x12\x04\x82\x01\x08\x1f\n\x0f\n\x05\x04\x08\x02\
    \0\x04\x12\x06\x82\x01\x08\x81\x01\x1f\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\x82\x01\x08\r\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x82\x01\x0e\x1a\n\
    \r\n\x05\x04\x08\x02\0\x03\x12\x04\x82\x01\x1d\x1e\n\x0c\n\x02\x04\t\x12\
    \x06\x85\x01\0\x88\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x85\x01\x08\x1e\
    \n\x0c\n\x04\x04\t\x02\0\x12\x04\x86\x01\x08\x20\n\x0f\n\x05\x04\t\x02\0\
    \x04\x12\x06\x86\x01\x08\x85\x01\x20\n\r\n\x05\x04\t\x02\0\x05\x12\x04\
    \x86\x01\x08\x0e\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x86\x01\x0f\x1b\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\x86\x01\x1e\x1f\n\x0c\n\x04\x04\t\x02\x01\
    \x12\x04\x87\x01\x08%\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\x87\x01\x08\
    \x86\x01\x20\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\x87\x01\x08\x16\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\x87\x01\x17\x20\n\r\n\x05\x04\t\x02\x01\
    \x03\x12\x04\x87\x01#$\n\x0c\n\x02\x04\n\x12\x06\x8a\x01\0\x8c\x01\x01\n\
    \x0b\n\x03\x04\n\x01\x12\x04\x8a\x01\x08\x1d\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\x8b\x01\x04\x1c\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\x8b\x01\x04\x8a\
    \x01\x1f\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8b\x01\x04\n\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\x8b\x01\x0b\x17\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x8b\
    \x01\x1a\x1b\n\x0c\n\x02\x04\x0b\x12\x06\x8e\x01\0\x90\x01\x01\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\x8e\x01\x08\x1d\n\x0c\n\x04\x04\x0b\x02\0\x12\
    \x04\x8f\x01\x04\x1c\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\x8f\x01\x04\
    \x8e\x01\x1f\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x8f\x01\x04\n\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\x8f\x01\x0b\x17\n\r\n\x05\x04\x0b\x02\0\x03\
    \x12\x04\x8f\x01\x1a\x1b\n\x0c\n\x02\x04\x0c\x12\x06\x92\x01\0\x94\x01\
    \x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x92\x01\x08\x1e\n\x0c\n\x04\x04\x0c\
    \x02\0\x12\x04\x93\x01\x04\x1c\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\x93\
    \x01\x04\x92\x01\x20\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x93\x01\x04\n\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\x93\x01\x0b\x17\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\x93\x01\x1a\x1b\n\x0c\n\x02\x04\r\x12\x06\x96\x01\0\x9b\
    \x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x96\x01\x08\x10\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\x97\x01\x08\x1f\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x97\
    \x01\x08\x96\x01\x12\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x97\x01\x08\x0e\n\
    \r\n\x05\x04\r\x02\0\x01\x12\x04\x97\x01\x0f\x1a\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\x97\x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x98\x01\
    \x08)\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\
    \r\x02\x01\x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\
    \x04\x98\x01\x18$\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x98\x01'(\n\x0c\n\
    \x04\x04\r\x02\x02\x12\x04\x99\x01\x08'\n\x0f\n\x05\x04\r\x02\x02\x04\
    \x12\x06\x99\x01\x08\x98\x01)\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x99\
    \x01\x08\x0e\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\x99\x01\x0f\"\n\r\n\x05\
    \x04\r\x02\x02\x03\x12\x04\x99\x01%&\n\x0c\n\x04\x04\r\x02\x03\x12\x04\
    \x9a\x01\x08%\n\x0f\n\x05\x04\r\x02\x03\x04\x12\x06\x9a\x01\x08\x99\x01'\
    \n\r\n\x05\x04\r\x02\x03\x05\x12\x04\x9a\x01\x08\x0e\n\r\n\x05\x04\r\x02\
    \x03\x01\x12\x04\x9a\x01\x0f\x20\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x9a\
    \x01#$\n\x0c\n\x02\x04\x0e\x12\x06\x9d\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x9d\x01\x08\x16\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9e\
    \x01\x08\x1b\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\x9e\x01\x08\x9d\x01\
    \x18\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x9e\x01\x08\x0e\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\x9e\x01\x0f\x16\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\x9e\x01\x19\x1a\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9f\x01\x08%\n\
    \x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\x9f\x01\x08\x9e\x01\x1b\n\r\n\x05\
    \x04\x0e\x02\x01\x05\x12\x04\x9f\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\x01\
    \x01\x12\x04\x9f\x01\x0f\x20\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x9f\
    \x01#$\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa0\x01\x08\"\n\x0f\n\x05\x04\
    \x0e\x02\x02\x04\x12\x06\xa0\x01\x08\x9f\x01%\n\r\n\x05\x04\x0e\x02\x02\
    \x05\x12\x04\xa0\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa0\
    \x01\x0f\x1d\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa0\x01\x20!\n\x0c\n\
    \x02\x04\x0f\x12\x06\xa3\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xa3\x01\x08\x10\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xa4\x01\x08\x1f\n\
    \x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\xa4\x01\x08\xa3\x01\x12\n\r\n\x05\
    \x04\x0f\x02\0\x06\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xa4\x01\x11\x1a\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa4\x01\x1d\
    \x1e\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xa5\x01\x08+\n\x0f\n\x05\x04\
    \x0f\x02\x01\x04\x12\x06\xa5\x01\x08\xa4\x01\x1f\n\r\n\x05\x04\x0f\x02\
    \x01\x06\x12\x04\xa5\x01\x08\x16\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \xa5\x01\x17&\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa5\x01)*\n\x0c\n\
    \x02\x04\x10\x12\x06\xa8\x01\0\xab\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xa8\x01\x08\x11\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa9\x01\x08\x1b\n\
    \x0f\n\x05\x04\x10\x02\0\x04\x12\x06\xa9\x01\x08\xa8\x01\x13\n\r\n\x05\
    \x04\x10\x02\0\x05\x12\x04\xa9\x01\x08\x0e\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xa9\x01\x0f\x16\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa9\x01\x19\
    \x1a\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xaa\x01\x08\x19\n\x0f\n\x05\x04\
    \x10\x02\x01\x04\x12\x06\xaa\x01\x08\xa9\x01\x1b\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xaa\x01\x08\x0e\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xaa\x01\x0f\x14\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xaa\x01\x17\x18\n\
    \x0c\n\x02\x04\x11\x12\x06\xad\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xad\x01\x08\x12\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xae\x01\x08\
    \x19\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xae\x01\x08\xad\x01\x14\n\r\n\
    \x05\x04\x11\x02\0\x05\x12\x04\xae\x01\x08\x0e\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xae\x01\x0f\x14\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xae\x01\
    \x17\x18\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xaf\x01\x08\x1d\n\x0f\n\x05\
    \x04\x11\x02\x01\x04\x12\x06\xaf\x01\x08\xae\x01\x19\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xaf\x01\x08\x0e\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xaf\x01\x0f\x18\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xaf\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xb0\x01\x08\x1b\n\x0f\n\x05\x04\
    \x11\x02\x02\x04\x12\x06\xb0\x01\x08\xaf\x01\x1d\n\r\n\x05\x04\x11\x02\
    \x02\x05\x12\x04\xb0\x01\x08\x0e\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\
    \xb0\x01\x0f\x16\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xb0\x01\x19\x1a\n\
    \x0c\n\x04\x04\x11\x02\x03\x12\x04\xb1\x01\x08\x19\n\x0f\n\x05\x04\x11\
    \x02\x03\x04\x12\x06\xb1\x01\x08\xb0\x01\x1b\n\r\n\x05\x04\x11\x02\x03\
    \x05\x12\x04\xb1\x01\x08\x0e\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xb1\
    \x01\x0f\x14\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xb1\x01\x17\x18\n\x0c\
    \n\x02\x04\x12\x12\x06\xb4\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xb4\x01\x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xb5\x01\x08\x19\n\
    \x0f\n\x05\x04\x12\x02\0\x04\x12\x06\xb5\x01\x08\xb4\x01\x15\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\xb5\x01\x08\x0e\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xb5\x01\x0f\x14\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb5\x01\x17\
    \x18\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xb6\x01\x08\x1d\n\x0f\n\x05\x04\
    \x12\x02\x01\x04\x12\x06\xb6\x01\x08\xb5\x01\x19\n\r\n\x05\x04\x12\x02\
    \x01\x06\x12\x04\xb6\x01\x08\x12\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xb6\x01\x13\x18\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xb6\x01\x1b\x1c\n\
    \x0c\n\x04\x04\x12\x02\x02\x12\x04\xb7\x01\x08\"\n\x0f\n\x05\x04\x12\x02\
    \x02\x04\x12\x06\xb7\x01\x08\xb6\x01\x1d\n\r\n\x05\x04\x12\x02\x02\x06\
    \x12\x04\xb7\x01\x08\x12\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xb7\x01\
    \x13\x1d\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xb7\x01\x20!\n\x0c\n\x04\
    \x04\x12\x02\x03\x12\x04\xb8\x01\x08$\n\x0f\n\x05\x04\x12\x02\x03\x04\
    \x12\x06\xb8\x01\x08\xb7\x01\"\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xb8\
    \x01\x08\x12\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xb8\x01\x13\x1f\n\r\n\
    \x05\x04\x12\x02\x03\x03\x12\x04\xb8\x01\"#\n\x0c\n\x04\x04\x12\x02\x04\
    \x12\x04\xb9\x01\x08\x1f\n\x0f\n\x05\x04\x12\x02\x04\x04\x12\x06\xb9\x01\
    \x08\xb8\x01$\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xb9\x01\x08\x0c\n\r\
    \n\x05\x04\x12\x02\x04\x01\x12\x04\xb9\x01\r\x1a\n\r\n\x05\x04\x12\x02\
    \x04\x03\x12\x04\xb9\x01\x1d\x1e\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xba\
    \x01\x08&\n\x0f\n\x05\x04\x12\x02\x05\x04\x12\x06\xba\x01\x08\xb9\x01\
    \x1f\n\r\n\x05\x04\x12\x02\x05\x06\x12\x04\xba\x01\x08\x1b\n\r\n\x05\x04\
    \x12\x02\x05\x01\x12\x04\xba\x01\x1c!\n\r\n\x05\x04\x12\x02\x05\x03\x12\
    \x04\xba\x01$%\n\x0c\n\x02\x04\x13\x12\x06\xbe\x01\0\xc3\x01\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xbe\x01\x08\x17\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\xbf\x01\x08\x19\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xbf\x01\x08\
    \xbe\x01\x19\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xbf\x01\x08\x0e\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xbf\x01\x0f\x14\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xbf\x01\x17\x18\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xc0\x01\
    \x08\x19\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\xc0\x01\x08\xbf\x01\x19\
    \n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xc0\x01\x08\x0e\n\r\n\x05\x04\x13\
    \x02\x01\x01\x12\x04\xc0\x01\x0f\x14\n\r\n\x05\x04\x13\x02\x01\x03\x12\
    \x04\xc0\x01\x17\x18\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xc1\x01\x08\x16\
    \n\x0f\n\x05\x04\x13\x02\x02\x04\x12\x06\xc1\x01\x08\xc0\x01\x19\n\r\n\
    \x05\x04\x13\x02\x02\x05\x12\x04\xc1\x01\x08\x0e\n\r\n\x05\x04\x13\x02\
    \x02\x01\x12\x04\xc1\x01\x0f\x11\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\
    \xc1\x01\x14\x15\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xc2\x01\x08\x19\n\
    \x0f\n\x05\x04\x13\x02\x03\x04\x12\x06\xc2\x01\x08\xc1\x01\x16\n\r\n\x05\
    \x04\x13\x02\x03\x05\x12\x04\xc2\x01\x08\x0e\n\r\n\x05\x04\x13\x02\x03\
    \x01\x12\x04\xc2\x01\x0f\x14\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xc2\
    \x01\x17\x18\n\x0c\n\x02\x04\x14\x12\x06\xc5\x01\0\xce\x01\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xc5\x01\x08\x12\nH\n\x04\x04\x14\x02\0\x12\x04\
    \xc6\x01\x08@\":\x20number\x20of\x20bytes\x20transferred\x20to\x20and\
    \x20from\x20the\x20block\x20device\n\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\
    \xc6\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xc6\x01\x11\x20\n\r\
    \n\x05\x04\x14\x02\0\x01\x12\x04\xc6\x01!;\n\r\n\x05\x04\x14\x02\0\x03\
    \x12\x04\xc6\x01>?\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xc7\x01\x08;\n\r\
    \n\x05\x04\x14\x02\x01\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x14\x02\
    \x01\x06\x12\x04\xc7\x01\x11\x20\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\
    \xc7\x01!6\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xc7\x019:\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\xc8\x01\x089\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04\xc8\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xc8\x01\x11\
    \x20\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xc8\x01!4\n\r\n\x05\x04\x14\
    \x02\x02\x03\x12\x04\xc8\x0178\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xc9\
    \x01\x08?\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xc9\x01\x08\x10\n\r\n\
    \x05\x04\x14\x02\x03\x06\x12\x04\xc9\x01\x11\x20\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xc9\x01!:\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xc9\x01\
    =>\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xca\x01\x08<\n\r\n\x05\x04\x14\
    \x02\x04\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x14\x02\x04\x06\x12\
    \x04\xca\x01\x11\x20\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xca\x01!7\n\r\
    \n\x05\x04\x14\x02\x04\x03\x12\x04\xca\x01:;\n\x0c\n\x04\x04\x14\x02\x05\
    \x12\x04\xcb\x01\x089\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\xcb\x01\x08\
    \x10\n\r\n\x05\x04\x14\x02\x05\x06\x12\x04\xcb\x01\x11\x20\n\r\n\x05\x04\
    \x14\x02\x05\x01\x12\x04\xcb\x01!4\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\
    \xcb\x0178\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\xcc\x01\x087\n\r\n\x05\
    \x04\x14\x02\x06\x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x14\x02\x06\
    \x06\x12\x04\xcc\x01\x11\x20\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xcc\
    \x01!2\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xcc\x0156\n\x0c\n\x04\x04\
    \x14\x02\x07\x12\x04\xcd\x01\x087\n\r\n\x05\x04\x14\x02\x07\x04\x12\x04\
    \xcd\x01\x08\x10\n\r\n\x05\x04\x14\x02\x07\x06\x12\x04\xcd\x01\x11\x20\n\
    \r\n\x05\x04\x14\x02\x07\x01\x12\x04\xcd\x01!2\n\r\n\x05\x04\x14\x02\x07\
    \x03\x12\x04\xcd\x0156\n\x0c\n\x02\x04\x15\x12\x06\xd0\x01\0\xd4\x01\x01\
    \n\x0b\n\x03\x04\x15\x01\x12\x04\xd0\x01\x08\x14\n\x0c\n\x04\x04\x15\x02\
    \0\x12\x04\xd1\x01\x08\x19\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xd1\x01\
    \x08\xd0\x01\x16\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xd1\x01\x08\x0e\n\r\
    \n\x05\x04\x15\x02\0\x01\x12\x04\xd1\x01\x0f\x14\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\xd1\x01\x17\x18\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xd2\x01\
    \x08\x1d\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xd2\x01\x08\xd1\x01\x19\
    \n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xd2\x01\x08\x0e\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\xd2\x01\x0f\x18\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\xd2\x01\x1b\x1c\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xd3\x01\x08\x1b\
    \n\x0f\n\x05\x04\x15\x02\x02\x04\x12\x06\xd3\x01\x08\xd2\x01\x1d\n\r\n\
    \x05\x04\x15\x02\x02\x05\x12\x04\xd3\x01\x08\x0e\n\r\n\x05\x04\x15\x02\
    \x02\x01\x12\x04\xd3\x01\x0f\x16\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xd3\x01\x19\x1a\n\x0c\n\x02\x04\x16\x12\x06\xd6\x01\0\xdd\x01\x01\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\xd6\x01\x08\x13\n\x0c\n\x04\x04\x16\x02\0\x12\
    \x04\xd7\x01\x04\x1b\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\xd7\x01\x04\
    \xd6\x01\x15\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xd7\x01\x04\x0c\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xd7\x01\r\x16\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xd7\x01\x19\x1a\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xd8\x01\x04\
    \"\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\xd8\x01\x04\xd7\x01\x1b\n\r\n\
    \x05\x04\x16\x02\x01\x06\x12\x04\xd8\x01\x04\x0f\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\xd8\x01\x10\x1c\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\
    \xd8\x01\x20!\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xd9\x01\x04\x1d\n\x0f\
    \n\x05\x04\x16\x02\x02\x04\x12\x06\xd9\x01\x04\xd8\x01\"\n\r\n\x05\x04\
    \x16\x02\x02\x06\x12\x04\xd9\x01\x04\r\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xd9\x01\x0e\x18\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xd9\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\xda\x01\x04\x1f\n\x0f\n\x05\x04\
    \x16\x02\x03\x04\x12\x06\xda\x01\x04\xd9\x01\x1d\n\r\n\x05\x04\x16\x02\
    \x03\x06\x12\x04\xda\x01\x04\x0e\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\
    \xda\x01\x0f\x1a\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xda\x01\x1d\x1e\n\
    R\n\x04\x04\x16\x02\x04\x12\x04\xdb\x01\x040\"D\x20the\x20map\x20is\x20i\
    n\x20the\x20format\x20\"size\x20of\x20hugepage:\x20stats\x20of\x20the\
    \x20hugepage\"\n\n\x0f\n\x05\x04\x16\x02\x04\x04\x12\x06\xdb\x01\x04\xda\
    \x01\x1f\n\r\n\x05\x04\x16\x02\x04\x06\x12\x04\xdb\x01\x04\x1d\n\r\n\x05\
    \x04\x16\x02\x04\x01\x12\x04\xdb\x01\x1e+\n\r\n\x05\x04\x16\x02\x04\x03\
    \x12\x04\xdb\x01./\n\x0c\n\x02\x04\x17\x12\x06\xdf\x01\0\xe9\x01\x01\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\xdf\x01\x08\x14\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\xe0\x01\x08\x18\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\xe0\x01\
    \x08\xdf\x01\x16\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xe0\x01\x08\x0e\n\r\
    \n\x05\x04\x17\x02\0\x01\x12\x04\xe0\x01\x0f\x13\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xe0\x01\x16\x17\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xe1\x01\
    \x08\x1c\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xe1\x01\x08\xe0\x01\x18\
    \n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xe1\x01\x08\x0e\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xe1\x01\x0f\x17\n\r\n\x05\x04\x17\x02\x01\x03\x12\
    \x04\xe1\x01\x1a\x1b\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xe2\x01\x08\x1e\
    \n\x0f\n\x05\x04\x17\x02\x02\x04\x12\x06\xe2\x01\x08\xe1\x01\x1c\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\xe2\x01\x08\x0e\n\r\n\x05\x04\x17\x02\
    \x02\x01\x12\x04\xe2\x01\x0f\x19\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\
    \xe2\x01\x1c\x1d\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xe3\x01\x08\x1e\n\
    \x0f\n\x05\x04\x17\x02\x03\x04\x12\x06\xe3\x01\x08\xe2\x01\x1e\n\r\n\x05\
    \x04\x17\x02\x03\x05\x12\x04\xe3\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x03\
    \x01\x12\x04\xe3\x01\x0f\x18\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xe3\
    \x01\x1c\x1d\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\xe4\x01\x08\x1e\n\x0f\n\
    \x05\x04\x17\x02\x04\x04\x12\x06\xe4\x01\x08\xe3\x01\x1e\n\r\n\x05\x04\
    \x17\x02\x04\x05\x12\x04\xe4\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x04\x01\
    \x12\x04\xe4\x01\x0f\x19\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xe4\x01\
    \x1c\x1d\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xe5\x01\x08\x1c\n\x0f\n\x05\
    \x04\x17\x02\x05\x04\x12\x06\xe5\x01\x08\xe4\x01\x1e\n\r\n\x05\x04\x17\
    \x02\x05\x05\x12\x04\xe5\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x05\x01\x12\
    \x04\xe5\x01\x0f\x17\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xe5\x01\x1a\
    \x1b\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xe6\x01\x08\x1e\n\x0f\n\x05\x04\
    \x17\x02\x06\x04\x12\x06\xe6\x01\x08\xe5\x01\x1c\n\r\n\x05\x04\x17\x02\
    \x06\x05\x12\x04\xe6\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\
    \xe6\x01\x0f\x19\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xe6\x01\x1c\x1d\n\
    \x0c\n\x04\x04\x17\x02\x07\x12\x04\xe7\x01\x08\x1d\n\x0f\n\x05\x04\x17\
    \x02\x07\x04\x12\x06\xe7\x01\x08\xe6\x01\x1e\n\r\n\x05\x04\x17\x02\x07\
    \x05\x12\x04\xe7\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xe7\
    \x01\x0f\x18\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\xe7\x01\x1b\x1c\n\x0c\
    \n\x04\x04\x17\x02\x08\x12\x04\xe8\x01\x08\x1e\n\x0f\n\x05\x04\x17\x02\
    \x08\x04\x12\x06\xe8\x01\x08\xe7\x01\x1d\n\r\n\x05\x04\x17\x02\x08\x05\
    \x12\x04\xe8\x01\x08\x0e\n\r\n\x05\x04\x17\x02\x08\x01\x12\x04\xe8\x01\
    \x0f\x19\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\xe8\x01\x1c\x1d\n\x0c\n\
    \x02\x04\x18\x12\x06\xeb\x01\0\xee\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xeb\x01\x08\x1e\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xec\x01\x08%\n\
    \x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xec\x01\x08\xeb\x01\x20\n\r\n\x05\
    \x04\x18\x02\0\x06\x12\x04\xec\x01\x08\x13\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\xec\x01\x14\x20\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xec\x01#$\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\xed\x01\x080\n\r\n\x05\x04\x18\x02\
    \x01\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\
    \xed\x01\x11\x1d\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xed\x01\x1e+\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\xed\x01./\n\x0c\n\x02\x04\x19\x12\x06\
    \xf0\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xf0\x01\x08\x1a\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xf1\x01\x08\x20\n\x0f\n\x05\x04\x19\x02\
    \0\x04\x12\x06\xf1\x01\x08\xf0\x01\x1c\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xf1\x01\x08\x0e\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xf1\x01\x0f\x1b\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xf1\x01\x1e\x1f\n\x0c\n\x04\x04\x19\
    \x02\x01\x12\x04\xf2\x01\x08\x1b\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\
    \xf2\x01\x08\xf1\x01\x20\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xf2\x01\
    \x08\x0e\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xf2\x01\x0f\x16\n\r\n\x05\
    \x04\x19\x02\x01\x03\x12\x04\xf2\x01\x19\x1a\n\x0c\n\x04\x04\x19\x02\x02\
    \x12\x04\xf3\x01\x08\x17\n\x0f\n\x05\x04\x19\x02\x02\x04\x12\x06\xf3\x01\
    \x08\xf2\x01\x1b\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xf3\x01\x08\r\n\r\
    \n\x05\x04\x19\x02\x02\x01\x12\x04\xf3\x01\x0e\x12\n\r\n\x05\x04\x19\x02\
    \x02\x03\x12\x04\xf3\x01\x15\x16\n\x0c\n\x02\x04\x1a\x12\x06\xf6\x01\0\
    \xf8\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xf6\x01\x08\x1b\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\xf7\x01\x08\x17\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\
    \x06\xf7\x01\x08\xf6\x01\x1d\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xf7\x01\
    \x08\x0e\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xf7\x01\x0f\x12\n\r\n\x05\
    \x04\x1a\x02\0\x03\x12\x04\xf7\x01\x15\x16\n\x0c\n\x02\x04\x1b\x12\x06\
    \xfa\x01\0\xfe\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xfa\x01\x08\x19\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xfb\x01\x08\x20\n\x0f\n\x05\x04\x1b\x02\
    \0\x04\x12\x06\xfb\x01\x08\xfa\x01\x1b\n\r\n\x05\x04\x1b\x02\0\x05\x12\
    \x04\xfb\x01\x08\x0e\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xfb\x01\x0f\x1b\
    \n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xfb\x01\x1e\x1f\n\x0c\n\x04\x04\x1b\
    \x02\x01\x12\x04\xfc\x01\x08\x1b\n\x0f\n\x05\x04\x1b\x02\x01\x04\x12\x06\
    \xfc\x01\x08\xfb\x01\x20\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xfc\x01\
    \x08\x0e\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xfc\x01\x0f\x16\n\r\n\x05\
    \x04\x1b\x02\x01\x03\x12\x04\xfc\x01\x19\x1a\n\x0c\n\x04\x04\x1b\x02\x02\
    \x12\x04\xfd\x01\x08\x17\n\x0f\n\x05\x04\x1b\x02\x02\x04\x12\x06\xfd\x01\
    \x08\xfc\x01\x1b\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xfd\x01\x08\x0e\n\
    \r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xfd\x01\x0f\x12\n\r\n\x05\x04\x1b\
    \x02\x02\x03\x12\x04\xfd\x01\x15\x16\n\x0c\n\x02\x04\x1c\x12\x06\x80\x02\
    \0\x82\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x80\x02\x08\x1a\n\x0c\n\
    \x04\x04\x1c\x02\0\x12\x04\x81\x02\x08\x17\n\x0f\n\x05\x04\x1c\x02\0\x04\
    \x12\x06\x81\x02\x08\x80\x02\x1c\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x81\
    \x02\x08\r\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x81\x02\x0e\x12\n\r\n\x05\
    \x04\x1c\x02\0\x03\x12\x04\x81\x02\x15\x16\n\x0c\n\x02\x04\x1d\x12\x06\
    \x84\x02\0\x87\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x84\x02\x08\x19\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\x85\x02\x08\x20\n\x0f\n\x05\x04\x1d\x02\
    \0\x04\x12\x06\x85\x02\x08\x84\x02\x1b\n\r\n\x05\x04\x1d\x02\0\x05\x12\
    \x04\x85\x02\x08\x0e\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x85\x02\x0f\x1b\
    \n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\x85\x02\x1e\x1f\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\x86\x02\x08\x1b\n\x0f\n\x05\x04\x1d\x02\x01\x04\x12\x06\
    \x86\x02\x08\x85\x02\x20\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\x86\x02\
    \x08\x0e\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x86\x02\x0f\x16\n\r\n\x05\
    \x04\x1d\x02\x01\x03\x12\x04\x86\x02\x19\x1a\n\x0c\n\x02\x04\x1e\x12\x06\
    \x89\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\x89\x02\x08\x1b\n\
    \x0c\n\x04\x04\x1e\x02\0\x12\x04\x8a\x02\x08\x20\n\x0f\n\x05\x04\x1e\x02\
    \0\x04\x12\x06\x8a\x02\x08\x89\x02\x1d\n\r\n\x05\x04\x1e\x02\0\x05\x12\
    \x04\x8a\x02\x08\x0e\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x8a\x02\x0f\x1b\
    \n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x8a\x02\x1e\x1f\n\x0c\n\x04\x04\x1e\
    \x02\x01\x12\x04\x8b\x02\x08\x1b\n\x0f\n\x05\x04\x1e\x02\x01\x04\x12\x06\
    \x8b\x02\x08\x8a\x02\x20\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\x8b\x02\
    \x08\x0e\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x8b\x02\x0f\x16\n\r\n\x05\
    \x04\x1e\x02\x01\x03\x12\x04\x8b\x02\x19\x1a\n\x0c\n\x04\x04\x1e\x02\x02\
    \x12\x04\x8c\x02\x08\x17\n\x0f\n\x05\x04\x1e\x02\x02\x04\x12\x06\x8c\x02\
    \x08\x8b\x02\x1b\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\x8c\x02\x08\x0e\n\
    \r\n\x05\x04\x1e\x02\x02\x01\x12\x04\x8c\x02\x0f\x12\n\r\n\x05\x04\x1e\
    \x02\x02\x03\x12\x04\x8c\x02\x15\x16\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\
    \x8d\x02\x08\x1a\n\x0f\n\x05\x04\x1e\x02\x03\x04\x12\x06\x8d\x02\x08\x8c\
    \x02\x17\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\x8d\x02\x08\x0e\n\r\n\x05\
    \x04\x1e\x02\x03\x01\x12\x04\x8d\x02\x0f\x15\n\r\n\x05\x04\x1e\x02\x03\
    \x03\x12\x04\x8d\x02\x18\x19\n\x0c\n\x02\x04\x1f\x12\x06\x90\x02\0\xa1\
    \x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\x90\x02\x08\x1c\n\x0c\n\x04\x04\
    \x1f\x02\0\x12\x04\x91\x02\x08\x1c\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\
    \x91\x02\x08\x90\x02\x1e\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\x91\x02\x08\
    \x0e\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x91\x02\x0f\x17\n\r\n\x05\x04\
    \x1f\x02\0\x03\x12\x04\x91\x02\x1a\x1b\n\x0c\n\x04\x04\x1f\x02\x01\x12\
    \x04\x92\x02\x08\x20\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\x92\x02\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\x92\x02\x11\x17\n\r\n\x05\x04\
    \x1f\x02\x01\x01\x12\x04\x92\x02\x18\x1b\n\r\n\x05\x04\x1f\x02\x01\x03\
    \x12\x04\x92\x02\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\x93\x02\x08\
    &\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\
    \x1f\x02\x02\x06\x12\x04\x93\x02\x11\x18\n\r\n\x05\x04\x1f\x02\x02\x01\
    \x12\x04\x93\x02\x19!\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\x93\x02$%\n\
    \xea\x01\n\x04\x04\x1f\x02\x03\x12\x04\x99\x02\x08\x1f\x1a\xdb\x01\x20Th\
    is\x20field\x20means\x20that\x20a\x20pause\x20process\x20needs\x20to\x20\
    be\x20created\x20by\x20the\n\x20agent.\x20This\x20pid\x20namespace\x20of\
    \x20the\x20pause\x20process\x20will\x20be\x20treated\x20as\n\x20a\x20sha\
    red\x20pid\x20namespace.\x20All\x20containers\x20created\x20will\x20join\
    \x20this\x20shared\n\x20pid\x20namespace.\n\n\x0f\n\x05\x04\x1f\x02\x03\
    \x04\x12\x06\x99\x02\x08\x93\x02&\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\
    \x99\x02\x08\x0c\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x99\x02\r\x1a\n\r\
    \n\x05\x04\x1f\x02\x03\x03\x12\x04\x99\x02\x1d\x1e\n\xc5\x01\n\x04\x04\
    \x1f\x02\x04\x12\x04\x9d\x02\x08\x1e\x1a\xb6\x01\x20SandboxId\x20identif\
    ies\x20which\x20sandbox\x20is\x20using\x20the\x20agent.\x20We\x20allow\
    \x20only\n\x20one\x20sandbox\x20per\x20agent\x20and\x20implicitly\x20req\
    uire\x20that\x20CreateSandbox\x20is\n\x20called\x20before\x20other\x20sa\
    ndbox/network\x20calls.\n\n\x0f\n\x05\x04\x1f\x02\x04\x04\x12\x06\x9d\
    \x02\x08\x99\x02\x1f\n\r\n\x05\x04\x1f\x02\x04\x05\x12\x04\x9d\x02\x08\
    \x0e\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\x9d\x02\x0f\x19\n\r\n\x05\x04\
    \x1f\x02\x04\x03\x12\x04\x9d\x02\x1c\x1d\n\x98\x01\n\x04\x04\x1f\x02\x05\
    \x12\x04\xa0\x02\x08#\x1a\x89\x01\x20This\x20field,\x20if\x20non-empty,\
    \x20designates\x20an\x20absolute\x20path\x20to\x20a\x20directory\n\x20th\
    at\x20the\x20agent\x20will\x20search\x20for\x20OCI\x20hooks\x20to\x20run\
    \x20within\x20the\x20guest.\n\n\x0f\n\x05\x04\x1f\x02\x05\x04\x12\x06\
    \xa0\x02\x08\x9d\x02\x1e\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\xa0\x02\
    \x08\x0e\n\r\n\x05\x04\x1f\x02\x05\x01\x12\x04\xa0\x02\x0f\x1e\n\r\n\x05\
    \x04\x1f\x02\x05\x03\x12\x04\xa0\x02!\"\n\x0c\n\x02\x04\x20\x12\x06\xa3\
    \x02\0\xa4\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xa3\x02\x08\x1d\n\x0c\
    \n\x02\x04!\x12\x06\xa6\x02\0\xa8\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \xa6\x02\x08\x12\n\x0c\n\x04\x04!\x02\0\x12\x04\xa7\x02\x080\n\r\n\x05\
    \x04!\x02\0\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04!\x02\0\x06\x12\x04\
    \xa7\x02\x11\x20\n\r\n\x05\x04!\x02\0\x01\x12\x04\xa7\x02!+\n\r\n\x05\
    \x04!\x02\0\x03\x12\x04\xa7\x02./\n\x0c\n\x02\x04\"\x12\x06\xaa\x02\0\
    \xac\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xaa\x02\x08\x0e\n\x0c\n\x04\
    \x04\"\x02\0\x12\x04\xab\x02\x08(\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xab\
    \x02\x08\x10\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xab\x02\x11\x1c\n\r\n\x05\
    \x04\"\x02\0\x01\x12\x04\xab\x02\x1d#\n\r\n\x05\x04\"\x02\0\x03\x12\x04\
    \xab\x02&'\n\x0c\n\x02\x04#\x12\x06\xae\x02\0\xb0\x02\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\xae\x02\x08\x1e\n\x0c\n\x04\x04#\x02\0\x12\x04\xaf\x02\
    \x08&\n\x0f\n\x05\x04#\x02\0\x04\x12\x06\xaf\x02\x08\xae\x02\x20\n\r\n\
    \x05\x04#\x02\0\x06\x12\x04\xaf\x02\x08\x17\n\r\n\x05\x04#\x02\0\x01\x12\
    \x04\xaf\x02\x18!\n\r\n\x05\x04#\x02\0\x03\x12\x04\xaf\x02$%\n\x0c\n\x02\
    \x04$\x12\x06\xb2\x02\0\xb4\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xb2\x02\
    \x08\x1b\n\x0c\n\x04\x04$\x02\0\x12\x04\xb3\x02\x08\x1a\n\x0f\n\x05\x04$\
    \x02\0\x04\x12\x06\xb3\x02\x08\xb2\x02\x1d\n\r\n\x05\x04$\x02\0\x06\x12\
    \x04\xb3\x02\x08\x0e\n\r\n\x05\x04$\x02\0\x01\x12\x04\xb3\x02\x0f\x15\n\
    \r\n\x05\x04$\x02\0\x03\x12\x04\xb3\x02\x18\x19\n\x0c\n\x02\x04%\x12\x06\
    \xb6\x02\0\xb7\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\xb6\x02\x08\x1d\n\
    \x0c\n\x02\x04&\x12\x06\xb9\x02\0\xba\x02\x01\n\x0b\n\x03\x04&\x01\x12\
    \x04\xb9\x02\x08\x19\n\x0c\n\x02\x04'\x12\x06\xbc\x02\0\xc7\x02\x01\n\
    \x0b\n\x03\x04'\x01\x12\x04\xbc\x02\x08\x1b\n\xf6\x01\n\x04\x04'\x02\0\
    \x12\x04\xc0\x02\x08\x16\x1a\xe7\x01\x20Wait\x20specifies\x20if\x20the\
    \x20caller\x20waits\x20for\x20the\x20agent\x20to\x20online\x20all\x20res\
    ources.\n\x20If\x20true\x20the\x20agent\x20returns\x20once\x20all\x20res\
    ources\x20have\x20been\x20connected,\x20otherwise\x20all\n\x20resources\
    \x20are\x20connected\x20asynchronously\x20and\x20the\x20agent\x20returns\
    \x20immediately.\n\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\xc0\x02\x08\xbc\
    \x02\x1d\n\r\n\x05\x04'\x02\0\x05\x12\x04\xc0\x02\x08\x0c\n\r\n\x05\x04'\
    \x02\0\x01\x12\x04\xc0\x02\r\x11\n\r\n\x05\x04'\x02\0\x03\x12\x04\xc0\
    \x02\x14\x15\n`\n\x04\x04'\x02\x01\x12\x04\xc3\x02\x08\x1b\x1aR\x20NbCpu\
    s\x20specifies\x20the\x20number\x20of\x20CPUs\x20that\x20were\x20added\
    \x20and\x20the\x20agent\x20has\x20to\x20online.\n\n\x0f\n\x05\x04'\x02\
    \x01\x04\x12\x06\xc3\x02\x08\xc0\x02\x16\n\r\n\x05\x04'\x02\x01\x05\x12\
    \x04\xc3\x02\x08\x0e\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xc3\x02\x0f\x16\
    \n\r\n\x05\x04'\x02\x01\x03\x12\x04\xc3\x02\x19\x1a\nA\n\x04\x04'\x02\
    \x02\x12\x04\xc6\x02\x08\x1a\x1a3\x20CpuOnly\x20specifies\x20whether\x20\
    only\x20online\x20CPU\x20or\x20not.\n\n\x0f\n\x05\x04'\x02\x02\x04\x12\
    \x06\xc6\x02\x08\xc3\x02\x1b\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xc6\x02\
    \x08\x0c\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xc6\x02\r\x15\n\r\n\x05\x04'\
    \x02\x02\x03\x12\x04\xc6\x02\x18\x19\n\x0c\n\x02\x04(\x12\x06\xc9\x02\0\
    \xcc\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xc9\x02\x08\x1e\nM\n\x04\x04(\
    \x02\0\x12\x04\xcb\x02\x08\x17\x1a?\x20Data\x20specifies\x20the\x20rando\
    m\x20data\x20used\x20to\x20reseed\x20the\x20guest\x20crng.\n\n\x0f\n\x05\
    \x04(\x02\0\x04\x12\x06\xcb\x02\x08\xc9\x02\x20\n\r\n\x05\x04(\x02\0\x05\
    \x12\x04\xcb\x02\x08\r\n\r\n\x05\x04(\x02\0\x01\x12\x04\xcb\x02\x0e\x12\
    \n\r\n\x05\x04(\x02\0\x03\x12\x04\xcb\x02\x15\x16\nX\n\x02\x04)\x12\x06\
    \xcf\x02\0\xdf\x02\x01\x1aJ\x20AgentDetails\x20provides\x20information\
    \x20to\x20the\x20client\x20about\x20the\x20running\x20agent.\n\n\x0b\n\
    \x03\x04)\x01\x12\x04\xcf\x02\x08\x14\nC\n\x04\x04)\x02\0\x12\x04\xd1\
    \x02\x08\x1b\x1a5\x20Semantic\x20version\x20of\x20agent\x20(see\x20https\
    ://semver.org).\n\n\x0f\n\x05\x04)\x02\0\x04\x12\x06\xd1\x02\x08\xcf\x02\
    \x16\n\r\n\x05\x04)\x02\0\x05\x12\x04\xd1\x02\x08\x0e\n\r\n\x05\x04)\x02\
    \0\x01\x12\x04\xd1\x02\x0f\x16\n\r\n\x05\x04)\x02\0\x03\x12\x04\xd1\x02\
    \x19\x1a\n5\n\x04\x04)\x02\x01\x12\x04\xd4\x02\x08\x1d\x1a'\x20Set\x20if\
    \x20the\x20agent\x20is\x20running\x20as\x20PID\x201.\n\n\x0f\n\x05\x04)\
    \x02\x01\x04\x12\x06\xd4\x02\x08\xd1\x02\x1b\n\r\n\x05\x04)\x02\x01\x05\
    \x12\x04\xd4\x02\x08\x0c\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xd4\x02\r\
    \x18\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xd4\x02\x1b\x1c\n2\n\x04\x04)\
    \x02\x02\x12\x04\xd7\x02\x08,\x1a$\x20List\x20of\x20available\x20device\
    \x20handlers.\n\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xd7\x02\x08\x10\n\r\n\
    \x05\x04)\x02\x02\x05\x12\x04\xd7\x02\x11\x17\n\r\n\x05\x04)\x02\x02\x01\
    \x12\x04\xd7\x02\x18'\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xd7\x02*+\n3\n\
    \x04\x04)\x02\x03\x12\x04\xda\x02\x08-\x1a%\x20List\x20of\x20available\
    \x20storage\x20handlers.\n\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xda\x02\
    \x08\x10\n\r\n\x05\x04)\x02\x03\x05\x12\x04\xda\x02\x11\x17\n\r\n\x05\
    \x04)\x02\x03\x01\x12\x04\xda\x02\x18(\n\r\n\x05\x04)\x02\x03\x03\x12\
    \x04\xda\x02+,\np\n\x04\x04)\x02\x04\x12\x04\xde\x02\x08\"\x1ab\x20Set\
    \x20only\x20if\x20the\x20agent\x20is\x20built\x20with\x20seccomp\x20supp\
    ort\x20and\x20the\x20guest\n\x20environment\x20supports\x20seccomp.\n\n\
    \x0f\n\x05\x04)\x02\x04\x04\x12\x06\xde\x02\x08\xda\x02-\n\r\n\x05\x04)\
    \x02\x04\x05\x12\x04\xde\x02\x08\x0c\n\r\n\x05\x04)\x02\x04\x01\x12\x04\
    \xde\x02\r\x1d\n\r\n\x05\x04)\x02\x04\x03\x12\x04\xde\x02\x20!\n\x0c\n\
    \x02\x04*\x12\x06\xe1\x02\0\xeb\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xe1\
    \x02\x08\x1b\n\xd5\x01\n\x04\x04*\x02\0\x12\x04\xe5\x02\x08\x20\x1a\xc6\
    \x01\x20MemBlockSize\x20asks\x20server\x20to\x20return\x20the\x20system\
    \x20memory\x20block\x20size\x20that\x20can\x20be\x20used\n\x20for\x20mem\
    ory\x20hotplug\x20alignment.\x20Typically\x20the\x20server\x20returns\
    \x20what's\x20in\n\x20/sys/devices/system/memory/block_size_bytes.\n\n\
    \x0f\n\x05\x04*\x02\0\x04\x12\x06\xe5\x02\x08\xe1\x02\x1d\n\r\n\x05\x04*\
    \x02\0\x05\x12\x04\xe5\x02\x08\x0c\n\r\n\x05\x04*\x02\0\x01\x12\x04\xe5\
    \x02\r\x1b\n\r\n\x05\x04*\x02\0\x03\x12\x04\xe5\x02\x1e\x1f\n\xd1\x01\n\
    \x04\x04*\x02\x01\x12\x04\xea\x02\x08#\x1a\xc2\x01\x20MemoryHotplugProbe\
    \x20asks\x20server\x20to\x20return\x20whether\x20guest\x20kernel\x20supp\
    orts\x20memory\x20hotplug\n\x20via\x20probeinterface.\x20Typically\x20th\
    e\x20server\x20will\x20check\x20if\x20the\x20path\n\x20/sys/devices/syst\
    em/memory/probe\x20exists.\n\n\x0f\n\x05\x04*\x02\x01\x04\x12\x06\xea\
    \x02\x08\xe5\x02\x20\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xea\x02\x08\x0c\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xea\x02\r\x1e\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xea\x02!\"\n\x0c\n\x02\x04+\x12\x06\xed\x02\0\xf4\x02\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xed\x02\x08\x1c\nP\n\x04\x04+\x02\0\x12\x04\
    \xef\x02\x08(\x1aB\x20MemBlockSizeBytes\x20returns\x20the\x20system\x20m\
    emory\x20block\x20size\x20in\x20bytes.\n\n\x0f\n\x05\x04+\x02\0\x04\x12\
    \x06\xef\x02\x08\xed\x02\x1e\n\r\n\x05\x04+\x02\0\x05\x12\x04\xef\x02\
    \x08\x0e\n\r\n\x05\x04+\x02\0\x01\x12\x04\xef\x02\x0f#\n\r\n\x05\x04+\
    \x02\0\x03\x12\x04\xef\x02&'\n\x0c\n\x04\x04+\x02\x01\x12\x04\xf1\x02\
    \x08'\n\x0f\n\x05\x04+\x02\x01\x04\x12\x06\xf1\x02\x08\xef\x02(\n\r\n\
    \x05\x04+\x02\x01\x06\x12\x04\xf1\x02\x08\x14\n\r\n\x05\x04+\x02\x01\x01\
    \x12\x04\xf1\x02\x15\"\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xf1\x02%&\n\
    \x0c\n\x04\x04+\x02\x02\x12\x04\xf3\x02\x08+\n\x0f\n\x05\x04+\x02\x02\
    \x04\x12\x06\xf3\x02\x08\xf1\x02'\n\r\n\x05\x04+\x02\x02\x05\x12\x04\xf3\
    \x02\x08\x0c\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xf3\x02\r&\n\r\n\x05\x04\
    +\x02\x02\x03\x12\x04\xf3\x02)*\n\x0c\n\x02\x04,\x12\x06\xf6\x02\0\xfa\
    \x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xf6\x02\x08\x20\n\xb2\x01\n\x04\
    \x04,\x02\0\x12\x04\xf9\x02\x080\x1a\xa3\x01\x20server\x20needs\x20to\
    \x20send\x20the\x20value\x20of\x20memHotplugProbeAddr\x20into\x20file\
    \x20/sys/devices/system/memory/probe,\n\x20in\x20order\x20to\x20notify\
    \x20the\x20guest\x20kernel\x20about\x20hot-add\x20memory\x20event\n\n\r\
    \n\x05\x04,\x02\0\x04\x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\
    \x12\x04\xf9\x02\x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xf9\x02\x18+\n\
    \r\n\x05\x04,\x02\0\x03\x12\x04\xf9\x02./\n\x0c\n\x02\x04-\x12\x06\xfc\
    \x02\0\x81\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\xfc\x02\x08\x1f\n/\n\x04\
    \x04-\x02\0\x12\x04\xfe\x02\x08\x16\x1a!\x20Sec\x20the\x20second\x20sinc\
    e\x20the\x20Epoch.\n\n\x0f\n\x05\x04-\x02\0\x04\x12\x06\xfe\x02\x08\xfc\
    \x02!\n\r\n\x05\x04-\x02\0\x05\x12\x04\xfe\x02\x08\r\n\r\n\x05\x04-\x02\
    \0\x01\x12\x04\xfe\x02\x0e\x11\n\r\n\x05\x04-\x02\0\x03\x12\x04\xfe\x02\
    \x14\x15\nF\n\x04\x04-\x02\x01\x12\x04\x80\x03\x08\x17\x1a8\x20Usec\x20t\
    he\x20microseconds\x20portion\x20of\x20time\x20since\x20the\x20Epoch.\n\
    \n\x0f\n\x05\x04-\x02\x01\x04\x12\x06\x80\x03\x08\xfe\x02\x16\n\r\n\x05\
    \x04-\x02\x01\x05\x12\x04\x80\x03\x08\r\n\r\n\x05\x04-\x02\x01\x01\x12\
    \x04\x80\x03\x0e\x12\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x80\x03\x15\x16\
    \n\xa3\x01\n\x02\x04.\x12\x06\x85\x03\0\x9f\x03\x01\x1a\x94\x01\x20Stora\
    ge\x20represents\x20both\x20the\x20rootfs\x20of\x20the\x20container,\x20\
    and\x20any\x20volume\x20that\n\x20could\x20have\x20been\x20defined\x20th\
    rough\x20the\x20Mount\x20list\x20of\x20the\x20OCI\x20specification.\n\n\
    \x0b\n\x03\x04.\x01\x12\x04\x85\x03\x08\x0f\n\x8b\x02\n\x04\x04.\x02\0\
    \x12\x04\x8a\x03\x08\x1a\x1a\xfc\x01\x20Driver\x20is\x20used\x20to\x20de\
    fine\x20the\x20way\x20the\x20storage\x20is\x20passed\x20through\x20the\n\
    \x20virtual\x20machine.\x20It\x20can\x20be\x20\"9p\",\x20\"blk\",\x20or\
    \x20something\x20else,\x20but\x20for\n\x20all\x20cases,\x20this\x20will\
    \x20define\x20if\x20some\x20extra\x20steps\x20are\x20required\x20before\
    \n\x20this\x20storage\x20gets\x20mounted\x20into\x20the\x20container.\n\
    \n\x0f\n\x05\x04.\x02\0\x04\x12\x06\x8a\x03\x08\x85\x03\x11\n\r\n\x05\
    \x04.\x02\0\x05\x12\x04\x8a\x03\x08\x0e\n\r\n\x05\x04.\x02\0\x01\x12\x04\
    \x8a\x03\x0f\x15\n\r\n\x05\x04.\x02\0\x03\x12\x04\x8a\x03\x18\x19\n\xd0\
    \x01\n\x04\x04.\x02\x01\x12\x04\x8e\x03\x08+\x1a\xc1\x01\x20DriverOption\
    s\x20allows\x20the\x20caller\x20to\x20define\x20a\x20list\x20of\x20optio\
    ns\x20such\n\x20as\x20block\x20sizes,\x20numbers\x20of\x20luns,\x20...\
    \x20which\x20are\x20very\x20specific\x20to\n\x20every\x20device\x20and\
    \x20cannot\x20be\x20generalized\x20through\x20extra\x20fields.\n\n\r\n\
    \x05\x04.\x02\x01\x04\x12\x04\x8e\x03\x08\x10\n\r\n\x05\x04.\x02\x01\x05\
    \x12\x04\x8e\x03\x11\x17\n\r\n\x05\x04.\x02\x01\x01\x12\x04\x8e\x03\x18&\
    \n\r\n\x05\x04.\x02\x01\x03\x12\x04\x8e\x03)*\n\xce\x02\n\x04\x04.\x02\
    \x02\x12\x04\x94\x03\x08\x1a\x1a\xbf\x02\x20Source\x20can\x20be\x20anyth\
    ing\x20representing\x20the\x20source\x20of\x20the\x20storage.\x20This\n\
    \x20will\x20be\x20handled\x20by\x20the\x20proper\x20handler\x20based\x20\
    on\x20the\x20Driver\x20used.\n\x20For\x20instance,\x20it\x20can\x20be\
    \x20a\x20very\x20simple\x20path\x20if\x20the\x20caller\x20knows\x20the\n\
    \x20name\x20of\x20device\x20inside\x20the\x20VM,\x20or\x20it\x20can\x20b\
    e\x20some\x20sort\x20of\x20identifier\n\x20to\x20let\x20the\x20agent\x20\
    find\x20the\x20device\x20inside\x20the\x20VM.\n\n\x0f\n\x05\x04.\x02\x02\
    \x04\x12\x06\x94\x03\x08\x8e\x03+\n\r\n\x05\x04.\x02\x02\x05\x12\x04\x94\
    \x03\x08\x0e\n\r\n\x05\x04.\x02\x02\x01\x12\x04\x94\x03\x0f\x15\n\r\n\
    \x05\x04.\x02\x02\x03\x12\x04\x94\x03\x18\x19\n\xdb\x01\n\x04\x04.\x02\
    \x03\x12\x04\x98\x03\x08\x1a\x1a\xcc\x01\x20Fstype\x20represents\x20the\
    \x20filesystem\x20that\x20needs\x20to\x20be\x20used\x20to\x20mount\x20th\
    e\n\x20storage\x20inside\x20the\x20VM.\x20For\x20instance,\x20it\x20coul\
    d\x20be\x20\"xfs\"\x20for\x20block\n\x20device,\x20\"9p\"\x20for\x20shar\
    ed\x20filesystem,\x20or\x20\"tmpfs\"\x20for\x20shared\x20/dev/shm.\n\n\
    \x0f\n\x05\x04.\x02\x03\x04\x12\x06\x98\x03\x08\x94\x03\x1a\n\r\n\x05\
    \x04.\x02\x03\x05\x12\x04\x98\x03\x08\x0e\n\r\n\x05\x04.\x02\x03\x01\x12\
    \x04\x98\x03\x0f\x15\n\r\n\x05\x04.\x02\x03\x03\x12\x04\x98\x03\x18\x19\
    \nw\n\x04\x04.\x02\x04\x12\x04\x9b\x03\x08$\x1ai\x20Options\x20describes\
    \x20the\x20additional\x20options\x20that\x20might\x20be\x20needed\x20to\
    \n\x20mount\x20properly\x20the\x20storage\x20filesytem.\n\n\r\n\x05\x04.\
    \x02\x04\x04\x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04.\x02\x04\x05\x12\x04\
    \x9b\x03\x11\x17\n\r\n\x05\x04.\x02\x04\x01\x12\x04\x9b\x03\x18\x1f\n\r\
    \n\x05\x04.\x02\x04\x03\x12\x04\x9b\x03\"#\na\n\x04\x04.\x02\x05\x12\x04\
    \x9e\x03\x08\x1f\x1aS\x20MountPoint\x20refers\x20to\x20the\x20path\x20wh\
    ere\x20the\x20storage\x20should\x20be\x20mounted\n\x20inside\x20the\x20V\
    M.\n\n\x0f\n\x05\x04.\x02\x05\x04\x12\x06\x9e\x03\x08\x9b\x03$\n\r\n\x05\
    \x04.\x02\x05\x05\x12\x04\x9e\x03\x08\x0e\n\r\n\x05\x04.\x02\x05\x01\x12\
    \x04\x9e\x03\x0f\x1a\n\r\n\x05\x04.\x02\x05\x03\x12\x04\x9e\x03\x1d\x1e\
    \n\x88\x01\n\x02\x04/\x12\x06\xa3\x03\0\xc3\x03\x01\x1az\x20Device\x20re\
    presents\x20only\x20the\x20devices\x20that\x20could\x20have\x20been\x20d\
    efined\x20through\x20the\n\x20Linux\x20Device\x20list\x20of\x20the\x20OC\
    I\x20specification.\n\n\x0b\n\x03\x04/\x01\x12\x04\xa3\x03\x08\x0e\n\xb0\
    \x01\n\x04\x04/\x02\0\x12\x04\xa7\x03\x08\x16\x1a\xa1\x01\x20Id\x20can\
    \x20be\x20used\x20to\x20identify\x20the\x20device\x20inside\x20the\x20VM\
    .\x20Some\x20devices\n\x20might\x20not\x20need\x20it\x20to\x20be\x20iden\
    tified\x20on\x20the\x20VM,\x20and\x20will\x20rely\x20on\x20the\n\x20prov\
    ided\x20VmPath\x20instead.\n\n\x0f\n\x05\x04/\x02\0\x04\x12\x06\xa7\x03\
    \x08\xa3\x03\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xa7\x03\x08\x0e\n\r\n\
    \x05\x04/\x02\0\x01\x12\x04\xa7\x03\x0f\x11\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xa7\x03\x14\x15\n\xbd\x01\n\x04\x04/\x02\x01\x12\x04\xac\x03\x08\
    \x18\x1a\xae\x01\x20Type\x20defines\x20the\x20type\x20of\x20device\x20de\
    scribed.\x20This\x20can\x20be\x20\"blk\",\n\x20\"scsi\",\x20\"vfio\",\
    \x20...\n\x20Particularly,\x20this\x20should\x20be\x20used\x20to\x20trig\
    ger\x20the\x20use\x20of\x20the\n\x20appropriate\x20device\x20handler.\n\
    \n\x0f\n\x05\x04/\x02\x01\x04\x12\x06\xac\x03\x08\xa7\x03\x16\n\r\n\x05\
    \x04/\x02\x01\x05\x12\x04\xac\x03\x08\x0e\n\r\n\x05\x04/\x02\x01\x01\x12\
    \x04\xac\x03\x0f\x13\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xac\x03\x16\x17\
    \n\xab\x02\n\x04\x04/\x02\x02\x12\x04\xb2\x03\x08\x1b\x1a\x9c\x02\x20VmP\
    ath\x20can\x20be\x20used\x20by\x20the\x20caller\x20to\x20provide\x20dire\
    ctly\x20the\x20path\x20of\n\x20the\x20device\x20as\x20it\x20will\x20appe\
    ar\x20inside\x20the\x20VM.\x20For\x20some\x20devices,\x20the\n\x20device\
    \x20id\x20or\x20the\x20list\x20of\x20options\x20passed\x20might\x20not\
    \x20be\x20enough\x20to\x20find\n\x20the\x20device.\x20In\x20those\x20cas\
    es,\x20the\x20caller\x20should\x20predict\x20and\x20provide\n\x20this\
    \x20vm_path.\n\n\x0f\n\x05\x04/\x02\x02\x04\x12\x06\xb2\x03\x08\xac\x03\
    \x18\n\r\n\x05\x04/\x02\x02\x05\x12\x04\xb2\x03\x08\x0e\n\r\n\x05\x04/\
    \x02\x02\x01\x12\x04\xb2\x03\x0f\x16\n\r\n\x05\x04/\x02\x02\x03\x12\x04\
    \xb2\x03\x19\x1a\n\xd4\x05\n\x04\x04/\x02\x03\x12\x04\xbe\x03\x08\"\x1a\
    \xc5\x05\x20ContainerPath\x20defines\x20the\x20path\x20where\x20the\x20d\
    evice\x20should\x20be\x20found\x20inside\n\x20the\x20container.\x20This\
    \x20path\x20should\x20match\x20the\x20path\x20of\x20the\x20device\x20fro\
    m\n\x20the\x20device\x20list\x20listed\x20inside\x20the\x20OCI\x20spec.\
    \x20This\x20is\x20used\x20in\x20order\n\x20to\x20identify\x20the\x20righ\
    t\x20device\x20in\x20the\x20spec\x20and\x20update\x20it\x20with\x20the\n\
    \x20right\x20options\x20such\x20as\x20major/minor\x20numbers\x20as\x20th\
    ey\x20appear\x20inside\n\x20the\x20VM\x20for\x20instance.\x20Note\x20tha\
    t\x20an\x20empty\x20ctr_path\x20should\x20be\x20used\n\x20to\x20make\x20\
    sure\x20the\x20device\x20handler\x20inside\x20the\x20agent\x20is\x20call\
    ed,\x20but\n\x20no\x20spec\x20update\x20needs\x20to\x20be\x20performed.\
    \x20This\x20has\x20to\x20happen\x20for\x20the\n\x20case\x20of\x20rootfs,\
    \x20when\x20a\x20device\x20has\x20to\x20be\x20waited\x20for\x20after\x20\
    it\x20has\n\x20been\x20hotplugged.\x20An\x20equivalent\x20Storage\x20ent\
    ry\x20should\x20be\x20defined\x20if\n\x20any\x20mount\x20needs\x20to\x20\
    be\x20performed\x20afterwards.\n\n\x0f\n\x05\x04/\x02\x03\x04\x12\x06\
    \xbe\x03\x08\xb2\x03\x1b\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xbe\x03\x08\
    \x0e\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xbe\x03\x0f\x1d\n\r\n\x05\x04/\
    \x02\x03\x03\x12\x04\xbe\x03\x20!\n\xca\x01\n\x04\x04/\x02\x04\x12\x04\
    \xc2\x03\x08$\x1a\xbb\x01\x20Options\x20allows\x20the\x20caller\x20to\
    \x20define\x20a\x20list\x20of\x20options\x20such\x20as\x20block\n\x20siz\
    es,\x20numbers\x20of\x20luns,\x20...\x20which\x20are\x20very\x20specific\
    \x20to\x20every\x20device\n\x20and\x20cannot\x20be\x20generalized\x20thr\
    ough\x20extra\x20fields.\n\n\r\n\x05\x04/\x02\x04\x04\x12\x04\xc2\x03\
    \x08\x10\n\r\n\x05\x04/\x02\x04\x05\x12\x04\xc2\x03\x11\x17\n\r\n\x05\
    \x04/\x02\x04\x01\x12\x04\xc2\x03\x18\x1f\n\r\n\x05\x04/\x02\x04\x03\x12\
    \x04\xc2\x03\"#\n\x0c\n\x02\x040\x12\x06\xc5\x03\0\xc9\x03\x01\n\x0b\n\
    \x03\x040\x01\x12\x04\xc5\x03\x08\x12\n\x0c\n\x04\x040\x02\0\x12\x04\xc6\
    \x03\x08\x17\n\x0f\n\x05\x040\x02\0\x04\x12\x06\xc6\x03\x08\xc5\x03\x14\
    \n\r\n\x05\x040\x02\0\x05\x12\x04\xc6\x03\x08\x0e\n\r\n\x05\x040\x02\0\
    \x01\x12\x04\xc6\x03\x0f\x12\n\r\n\x05\x040\x02\0\x03\x12\x04\xc6\x03\
    \x15\x16\n\x0c\n\x04\x040\x02\x01\x12\x04\xc7\x03\x08\x17\n\x0f\n\x05\
    \x040\x02\x01\x04\x12\x06\xc7\x03\x08\xc6\x03\x17\n\r\n\x05\x040\x02\x01\
    \x05\x12\x04\xc7\x03\x08\x0e\n\r\n\x05\x040\x02\x01\x01\x12\x04\xc7\x03\
    \x0f\x12\n\r\n\x05\x040\x02\x01\x03\x12\x04\xc7\x03\x15\x16\n\x0c\n\x04\
    \x040\x02\x02\x12\x04\xc8\x03\x08+\n\r\n\x05\x040\x02\x02\x04\x12\x04\
    \xc8\x03\x08\x10\n\r\n\x05\x040\x02\x02\x05\x12\x04\xc8\x03\x11\x17\n\r\
    \n\x05\x040\x02\x02\x01\x12\x04\xc8\x03\x18&\n\r\n\x05\x040\x02\x02\x03\
    \x12\x04\xc8\x03)*\n\x0c\n\x02\x041\x12\x06\xcb\x03\0\xdf\x03\x01\n\x0b\
    \n\x03\x041\x01\x12\x04\xcb\x03\x08\x17\nj\n\x04\x041\x02\0\x12\x04\xce\
    \x03\x08\x18\x1a\\\x20Path\x20is\x20the\x20destination\x20file\x20in\x20\
    the\x20guest.\x20It\x20must\x20be\x20absolute,\n\x20canonical\x20and\x20\
    below\x20/run.\n\n\x0f\n\x05\x041\x02\0\x04\x12\x06\xce\x03\x08\xcb\x03\
    \x19\n\r\n\x05\x041\x02\0\x05\x12\x04\xce\x03\x08\x0e\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xce\x03\x0f\x13\n\r\n\x05\x041\x02\0\x03\x12\x04\xce\x03\
    \x16\x17\n\xbd\x01\n\x04\x041\x02\x01\x12\x04\xd2\x03\x08\x1c\x1a\xae\
    \x01\x20FileSize\x20is\x20the\x20expected\x20file\x20size,\x20for\x20sec\
    urity\x20reasons\x20write\x20operations\n\x20are\x20made\x20in\x20a\x20t\
    emporary\x20file,\x20once\x20it\x20has\x20the\x20expected\x20size,\x20it\
    's\x20moved\n\x20to\x20the\x20destination\x20path.\n\n\x0f\n\x05\x041\
    \x02\x01\x04\x12\x06\xd2\x03\x08\xce\x03\x18\n\r\n\x05\x041\x02\x01\x05\
    \x12\x04\xd2\x03\x08\r\n\r\n\x05\x041\x02\x01\x01\x12\x04\xd2\x03\x0e\
    \x17\n\r\n\x05\x041\x02\x01\x03\x12\x04\xd2\x03\x1a\x1b\n*\n\x04\x041\
    \x02\x02\x12\x04\xd4\x03\x08\x1d\x1a\x1c\x20FileMode\x20is\x20the\x20fil\
    e\x20mode.\n\n\x0f\n\x05\x041\x02\x02\x04\x12\x06\xd4\x03\x08\xd2\x03\
    \x1c\n\r\n\x05\x041\x02\x02\x05\x12\x04\xd4\x03\x08\x0e\n\r\n\x05\x041\
    \x02\x02\x01\x12\x04\xd4\x03\x0f\x18\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xd4\x03\x1b\x1c\nS\n\x04\x041\x02\x03\x12\x04\xd6\x03\x08\x1c\x1aE\x20D\
    irMode\x20is\x20the\x20mode\x20for\x20the\x20parent\x20directories\x20of\
    \x20destination\x20path.\n\n\x0f\n\x05\x041\x02\x03\x04\x12\x06\xd6\x03\
    \x08\xd4\x03\x1d\n\r\n\x05\x041\x02\x03\x05\x12\x04\xd6\x03\x08\x0e\n\r\
    \n\x05\x041\x02\x03\x01\x12\x04\xd6\x03\x0f\x17\n\r\n\x05\x041\x02\x03\
    \x03\x12\x04\xd6\x03\x1a\x1b\n+\n\x04\x041\x02\x04\x12\x04\xd8\x03\x08\
    \x16\x1a\x1d\x20Uid\x20is\x20the\x20numeric\x20user\x20id.\n\n\x0f\n\x05\
    \x041\x02\x04\x04\x12\x06\xd8\x03\x08\xd6\x03\x1c\n\r\n\x05\x041\x02\x04\
    \x05\x12\x04\xd8\x03\x08\r\n\r\n\x05\x041\x02\x04\x01\x12\x04\xd8\x03\
    \x0e\x11\n\r\n\x05\x041\x02\x04\x03\x12\x04\xd8\x03\x14\x15\n,\n\x04\x04\
    1\x02\x05\x12\x04\xda\x03\x08\x16\x1a\x1e\x20Gid\x20is\x20the\x20numeric\
    \x20group\x20id.\n\n\x0f\n\x05\x041\x02\x05\x04\x12\x06\xda\x03\x08\xd8\
    \x03\x16\n\r\n\x05\x041\x02\x05\x05\x12\x04\xda\x03\x08\r\n\r\n\x05\x041\
    \x02\x05\x01\x12\x04\xda\x03\x0e\x11\n\r\n\x05\x041\x02\x05\x03\x12\x04\
    \xda\x03\x14\x15\n4\n\x04\x041\x02\x06\x12\x04\xdc\x03\x08\x19\x1a&\x20O\
    ffset\x20for\x20the\x20next\x20write\x20operation.\n\n\x0f\n\x05\x041\
    \x02\x06\x04\x12\x06\xdc\x03\x08\xda\x03\x16\n\r\n\x05\x041\x02\x06\x05\
    \x12\x04\xdc\x03\x08\r\n\r\n\x05\x041\x02\x06\x01\x12\x04\xdc\x03\x0e\
    \x14\n\r\n\x05\x041\x02\x06\x03\x12\x04\xdc\x03\x17\x18\n6\n\x04\x041\
    \x02\x07\x12\x04\xde\x03\x08\x17\x1a(\x20Data\x20to\x20write\x20in\x20th\
    e\x20destination\x20file.\n\n\x0f\n\x05\x041\x02\x07\x04\x12\x06\xde\x03\
    \x08\xdc\x03\x19\n\r\n\x05\x041\x02\x07\x05\x12\x04\xde\x03\x08\r\n\r\n\
    \x05\x041\x02\x07\x01\x12\x04\xde\x03\x0e\x12\n\r\n\x05\x041\x02\x07\x03\
    \x12\x04\xde\x03\x15\x16\n\x0c\n\x02\x042\x12\x06\xe1\x03\0\xe2\x03\x01\
    \n\x0b\n\x03\x042\x01\x12\x04\xe1\x03\x08\x1b\n\x0c\n\x02\x043\x12\x06\
    \xe4\x03\0\xe5\x03\x01\n\x0b\n\x03\x043\x01\x12\x04\xe4\x03\x08\x1ab\x06\
    proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
