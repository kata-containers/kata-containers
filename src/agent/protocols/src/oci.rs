// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `github.com/kata-containers/kata-containers/src/agent/protocols/protos/oci.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct Spec {
    // message fields
    pub Version: ::std::string::String,
    pub Process: ::protobuf::SingularPtrField<Process>,
    pub Root: ::protobuf::SingularPtrField<Root>,
    pub Hostname: ::std::string::String,
    pub Mounts: ::protobuf::RepeatedField<Mount>,
    pub Hooks: ::protobuf::SingularPtrField<Hooks>,
    pub Annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub Linux: ::protobuf::SingularPtrField<Linux>,
    pub Solaris: ::protobuf::SingularPtrField<Solaris>,
    pub Windows: ::protobuf::SingularPtrField<Windows>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Spec {
    fn default() -> &'a Spec {
        <Spec as ::protobuf::Message>::default_instance()
    }
}

impl Spec {
    pub fn new() -> Spec {
        ::std::default::Default::default()
    }

    // string Version = 1;


    pub fn get_Version(&self) -> &str {
        &self.Version
    }
    pub fn clear_Version(&mut self) {
        self.Version.clear();
    }

    // Param is passed by value, moved
    pub fn set_Version(&mut self, v: ::std::string::String) {
        self.Version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Version(&mut self) -> &mut ::std::string::String {
        &mut self.Version
    }

    // Take field
    pub fn take_Version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Version, ::std::string::String::new())
    }

    // .grpc.Process Process = 2;


    pub fn get_Process(&self) -> &Process {
        self.Process.as_ref().unwrap_or_else(|| Process::default_instance())
    }
    pub fn clear_Process(&mut self) {
        self.Process.clear();
    }

    pub fn has_Process(&self) -> bool {
        self.Process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Process(&mut self, v: Process) {
        self.Process = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Process(&mut self) -> &mut Process {
        if self.Process.is_none() {
            self.Process.set_default();
        }
        self.Process.as_mut().unwrap()
    }

    // Take field
    pub fn take_Process(&mut self) -> Process {
        self.Process.take().unwrap_or_else(|| Process::new())
    }

    // .grpc.Root Root = 3;


    pub fn get_Root(&self) -> &Root {
        self.Root.as_ref().unwrap_or_else(|| Root::default_instance())
    }
    pub fn clear_Root(&mut self) {
        self.Root.clear();
    }

    pub fn has_Root(&self) -> bool {
        self.Root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Root(&mut self, v: Root) {
        self.Root = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Root(&mut self) -> &mut Root {
        if self.Root.is_none() {
            self.Root.set_default();
        }
        self.Root.as_mut().unwrap()
    }

    // Take field
    pub fn take_Root(&mut self) -> Root {
        self.Root.take().unwrap_or_else(|| Root::new())
    }

    // string Hostname = 4;


    pub fn get_Hostname(&self) -> &str {
        &self.Hostname
    }
    pub fn clear_Hostname(&mut self) {
        self.Hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_Hostname(&mut self, v: ::std::string::String) {
        self.Hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hostname(&mut self) -> &mut ::std::string::String {
        &mut self.Hostname
    }

    // Take field
    pub fn take_Hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Hostname, ::std::string::String::new())
    }

    // repeated .grpc.Mount Mounts = 5;


    pub fn get_Mounts(&self) -> &[Mount] {
        &self.Mounts
    }
    pub fn clear_Mounts(&mut self) {
        self.Mounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_Mounts(&mut self, v: ::protobuf::RepeatedField<Mount>) {
        self.Mounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Mounts(&mut self) -> &mut ::protobuf::RepeatedField<Mount> {
        &mut self.Mounts
    }

    // Take field
    pub fn take_Mounts(&mut self) -> ::protobuf::RepeatedField<Mount> {
        ::std::mem::replace(&mut self.Mounts, ::protobuf::RepeatedField::new())
    }

    // .grpc.Hooks Hooks = 6;


    pub fn get_Hooks(&self) -> &Hooks {
        self.Hooks.as_ref().unwrap_or_else(|| Hooks::default_instance())
    }
    pub fn clear_Hooks(&mut self) {
        self.Hooks.clear();
    }

    pub fn has_Hooks(&self) -> bool {
        self.Hooks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Hooks(&mut self, v: Hooks) {
        self.Hooks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hooks(&mut self) -> &mut Hooks {
        if self.Hooks.is_none() {
            self.Hooks.set_default();
        }
        self.Hooks.as_mut().unwrap()
    }

    // Take field
    pub fn take_Hooks(&mut self) -> Hooks {
        self.Hooks.take().unwrap_or_else(|| Hooks::new())
    }

    // repeated .grpc.Spec.AnnotationsEntry Annotations = 7;


    pub fn get_Annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.Annotations
    }
    pub fn clear_Annotations(&mut self) {
        self.Annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_Annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.Annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.Annotations
    }

    // Take field
    pub fn take_Annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.Annotations, ::std::collections::HashMap::new())
    }

    // .grpc.Linux Linux = 8;


    pub fn get_Linux(&self) -> &Linux {
        self.Linux.as_ref().unwrap_or_else(|| Linux::default_instance())
    }
    pub fn clear_Linux(&mut self) {
        self.Linux.clear();
    }

    pub fn has_Linux(&self) -> bool {
        self.Linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Linux(&mut self, v: Linux) {
        self.Linux = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Linux(&mut self) -> &mut Linux {
        if self.Linux.is_none() {
            self.Linux.set_default();
        }
        self.Linux.as_mut().unwrap()
    }

    // Take field
    pub fn take_Linux(&mut self) -> Linux {
        self.Linux.take().unwrap_or_else(|| Linux::new())
    }

    // .grpc.Solaris Solaris = 9;


    pub fn get_Solaris(&self) -> &Solaris {
        self.Solaris.as_ref().unwrap_or_else(|| Solaris::default_instance())
    }
    pub fn clear_Solaris(&mut self) {
        self.Solaris.clear();
    }

    pub fn has_Solaris(&self) -> bool {
        self.Solaris.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Solaris(&mut self, v: Solaris) {
        self.Solaris = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Solaris(&mut self) -> &mut Solaris {
        if self.Solaris.is_none() {
            self.Solaris.set_default();
        }
        self.Solaris.as_mut().unwrap()
    }

    // Take field
    pub fn take_Solaris(&mut self) -> Solaris {
        self.Solaris.take().unwrap_or_else(|| Solaris::new())
    }

    // .grpc.Windows Windows = 10;


    pub fn get_Windows(&self) -> &Windows {
        self.Windows.as_ref().unwrap_or_else(|| Windows::default_instance())
    }
    pub fn clear_Windows(&mut self) {
        self.Windows.clear();
    }

    pub fn has_Windows(&self) -> bool {
        self.Windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Windows(&mut self, v: Windows) {
        self.Windows = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Windows(&mut self) -> &mut Windows {
        if self.Windows.is_none() {
            self.Windows.set_default();
        }
        self.Windows.as_mut().unwrap()
    }

    // Take field
    pub fn take_Windows(&mut self) -> Windows {
        self.Windows.take().unwrap_or_else(|| Windows::new())
    }
}

impl ::protobuf::Message for Spec {
    fn is_initialized(&self) -> bool {
        for v in &self.Process {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Root {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Mounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Hooks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Linux {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Solaris {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Windows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Process)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Root)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Hostname)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Mounts)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Hooks)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.Annotations)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Linux)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Solaris)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Windows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Version);
        }
        if let Some(ref v) = self.Process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Hostname);
        }
        for value in &self.Mounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Hooks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.Annotations);
        if let Some(ref v) = self.Linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Solaris.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Windows.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Version.is_empty() {
            os.write_string(1, &self.Version)?;
        }
        if let Some(ref v) = self.Process.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Root.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Hostname.is_empty() {
            os.write_string(4, &self.Hostname)?;
        }
        for v in &self.Mounts {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Hooks.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.Annotations, os)?;
        if let Some(ref v) = self.Linux.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Solaris.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Windows.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Spec {
        Spec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Version",
                    |m: &Spec| { &m.Version },
                    |m: &mut Spec| { &mut m.Version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Process>>(
                    "Process",
                    |m: &Spec| { &m.Process },
                    |m: &mut Spec| { &mut m.Process },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Root>>(
                    "Root",
                    |m: &Spec| { &m.Root },
                    |m: &mut Spec| { &mut m.Root },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Hostname",
                    |m: &Spec| { &m.Hostname },
                    |m: &mut Spec| { &mut m.Hostname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mount>>(
                    "Mounts",
                    |m: &Spec| { &m.Mounts },
                    |m: &mut Spec| { &mut m.Mounts },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hooks>>(
                    "Hooks",
                    |m: &Spec| { &m.Hooks },
                    |m: &mut Spec| { &mut m.Hooks },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "Annotations",
                    |m: &Spec| { &m.Annotations },
                    |m: &mut Spec| { &mut m.Annotations },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Linux>>(
                    "Linux",
                    |m: &Spec| { &m.Linux },
                    |m: &mut Spec| { &mut m.Linux },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Solaris>>(
                    "Solaris",
                    |m: &Spec| { &m.Solaris },
                    |m: &mut Spec| { &mut m.Solaris },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Windows>>(
                    "Windows",
                    |m: &Spec| { &m.Windows },
                    |m: &mut Spec| { &mut m.Windows },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Spec>(
                    "Spec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Spec {
        static mut instance: ::protobuf::lazy::Lazy<Spec> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Spec::new)
        }
    }
}

impl ::protobuf::Clear for Spec {
    fn clear(&mut self) {
        self.Version.clear();
        self.Process.clear();
        self.Root.clear();
        self.Hostname.clear();
        self.Mounts.clear();
        self.Hooks.clear();
        self.Annotations.clear();
        self.Linux.clear();
        self.Solaris.clear();
        self.Windows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Spec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Spec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Process {
    // message fields
    pub Terminal: bool,
    pub ConsoleSize: ::protobuf::SingularPtrField<Box>,
    pub User: ::protobuf::SingularPtrField<User>,
    pub Args: ::protobuf::RepeatedField<::std::string::String>,
    pub Env: ::protobuf::RepeatedField<::std::string::String>,
    pub Cwd: ::std::string::String,
    pub Capabilities: ::protobuf::SingularPtrField<LinuxCapabilities>,
    pub Rlimits: ::protobuf::RepeatedField<POSIXRlimit>,
    pub NoNewPrivileges: bool,
    pub ApparmorProfile: ::std::string::String,
    pub OOMScoreAdj: i64,
    pub SelinuxLabel: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Process {
    fn default() -> &'a Process {
        <Process as ::protobuf::Message>::default_instance()
    }
}

impl Process {
    pub fn new() -> Process {
        ::std::default::Default::default()
    }

    // bool Terminal = 1;


    pub fn get_Terminal(&self) -> bool {
        self.Terminal
    }
    pub fn clear_Terminal(&mut self) {
        self.Terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_Terminal(&mut self, v: bool) {
        self.Terminal = v;
    }

    // .grpc.Box ConsoleSize = 2;


    pub fn get_ConsoleSize(&self) -> &Box {
        self.ConsoleSize.as_ref().unwrap_or_else(|| Box::default_instance())
    }
    pub fn clear_ConsoleSize(&mut self) {
        self.ConsoleSize.clear();
    }

    pub fn has_ConsoleSize(&self) -> bool {
        self.ConsoleSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ConsoleSize(&mut self, v: Box) {
        self.ConsoleSize = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ConsoleSize(&mut self) -> &mut Box {
        if self.ConsoleSize.is_none() {
            self.ConsoleSize.set_default();
        }
        self.ConsoleSize.as_mut().unwrap()
    }

    // Take field
    pub fn take_ConsoleSize(&mut self) -> Box {
        self.ConsoleSize.take().unwrap_or_else(|| Box::new())
    }

    // .grpc.User User = 3;


    pub fn get_User(&self) -> &User {
        self.User.as_ref().unwrap_or_else(|| User::default_instance())
    }
    pub fn clear_User(&mut self) {
        self.User.clear();
    }

    pub fn has_User(&self) -> bool {
        self.User.is_some()
    }

    // Param is passed by value, moved
    pub fn set_User(&mut self, v: User) {
        self.User = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_User(&mut self) -> &mut User {
        if self.User.is_none() {
            self.User.set_default();
        }
        self.User.as_mut().unwrap()
    }

    // Take field
    pub fn take_User(&mut self) -> User {
        self.User.take().unwrap_or_else(|| User::new())
    }

    // repeated string Args = 4;


    pub fn get_Args(&self) -> &[::std::string::String] {
        &self.Args
    }
    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Args, ::protobuf::RepeatedField::new())
    }

    // repeated string Env = 5;


    pub fn get_Env(&self) -> &[::std::string::String] {
        &self.Env
    }
    pub fn clear_Env(&mut self) {
        self.Env.clear();
    }

    // Param is passed by value, moved
    pub fn set_Env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Env
    }

    // Take field
    pub fn take_Env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Env, ::protobuf::RepeatedField::new())
    }

    // string Cwd = 6;


    pub fn get_Cwd(&self) -> &str {
        &self.Cwd
    }
    pub fn clear_Cwd(&mut self) {
        self.Cwd.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cwd(&mut self, v: ::std::string::String) {
        self.Cwd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cwd(&mut self) -> &mut ::std::string::String {
        &mut self.Cwd
    }

    // Take field
    pub fn take_Cwd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cwd, ::std::string::String::new())
    }

    // .grpc.LinuxCapabilities Capabilities = 7;


    pub fn get_Capabilities(&self) -> &LinuxCapabilities {
        self.Capabilities.as_ref().unwrap_or_else(|| LinuxCapabilities::default_instance())
    }
    pub fn clear_Capabilities(&mut self) {
        self.Capabilities.clear();
    }

    pub fn has_Capabilities(&self) -> bool {
        self.Capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Capabilities(&mut self, v: LinuxCapabilities) {
        self.Capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Capabilities(&mut self) -> &mut LinuxCapabilities {
        if self.Capabilities.is_none() {
            self.Capabilities.set_default();
        }
        self.Capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_Capabilities(&mut self) -> LinuxCapabilities {
        self.Capabilities.take().unwrap_or_else(|| LinuxCapabilities::new())
    }

    // repeated .grpc.POSIXRlimit Rlimits = 8;


    pub fn get_Rlimits(&self) -> &[POSIXRlimit] {
        &self.Rlimits
    }
    pub fn clear_Rlimits(&mut self) {
        self.Rlimits.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rlimits(&mut self, v: ::protobuf::RepeatedField<POSIXRlimit>) {
        self.Rlimits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rlimits(&mut self) -> &mut ::protobuf::RepeatedField<POSIXRlimit> {
        &mut self.Rlimits
    }

    // Take field
    pub fn take_Rlimits(&mut self) -> ::protobuf::RepeatedField<POSIXRlimit> {
        ::std::mem::replace(&mut self.Rlimits, ::protobuf::RepeatedField::new())
    }

    // bool NoNewPrivileges = 9;


    pub fn get_NoNewPrivileges(&self) -> bool {
        self.NoNewPrivileges
    }
    pub fn clear_NoNewPrivileges(&mut self) {
        self.NoNewPrivileges = false;
    }

    // Param is passed by value, moved
    pub fn set_NoNewPrivileges(&mut self, v: bool) {
        self.NoNewPrivileges = v;
    }

    // string ApparmorProfile = 10;


    pub fn get_ApparmorProfile(&self) -> &str {
        &self.ApparmorProfile
    }
    pub fn clear_ApparmorProfile(&mut self) {
        self.ApparmorProfile.clear();
    }

    // Param is passed by value, moved
    pub fn set_ApparmorProfile(&mut self, v: ::std::string::String) {
        self.ApparmorProfile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ApparmorProfile(&mut self) -> &mut ::std::string::String {
        &mut self.ApparmorProfile
    }

    // Take field
    pub fn take_ApparmorProfile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ApparmorProfile, ::std::string::String::new())
    }

    // int64 OOMScoreAdj = 11;


    pub fn get_OOMScoreAdj(&self) -> i64 {
        self.OOMScoreAdj
    }
    pub fn clear_OOMScoreAdj(&mut self) {
        self.OOMScoreAdj = 0;
    }

    // Param is passed by value, moved
    pub fn set_OOMScoreAdj(&mut self, v: i64) {
        self.OOMScoreAdj = v;
    }

    // string SelinuxLabel = 12;


    pub fn get_SelinuxLabel(&self) -> &str {
        &self.SelinuxLabel
    }
    pub fn clear_SelinuxLabel(&mut self) {
        self.SelinuxLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_SelinuxLabel(&mut self, v: ::std::string::String) {
        self.SelinuxLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SelinuxLabel(&mut self) -> &mut ::std::string::String {
        &mut self.SelinuxLabel
    }

    // Take field
    pub fn take_SelinuxLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SelinuxLabel, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Process {
    fn is_initialized(&self) -> bool {
        for v in &self.ConsoleSize {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.User {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Rlimits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Terminal = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ConsoleSize)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.User)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Args)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Env)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Cwd)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Capabilities)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Rlimits)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.NoNewPrivileges = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ApparmorProfile)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.OOMScoreAdj = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SelinuxLabel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Terminal != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ConsoleSize.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.User.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.Env {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.Cwd.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Cwd);
        }
        if let Some(ref v) = self.Capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Rlimits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.NoNewPrivileges != false {
            my_size += 2;
        }
        if !self.ApparmorProfile.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.ApparmorProfile);
        }
        if self.OOMScoreAdj != 0 {
            my_size += ::protobuf::rt::value_size(11, self.OOMScoreAdj, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SelinuxLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.SelinuxLabel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Terminal != false {
            os.write_bool(1, self.Terminal)?;
        }
        if let Some(ref v) = self.ConsoleSize.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.User.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.Args {
            os.write_string(4, &v)?;
        };
        for v in &self.Env {
            os.write_string(5, &v)?;
        };
        if !self.Cwd.is_empty() {
            os.write_string(6, &self.Cwd)?;
        }
        if let Some(ref v) = self.Capabilities.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.Rlimits {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.NoNewPrivileges != false {
            os.write_bool(9, self.NoNewPrivileges)?;
        }
        if !self.ApparmorProfile.is_empty() {
            os.write_string(10, &self.ApparmorProfile)?;
        }
        if self.OOMScoreAdj != 0 {
            os.write_int64(11, self.OOMScoreAdj)?;
        }
        if !self.SelinuxLabel.is_empty() {
            os.write_string(12, &self.SelinuxLabel)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Process {
        Process::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Terminal",
                    |m: &Process| { &m.Terminal },
                    |m: &mut Process| { &mut m.Terminal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Box>>(
                    "ConsoleSize",
                    |m: &Process| { &m.ConsoleSize },
                    |m: &mut Process| { &mut m.ConsoleSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "User",
                    |m: &Process| { &m.User },
                    |m: &mut Process| { &mut m.User },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Args",
                    |m: &Process| { &m.Args },
                    |m: &mut Process| { &mut m.Args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Env",
                    |m: &Process| { &m.Env },
                    |m: &mut Process| { &mut m.Env },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Cwd",
                    |m: &Process| { &m.Cwd },
                    |m: &mut Process| { &mut m.Cwd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxCapabilities>>(
                    "Capabilities",
                    |m: &Process| { &m.Capabilities },
                    |m: &mut Process| { &mut m.Capabilities },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<POSIXRlimit>>(
                    "Rlimits",
                    |m: &Process| { &m.Rlimits },
                    |m: &mut Process| { &mut m.Rlimits },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "NoNewPrivileges",
                    |m: &Process| { &m.NoNewPrivileges },
                    |m: &mut Process| { &mut m.NoNewPrivileges },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ApparmorProfile",
                    |m: &Process| { &m.ApparmorProfile },
                    |m: &mut Process| { &mut m.ApparmorProfile },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "OOMScoreAdj",
                    |m: &Process| { &m.OOMScoreAdj },
                    |m: &mut Process| { &mut m.OOMScoreAdj },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SelinuxLabel",
                    |m: &Process| { &m.SelinuxLabel },
                    |m: &mut Process| { &mut m.SelinuxLabel },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Process>(
                    "Process",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Process {
        static mut instance: ::protobuf::lazy::Lazy<Process> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Process::new)
        }
    }
}

impl ::protobuf::Clear for Process {
    fn clear(&mut self) {
        self.Terminal = false;
        self.ConsoleSize.clear();
        self.User.clear();
        self.Args.clear();
        self.Env.clear();
        self.Cwd.clear();
        self.Capabilities.clear();
        self.Rlimits.clear();
        self.NoNewPrivileges = false;
        self.ApparmorProfile.clear();
        self.OOMScoreAdj = 0;
        self.SelinuxLabel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Process {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Process {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Box {
    // message fields
    pub Height: u32,
    pub Width: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Box {
    fn default() -> &'a Box {
        <Box as ::protobuf::Message>::default_instance()
    }
}

impl Box {
    pub fn new() -> Box {
        ::std::default::Default::default()
    }

    // uint32 Height = 1;


    pub fn get_Height(&self) -> u32 {
        self.Height
    }
    pub fn clear_Height(&mut self) {
        self.Height = 0;
    }

    // Param is passed by value, moved
    pub fn set_Height(&mut self, v: u32) {
        self.Height = v;
    }

    // uint32 Width = 2;


    pub fn get_Width(&self) -> u32 {
        self.Width
    }
    pub fn clear_Width(&mut self) {
        self.Width = 0;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: u32) {
        self.Width = v;
    }
}

impl ::protobuf::Message for Box {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Width = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Width != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Width, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Height != 0 {
            os.write_uint32(1, self.Height)?;
        }
        if self.Width != 0 {
            os.write_uint32(2, self.Width)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Box {
        Box::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Height",
                    |m: &Box| { &m.Height },
                    |m: &mut Box| { &mut m.Height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Width",
                    |m: &Box| { &m.Width },
                    |m: &mut Box| { &mut m.Width },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Box>(
                    "Box",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Box {
        static mut instance: ::protobuf::lazy::Lazy<Box> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Box::new)
        }
    }
}

impl ::protobuf::Clear for Box {
    fn clear(&mut self) {
        self.Height = 0;
        self.Width = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Box {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Box {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub UID: u32,
    pub GID: u32,
    pub AdditionalGids: ::std::vec::Vec<u32>,
    pub Username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // uint32 UID = 1;


    pub fn get_UID(&self) -> u32 {
        self.UID
    }
    pub fn clear_UID(&mut self) {
        self.UID = 0;
    }

    // Param is passed by value, moved
    pub fn set_UID(&mut self, v: u32) {
        self.UID = v;
    }

    // uint32 GID = 2;


    pub fn get_GID(&self) -> u32 {
        self.GID
    }
    pub fn clear_GID(&mut self) {
        self.GID = 0;
    }

    // Param is passed by value, moved
    pub fn set_GID(&mut self, v: u32) {
        self.GID = v;
    }

    // repeated uint32 AdditionalGids = 3;


    pub fn get_AdditionalGids(&self) -> &[u32] {
        &self.AdditionalGids
    }
    pub fn clear_AdditionalGids(&mut self) {
        self.AdditionalGids.clear();
    }

    // Param is passed by value, moved
    pub fn set_AdditionalGids(&mut self, v: ::std::vec::Vec<u32>) {
        self.AdditionalGids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AdditionalGids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.AdditionalGids
    }

    // Take field
    pub fn take_AdditionalGids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.AdditionalGids, ::std::vec::Vec::new())
    }

    // string Username = 4;


    pub fn get_Username(&self) -> &str {
        &self.Username
    }
    pub fn clear_Username(&mut self) {
        self.Username.clear();
    }

    // Param is passed by value, moved
    pub fn set_Username(&mut self, v: ::std::string::String) {
        self.Username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Username(&mut self) -> &mut ::std::string::String {
        &mut self.Username
    }

    // Take field
    pub fn take_Username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.UID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.GID = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.AdditionalGids)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.UID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.UID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.GID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.AdditionalGids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.Username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.UID != 0 {
            os.write_uint32(1, self.UID)?;
        }
        if self.GID != 0 {
            os.write_uint32(2, self.GID)?;
        }
        for v in &self.AdditionalGids {
            os.write_uint32(3, *v)?;
        };
        if !self.Username.is_empty() {
            os.write_string(4, &self.Username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "UID",
                    |m: &User| { &m.UID },
                    |m: &mut User| { &mut m.UID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "GID",
                    |m: &User| { &m.GID },
                    |m: &mut User| { &mut m.GID },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "AdditionalGids",
                    |m: &User| { &m.AdditionalGids },
                    |m: &mut User| { &mut m.AdditionalGids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Username",
                    |m: &User| { &m.Username },
                    |m: &mut User| { &mut m.Username },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<User>(
                    "User",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static User {
        static mut instance: ::protobuf::lazy::Lazy<User> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(User::new)
        }
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.UID = 0;
        self.GID = 0;
        self.AdditionalGids.clear();
        self.Username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxCapabilities {
    // message fields
    pub Bounding: ::protobuf::RepeatedField<::std::string::String>,
    pub Effective: ::protobuf::RepeatedField<::std::string::String>,
    pub Inheritable: ::protobuf::RepeatedField<::std::string::String>,
    pub Permitted: ::protobuf::RepeatedField<::std::string::String>,
    pub Ambient: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxCapabilities {
    fn default() -> &'a LinuxCapabilities {
        <LinuxCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl LinuxCapabilities {
    pub fn new() -> LinuxCapabilities {
        ::std::default::Default::default()
    }

    // repeated string Bounding = 1;


    pub fn get_Bounding(&self) -> &[::std::string::String] {
        &self.Bounding
    }
    pub fn clear_Bounding(&mut self) {
        self.Bounding.clear();
    }

    // Param is passed by value, moved
    pub fn set_Bounding(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Bounding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Bounding(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Bounding
    }

    // Take field
    pub fn take_Bounding(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Bounding, ::protobuf::RepeatedField::new())
    }

    // repeated string Effective = 2;


    pub fn get_Effective(&self) -> &[::std::string::String] {
        &self.Effective
    }
    pub fn clear_Effective(&mut self) {
        self.Effective.clear();
    }

    // Param is passed by value, moved
    pub fn set_Effective(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Effective = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Effective(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Effective
    }

    // Take field
    pub fn take_Effective(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Effective, ::protobuf::RepeatedField::new())
    }

    // repeated string Inheritable = 3;


    pub fn get_Inheritable(&self) -> &[::std::string::String] {
        &self.Inheritable
    }
    pub fn clear_Inheritable(&mut self) {
        self.Inheritable.clear();
    }

    // Param is passed by value, moved
    pub fn set_Inheritable(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Inheritable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Inheritable(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Inheritable
    }

    // Take field
    pub fn take_Inheritable(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Inheritable, ::protobuf::RepeatedField::new())
    }

    // repeated string Permitted = 4;


    pub fn get_Permitted(&self) -> &[::std::string::String] {
        &self.Permitted
    }
    pub fn clear_Permitted(&mut self) {
        self.Permitted.clear();
    }

    // Param is passed by value, moved
    pub fn set_Permitted(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Permitted = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Permitted(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Permitted
    }

    // Take field
    pub fn take_Permitted(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Permitted, ::protobuf::RepeatedField::new())
    }

    // repeated string Ambient = 5;


    pub fn get_Ambient(&self) -> &[::std::string::String] {
        &self.Ambient
    }
    pub fn clear_Ambient(&mut self) {
        self.Ambient.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ambient(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Ambient = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ambient(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Ambient
    }

    // Take field
    pub fn take_Ambient(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Ambient, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxCapabilities {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Bounding)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Effective)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Inheritable)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Permitted)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Ambient)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Bounding {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.Effective {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Inheritable {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.Permitted {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.Ambient {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Bounding {
            os.write_string(1, &v)?;
        };
        for v in &self.Effective {
            os.write_string(2, &v)?;
        };
        for v in &self.Inheritable {
            os.write_string(3, &v)?;
        };
        for v in &self.Permitted {
            os.write_string(4, &v)?;
        };
        for v in &self.Ambient {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxCapabilities {
        LinuxCapabilities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Bounding",
                    |m: &LinuxCapabilities| { &m.Bounding },
                    |m: &mut LinuxCapabilities| { &mut m.Bounding },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Effective",
                    |m: &LinuxCapabilities| { &m.Effective },
                    |m: &mut LinuxCapabilities| { &mut m.Effective },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Inheritable",
                    |m: &LinuxCapabilities| { &m.Inheritable },
                    |m: &mut LinuxCapabilities| { &mut m.Inheritable },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Permitted",
                    |m: &LinuxCapabilities| { &m.Permitted },
                    |m: &mut LinuxCapabilities| { &mut m.Permitted },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Ambient",
                    |m: &LinuxCapabilities| { &m.Ambient },
                    |m: &mut LinuxCapabilities| { &mut m.Ambient },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxCapabilities>(
                    "LinuxCapabilities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxCapabilities {
        static mut instance: ::protobuf::lazy::Lazy<LinuxCapabilities> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxCapabilities::new)
        }
    }
}

impl ::protobuf::Clear for LinuxCapabilities {
    fn clear(&mut self) {
        self.Bounding.clear();
        self.Effective.clear();
        self.Inheritable.clear();
        self.Permitted.clear();
        self.Ambient.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxCapabilities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct POSIXRlimit {
    // message fields
    pub Type: ::std::string::String,
    pub Hard: u64,
    pub Soft: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a POSIXRlimit {
    fn default() -> &'a POSIXRlimit {
        <POSIXRlimit as ::protobuf::Message>::default_instance()
    }
}

impl POSIXRlimit {
    pub fn new() -> POSIXRlimit {
        ::std::default::Default::default()
    }

    // string Type = 1;


    pub fn get_Type(&self) -> &str {
        &self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // uint64 Hard = 2;


    pub fn get_Hard(&self) -> u64 {
        self.Hard
    }
    pub fn clear_Hard(&mut self) {
        self.Hard = 0;
    }

    // Param is passed by value, moved
    pub fn set_Hard(&mut self, v: u64) {
        self.Hard = v;
    }

    // uint64 Soft = 3;


    pub fn get_Soft(&self) -> u64 {
        self.Soft
    }
    pub fn clear_Soft(&mut self) {
        self.Soft = 0;
    }

    // Param is passed by value, moved
    pub fn set_Soft(&mut self, v: u64) {
        self.Soft = v;
    }
}

impl ::protobuf::Message for POSIXRlimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Hard = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Soft = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Type);
        }
        if self.Hard != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Hard, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Soft != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Soft, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Type.is_empty() {
            os.write_string(1, &self.Type)?;
        }
        if self.Hard != 0 {
            os.write_uint64(2, self.Hard)?;
        }
        if self.Soft != 0 {
            os.write_uint64(3, self.Soft)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> POSIXRlimit {
        POSIXRlimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Type",
                    |m: &POSIXRlimit| { &m.Type },
                    |m: &mut POSIXRlimit| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Hard",
                    |m: &POSIXRlimit| { &m.Hard },
                    |m: &mut POSIXRlimit| { &mut m.Hard },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Soft",
                    |m: &POSIXRlimit| { &m.Soft },
                    |m: &mut POSIXRlimit| { &mut m.Soft },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<POSIXRlimit>(
                    "POSIXRlimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static POSIXRlimit {
        static mut instance: ::protobuf::lazy::Lazy<POSIXRlimit> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(POSIXRlimit::new)
        }
    }
}

impl ::protobuf::Clear for POSIXRlimit {
    fn clear(&mut self) {
        self.Type.clear();
        self.Hard = 0;
        self.Soft = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for POSIXRlimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for POSIXRlimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mount {
    // message fields
    pub destination: ::std::string::String,
    pub source: ::std::string::String,
    pub field_type: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mount {
    fn default() -> &'a Mount {
        <Mount as ::protobuf::Message>::default_instance()
    }
}

impl Mount {
    pub fn new() -> Mount {
        ::std::default::Default::default()
    }

    // string destination = 1;


    pub fn get_destination(&self) -> &str {
        &self.destination
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    // string source = 2;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // repeated string options = 4;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Mount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.source.is_empty() {
            os.write_string(2, &self.source)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        for v in &self.options {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mount {
        Mount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination",
                    |m: &Mount| { &m.destination },
                    |m: &mut Mount| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &Mount| { &m.source },
                    |m: &mut Mount| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Mount| { &m.field_type },
                    |m: &mut Mount| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &Mount| { &m.options },
                    |m: &mut Mount| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mount>(
                    "Mount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Mount {
        static mut instance: ::protobuf::lazy::Lazy<Mount> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Mount::new)
        }
    }
}

impl ::protobuf::Clear for Mount {
    fn clear(&mut self) {
        self.destination.clear();
        self.source.clear();
        self.field_type.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Root {
    // message fields
    pub Path: ::std::string::String,
    pub Readonly: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Root {
    fn default() -> &'a Root {
        <Root as ::protobuf::Message>::default_instance()
    }
}

impl Root {
    pub fn new() -> Root {
        ::std::default::Default::default()
    }

    // string Path = 1;


    pub fn get_Path(&self) -> &str {
        &self.Path
    }
    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // bool Readonly = 2;


    pub fn get_Readonly(&self) -> bool {
        self.Readonly
    }
    pub fn clear_Readonly(&mut self) {
        self.Readonly = false;
    }

    // Param is passed by value, moved
    pub fn set_Readonly(&mut self, v: bool) {
        self.Readonly = v;
    }
}

impl ::protobuf::Message for Root {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Readonly = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        if self.Readonly != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        if self.Readonly != false {
            os.write_bool(2, self.Readonly)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Root {
        Root::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Path",
                    |m: &Root| { &m.Path },
                    |m: &mut Root| { &mut m.Path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Readonly",
                    |m: &Root| { &m.Readonly },
                    |m: &mut Root| { &mut m.Readonly },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Root>(
                    "Root",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Root {
        static mut instance: ::protobuf::lazy::Lazy<Root> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Root::new)
        }
    }
}

impl ::protobuf::Clear for Root {
    fn clear(&mut self) {
        self.Path.clear();
        self.Readonly = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Root {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Root {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hooks {
    // message fields
    pub Prestart: ::protobuf::RepeatedField<Hook>,
    pub Poststart: ::protobuf::RepeatedField<Hook>,
    pub Poststop: ::protobuf::RepeatedField<Hook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hooks {
    fn default() -> &'a Hooks {
        <Hooks as ::protobuf::Message>::default_instance()
    }
}

impl Hooks {
    pub fn new() -> Hooks {
        ::std::default::Default::default()
    }

    // repeated .grpc.Hook Prestart = 1;


    pub fn get_Prestart(&self) -> &[Hook] {
        &self.Prestart
    }
    pub fn clear_Prestart(&mut self) {
        self.Prestart.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prestart(&mut self, v: ::protobuf::RepeatedField<Hook>) {
        self.Prestart = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Prestart(&mut self) -> &mut ::protobuf::RepeatedField<Hook> {
        &mut self.Prestart
    }

    // Take field
    pub fn take_Prestart(&mut self) -> ::protobuf::RepeatedField<Hook> {
        ::std::mem::replace(&mut self.Prestart, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Hook Poststart = 2;


    pub fn get_Poststart(&self) -> &[Hook] {
        &self.Poststart
    }
    pub fn clear_Poststart(&mut self) {
        self.Poststart.clear();
    }

    // Param is passed by value, moved
    pub fn set_Poststart(&mut self, v: ::protobuf::RepeatedField<Hook>) {
        self.Poststart = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Poststart(&mut self) -> &mut ::protobuf::RepeatedField<Hook> {
        &mut self.Poststart
    }

    // Take field
    pub fn take_Poststart(&mut self) -> ::protobuf::RepeatedField<Hook> {
        ::std::mem::replace(&mut self.Poststart, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Hook Poststop = 3;


    pub fn get_Poststop(&self) -> &[Hook] {
        &self.Poststop
    }
    pub fn clear_Poststop(&mut self) {
        self.Poststop.clear();
    }

    // Param is passed by value, moved
    pub fn set_Poststop(&mut self, v: ::protobuf::RepeatedField<Hook>) {
        self.Poststop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Poststop(&mut self) -> &mut ::protobuf::RepeatedField<Hook> {
        &mut self.Poststop
    }

    // Take field
    pub fn take_Poststop(&mut self) -> ::protobuf::RepeatedField<Hook> {
        ::std::mem::replace(&mut self.Poststop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Hooks {
    fn is_initialized(&self) -> bool {
        for v in &self.Prestart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Poststart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Poststop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Prestart)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Poststart)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Poststop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Prestart {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Poststart {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Poststop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Prestart {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Poststart {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Poststop {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hooks {
        Hooks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hook>>(
                    "Prestart",
                    |m: &Hooks| { &m.Prestart },
                    |m: &mut Hooks| { &mut m.Prestart },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hook>>(
                    "Poststart",
                    |m: &Hooks| { &m.Poststart },
                    |m: &mut Hooks| { &mut m.Poststart },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hook>>(
                    "Poststop",
                    |m: &Hooks| { &m.Poststop },
                    |m: &mut Hooks| { &mut m.Poststop },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hooks>(
                    "Hooks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hooks {
        static mut instance: ::protobuf::lazy::Lazy<Hooks> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Hooks::new)
        }
    }
}

impl ::protobuf::Clear for Hooks {
    fn clear(&mut self) {
        self.Prestart.clear();
        self.Poststart.clear();
        self.Poststop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hooks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hooks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hook {
    // message fields
    pub Path: ::std::string::String,
    pub Args: ::protobuf::RepeatedField<::std::string::String>,
    pub Env: ::protobuf::RepeatedField<::std::string::String>,
    pub Timeout: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hook {
    fn default() -> &'a Hook {
        <Hook as ::protobuf::Message>::default_instance()
    }
}

impl Hook {
    pub fn new() -> Hook {
        ::std::default::Default::default()
    }

    // string Path = 1;


    pub fn get_Path(&self) -> &str {
        &self.Path
    }
    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // repeated string Args = 2;


    pub fn get_Args(&self) -> &[::std::string::String] {
        &self.Args
    }
    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Args, ::protobuf::RepeatedField::new())
    }

    // repeated string Env = 3;


    pub fn get_Env(&self) -> &[::std::string::String] {
        &self.Env
    }
    pub fn clear_Env(&mut self) {
        self.Env.clear();
    }

    // Param is passed by value, moved
    pub fn set_Env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Env
    }

    // Take field
    pub fn take_Env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Env, ::protobuf::RepeatedField::new())
    }

    // int64 Timeout = 4;


    pub fn get_Timeout(&self) -> i64 {
        self.Timeout
    }
    pub fn clear_Timeout(&mut self) {
        self.Timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_Timeout(&mut self, v: i64) {
        self.Timeout = v;
    }
}

impl ::protobuf::Message for Hook {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Path)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Args)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Env)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        for value in &self.Args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Env {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.Timeout != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        for v in &self.Args {
            os.write_string(2, &v)?;
        };
        for v in &self.Env {
            os.write_string(3, &v)?;
        };
        if self.Timeout != 0 {
            os.write_int64(4, self.Timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hook {
        Hook::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Path",
                    |m: &Hook| { &m.Path },
                    |m: &mut Hook| { &mut m.Path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Args",
                    |m: &Hook| { &m.Args },
                    |m: &mut Hook| { &mut m.Args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Env",
                    |m: &Hook| { &m.Env },
                    |m: &mut Hook| { &mut m.Env },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Timeout",
                    |m: &Hook| { &m.Timeout },
                    |m: &mut Hook| { &mut m.Timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hook>(
                    "Hook",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hook {
        static mut instance: ::protobuf::lazy::Lazy<Hook> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Hook::new)
        }
    }
}

impl ::protobuf::Clear for Hook {
    fn clear(&mut self) {
        self.Path.clear();
        self.Args.clear();
        self.Env.clear();
        self.Timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Linux {
    // message fields
    pub UIDMappings: ::protobuf::RepeatedField<LinuxIDMapping>,
    pub GIDMappings: ::protobuf::RepeatedField<LinuxIDMapping>,
    pub Sysctl: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub Resources: ::protobuf::SingularPtrField<LinuxResources>,
    pub CgroupsPath: ::std::string::String,
    pub Namespaces: ::protobuf::RepeatedField<LinuxNamespace>,
    pub Devices: ::protobuf::RepeatedField<LinuxDevice>,
    pub Seccomp: ::protobuf::SingularPtrField<LinuxSeccomp>,
    pub RootfsPropagation: ::std::string::String,
    pub MaskedPaths: ::protobuf::RepeatedField<::std::string::String>,
    pub ReadonlyPaths: ::protobuf::RepeatedField<::std::string::String>,
    pub MountLabel: ::std::string::String,
    pub IntelRdt: ::protobuf::SingularPtrField<LinuxIntelRdt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Linux {
    fn default() -> &'a Linux {
        <Linux as ::protobuf::Message>::default_instance()
    }
}

impl Linux {
    pub fn new() -> Linux {
        ::std::default::Default::default()
    }

    // repeated .grpc.LinuxIDMapping UIDMappings = 1;


    pub fn get_UIDMappings(&self) -> &[LinuxIDMapping] {
        &self.UIDMappings
    }
    pub fn clear_UIDMappings(&mut self) {
        self.UIDMappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_UIDMappings(&mut self, v: ::protobuf::RepeatedField<LinuxIDMapping>) {
        self.UIDMappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_UIDMappings(&mut self) -> &mut ::protobuf::RepeatedField<LinuxIDMapping> {
        &mut self.UIDMappings
    }

    // Take field
    pub fn take_UIDMappings(&mut self) -> ::protobuf::RepeatedField<LinuxIDMapping> {
        ::std::mem::replace(&mut self.UIDMappings, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxIDMapping GIDMappings = 2;


    pub fn get_GIDMappings(&self) -> &[LinuxIDMapping] {
        &self.GIDMappings
    }
    pub fn clear_GIDMappings(&mut self) {
        self.GIDMappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_GIDMappings(&mut self, v: ::protobuf::RepeatedField<LinuxIDMapping>) {
        self.GIDMappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_GIDMappings(&mut self) -> &mut ::protobuf::RepeatedField<LinuxIDMapping> {
        &mut self.GIDMappings
    }

    // Take field
    pub fn take_GIDMappings(&mut self) -> ::protobuf::RepeatedField<LinuxIDMapping> {
        ::std::mem::replace(&mut self.GIDMappings, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.Linux.SysctlEntry Sysctl = 3;


    pub fn get_Sysctl(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.Sysctl
    }
    pub fn clear_Sysctl(&mut self) {
        self.Sysctl.clear();
    }

    // Param is passed by value, moved
    pub fn set_Sysctl(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.Sysctl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Sysctl(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.Sysctl
    }

    // Take field
    pub fn take_Sysctl(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.Sysctl, ::std::collections::HashMap::new())
    }

    // .grpc.LinuxResources Resources = 4;


    pub fn get_Resources(&self) -> &LinuxResources {
        self.Resources.as_ref().unwrap_or_else(|| LinuxResources::default_instance())
    }
    pub fn clear_Resources(&mut self) {
        self.Resources.clear();
    }

    pub fn has_Resources(&self) -> bool {
        self.Resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Resources(&mut self, v: LinuxResources) {
        self.Resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Resources(&mut self) -> &mut LinuxResources {
        if self.Resources.is_none() {
            self.Resources.set_default();
        }
        self.Resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_Resources(&mut self) -> LinuxResources {
        self.Resources.take().unwrap_or_else(|| LinuxResources::new())
    }

    // string CgroupsPath = 5;


    pub fn get_CgroupsPath(&self) -> &str {
        &self.CgroupsPath
    }
    pub fn clear_CgroupsPath(&mut self) {
        self.CgroupsPath.clear();
    }

    // Param is passed by value, moved
    pub fn set_CgroupsPath(&mut self, v: ::std::string::String) {
        self.CgroupsPath = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CgroupsPath(&mut self) -> &mut ::std::string::String {
        &mut self.CgroupsPath
    }

    // Take field
    pub fn take_CgroupsPath(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CgroupsPath, ::std::string::String::new())
    }

    // repeated .grpc.LinuxNamespace Namespaces = 6;


    pub fn get_Namespaces(&self) -> &[LinuxNamespace] {
        &self.Namespaces
    }
    pub fn clear_Namespaces(&mut self) {
        self.Namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Namespaces(&mut self, v: ::protobuf::RepeatedField<LinuxNamespace>) {
        self.Namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Namespaces(&mut self) -> &mut ::protobuf::RepeatedField<LinuxNamespace> {
        &mut self.Namespaces
    }

    // Take field
    pub fn take_Namespaces(&mut self) -> ::protobuf::RepeatedField<LinuxNamespace> {
        ::std::mem::replace(&mut self.Namespaces, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxDevice Devices = 7;


    pub fn get_Devices(&self) -> &[LinuxDevice] {
        &self.Devices
    }
    pub fn clear_Devices(&mut self) {
        self.Devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_Devices(&mut self, v: ::protobuf::RepeatedField<LinuxDevice>) {
        self.Devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Devices(&mut self) -> &mut ::protobuf::RepeatedField<LinuxDevice> {
        &mut self.Devices
    }

    // Take field
    pub fn take_Devices(&mut self) -> ::protobuf::RepeatedField<LinuxDevice> {
        ::std::mem::replace(&mut self.Devices, ::protobuf::RepeatedField::new())
    }

    // .grpc.LinuxSeccomp Seccomp = 8;


    pub fn get_Seccomp(&self) -> &LinuxSeccomp {
        self.Seccomp.as_ref().unwrap_or_else(|| LinuxSeccomp::default_instance())
    }
    pub fn clear_Seccomp(&mut self) {
        self.Seccomp.clear();
    }

    pub fn has_Seccomp(&self) -> bool {
        self.Seccomp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Seccomp(&mut self, v: LinuxSeccomp) {
        self.Seccomp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Seccomp(&mut self) -> &mut LinuxSeccomp {
        if self.Seccomp.is_none() {
            self.Seccomp.set_default();
        }
        self.Seccomp.as_mut().unwrap()
    }

    // Take field
    pub fn take_Seccomp(&mut self) -> LinuxSeccomp {
        self.Seccomp.take().unwrap_or_else(|| LinuxSeccomp::new())
    }

    // string RootfsPropagation = 9;


    pub fn get_RootfsPropagation(&self) -> &str {
        &self.RootfsPropagation
    }
    pub fn clear_RootfsPropagation(&mut self) {
        self.RootfsPropagation.clear();
    }

    // Param is passed by value, moved
    pub fn set_RootfsPropagation(&mut self, v: ::std::string::String) {
        self.RootfsPropagation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RootfsPropagation(&mut self) -> &mut ::std::string::String {
        &mut self.RootfsPropagation
    }

    // Take field
    pub fn take_RootfsPropagation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.RootfsPropagation, ::std::string::String::new())
    }

    // repeated string MaskedPaths = 10;


    pub fn get_MaskedPaths(&self) -> &[::std::string::String] {
        &self.MaskedPaths
    }
    pub fn clear_MaskedPaths(&mut self) {
        self.MaskedPaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_MaskedPaths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.MaskedPaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MaskedPaths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.MaskedPaths
    }

    // Take field
    pub fn take_MaskedPaths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.MaskedPaths, ::protobuf::RepeatedField::new())
    }

    // repeated string ReadonlyPaths = 11;


    pub fn get_ReadonlyPaths(&self) -> &[::std::string::String] {
        &self.ReadonlyPaths
    }
    pub fn clear_ReadonlyPaths(&mut self) {
        self.ReadonlyPaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_ReadonlyPaths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ReadonlyPaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ReadonlyPaths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ReadonlyPaths
    }

    // Take field
    pub fn take_ReadonlyPaths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ReadonlyPaths, ::protobuf::RepeatedField::new())
    }

    // string MountLabel = 12;


    pub fn get_MountLabel(&self) -> &str {
        &self.MountLabel
    }
    pub fn clear_MountLabel(&mut self) {
        self.MountLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_MountLabel(&mut self, v: ::std::string::String) {
        self.MountLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MountLabel(&mut self) -> &mut ::std::string::String {
        &mut self.MountLabel
    }

    // Take field
    pub fn take_MountLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.MountLabel, ::std::string::String::new())
    }

    // .grpc.LinuxIntelRdt IntelRdt = 13;


    pub fn get_IntelRdt(&self) -> &LinuxIntelRdt {
        self.IntelRdt.as_ref().unwrap_or_else(|| LinuxIntelRdt::default_instance())
    }
    pub fn clear_IntelRdt(&mut self) {
        self.IntelRdt.clear();
    }

    pub fn has_IntelRdt(&self) -> bool {
        self.IntelRdt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IntelRdt(&mut self, v: LinuxIntelRdt) {
        self.IntelRdt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IntelRdt(&mut self) -> &mut LinuxIntelRdt {
        if self.IntelRdt.is_none() {
            self.IntelRdt.set_default();
        }
        self.IntelRdt.as_mut().unwrap()
    }

    // Take field
    pub fn take_IntelRdt(&mut self) -> LinuxIntelRdt {
        self.IntelRdt.take().unwrap_or_else(|| LinuxIntelRdt::new())
    }
}

impl ::protobuf::Message for Linux {
    fn is_initialized(&self) -> bool {
        for v in &self.UIDMappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GIDMappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Namespaces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Seccomp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.IntelRdt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.UIDMappings)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.GIDMappings)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.Sysctl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Resources)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CgroupsPath)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Namespaces)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Devices)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Seccomp)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.RootfsPropagation)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.MaskedPaths)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ReadonlyPaths)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.MountLabel)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.IntelRdt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.UIDMappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.GIDMappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.Sysctl);
        if let Some(ref v) = self.Resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.CgroupsPath.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CgroupsPath);
        }
        for value in &self.Namespaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Seccomp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.RootfsPropagation.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.RootfsPropagation);
        }
        for value in &self.MaskedPaths {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.ReadonlyPaths {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if !self.MountLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.MountLabel);
        }
        if let Some(ref v) = self.IntelRdt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.UIDMappings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.GIDMappings {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.Sysctl, os)?;
        if let Some(ref v) = self.Resources.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.CgroupsPath.is_empty() {
            os.write_string(5, &self.CgroupsPath)?;
        }
        for v in &self.Namespaces {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Devices {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Seccomp.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.RootfsPropagation.is_empty() {
            os.write_string(9, &self.RootfsPropagation)?;
        }
        for v in &self.MaskedPaths {
            os.write_string(10, &v)?;
        };
        for v in &self.ReadonlyPaths {
            os.write_string(11, &v)?;
        };
        if !self.MountLabel.is_empty() {
            os.write_string(12, &self.MountLabel)?;
        }
        if let Some(ref v) = self.IntelRdt.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Linux {
        Linux::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxIDMapping>>(
                    "UIDMappings",
                    |m: &Linux| { &m.UIDMappings },
                    |m: &mut Linux| { &mut m.UIDMappings },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxIDMapping>>(
                    "GIDMappings",
                    |m: &Linux| { &m.GIDMappings },
                    |m: &mut Linux| { &mut m.GIDMappings },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "Sysctl",
                    |m: &Linux| { &m.Sysctl },
                    |m: &mut Linux| { &mut m.Sysctl },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxResources>>(
                    "Resources",
                    |m: &Linux| { &m.Resources },
                    |m: &mut Linux| { &mut m.Resources },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "CgroupsPath",
                    |m: &Linux| { &m.CgroupsPath },
                    |m: &mut Linux| { &mut m.CgroupsPath },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxNamespace>>(
                    "Namespaces",
                    |m: &Linux| { &m.Namespaces },
                    |m: &mut Linux| { &mut m.Namespaces },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxDevice>>(
                    "Devices",
                    |m: &Linux| { &m.Devices },
                    |m: &mut Linux| { &mut m.Devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxSeccomp>>(
                    "Seccomp",
                    |m: &Linux| { &m.Seccomp },
                    |m: &mut Linux| { &mut m.Seccomp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RootfsPropagation",
                    |m: &Linux| { &m.RootfsPropagation },
                    |m: &mut Linux| { &mut m.RootfsPropagation },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "MaskedPaths",
                    |m: &Linux| { &m.MaskedPaths },
                    |m: &mut Linux| { &mut m.MaskedPaths },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ReadonlyPaths",
                    |m: &Linux| { &m.ReadonlyPaths },
                    |m: &mut Linux| { &mut m.ReadonlyPaths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "MountLabel",
                    |m: &Linux| { &m.MountLabel },
                    |m: &mut Linux| { &mut m.MountLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxIntelRdt>>(
                    "IntelRdt",
                    |m: &Linux| { &m.IntelRdt },
                    |m: &mut Linux| { &mut m.IntelRdt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Linux>(
                    "Linux",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Linux {
        static mut instance: ::protobuf::lazy::Lazy<Linux> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Linux::new)
        }
    }
}

impl ::protobuf::Clear for Linux {
    fn clear(&mut self) {
        self.UIDMappings.clear();
        self.GIDMappings.clear();
        self.Sysctl.clear();
        self.Resources.clear();
        self.CgroupsPath.clear();
        self.Namespaces.clear();
        self.Devices.clear();
        self.Seccomp.clear();
        self.RootfsPropagation.clear();
        self.MaskedPaths.clear();
        self.ReadonlyPaths.clear();
        self.MountLabel.clear();
        self.IntelRdt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Linux {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Linux {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Windows {
    // message fields
    pub dummy: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Windows {
    fn default() -> &'a Windows {
        <Windows as ::protobuf::Message>::default_instance()
    }
}

impl Windows {
    pub fn new() -> Windows {
        ::std::default::Default::default()
    }

    // string dummy = 1;


    pub fn get_dummy(&self) -> &str {
        &self.dummy
    }
    pub fn clear_dummy(&mut self) {
        self.dummy.clear();
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: ::std::string::String) {
        self.dummy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy(&mut self) -> &mut ::std::string::String {
        &mut self.dummy
    }

    // Take field
    pub fn take_dummy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dummy, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Windows {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dummy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dummy.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dummy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dummy.is_empty() {
            os.write_string(1, &self.dummy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Windows {
        Windows::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dummy",
                    |m: &Windows| { &m.dummy },
                    |m: &mut Windows| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Windows>(
                    "Windows",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Windows {
        static mut instance: ::protobuf::lazy::Lazy<Windows> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Windows::new)
        }
    }
}

impl ::protobuf::Clear for Windows {
    fn clear(&mut self) {
        self.dummy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Windows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Windows {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Solaris {
    // message fields
    pub dummy: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Solaris {
    fn default() -> &'a Solaris {
        <Solaris as ::protobuf::Message>::default_instance()
    }
}

impl Solaris {
    pub fn new() -> Solaris {
        ::std::default::Default::default()
    }

    // string dummy = 1;


    pub fn get_dummy(&self) -> &str {
        &self.dummy
    }
    pub fn clear_dummy(&mut self) {
        self.dummy.clear();
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: ::std::string::String) {
        self.dummy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy(&mut self) -> &mut ::std::string::String {
        &mut self.dummy
    }

    // Take field
    pub fn take_dummy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dummy, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Solaris {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dummy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dummy.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dummy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dummy.is_empty() {
            os.write_string(1, &self.dummy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Solaris {
        Solaris::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dummy",
                    |m: &Solaris| { &m.dummy },
                    |m: &mut Solaris| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Solaris>(
                    "Solaris",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Solaris {
        static mut instance: ::protobuf::lazy::Lazy<Solaris> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Solaris::new)
        }
    }
}

impl ::protobuf::Clear for Solaris {
    fn clear(&mut self) {
        self.dummy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Solaris {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Solaris {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxIDMapping {
    // message fields
    pub HostID: u32,
    pub ContainerID: u32,
    pub Size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxIDMapping {
    fn default() -> &'a LinuxIDMapping {
        <LinuxIDMapping as ::protobuf::Message>::default_instance()
    }
}

impl LinuxIDMapping {
    pub fn new() -> LinuxIDMapping {
        ::std::default::Default::default()
    }

    // uint32 HostID = 1;


    pub fn get_HostID(&self) -> u32 {
        self.HostID
    }
    pub fn clear_HostID(&mut self) {
        self.HostID = 0;
    }

    // Param is passed by value, moved
    pub fn set_HostID(&mut self, v: u32) {
        self.HostID = v;
    }

    // uint32 ContainerID = 2;


    pub fn get_ContainerID(&self) -> u32 {
        self.ContainerID
    }
    pub fn clear_ContainerID(&mut self) {
        self.ContainerID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ContainerID(&mut self, v: u32) {
        self.ContainerID = v;
    }

    // uint32 Size = 3;


    pub fn get_Size(&self) -> u32 {
        self.Size
    }
    pub fn clear_Size(&mut self) {
        self.Size = 0;
    }

    // Param is passed by value, moved
    pub fn set_Size(&mut self, v: u32) {
        self.Size = v;
    }
}

impl ::protobuf::Message for LinuxIDMapping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.HostID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ContainerID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.HostID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.HostID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ContainerID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ContainerID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.HostID != 0 {
            os.write_uint32(1, self.HostID)?;
        }
        if self.ContainerID != 0 {
            os.write_uint32(2, self.ContainerID)?;
        }
        if self.Size != 0 {
            os.write_uint32(3, self.Size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxIDMapping {
        LinuxIDMapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "HostID",
                    |m: &LinuxIDMapping| { &m.HostID },
                    |m: &mut LinuxIDMapping| { &mut m.HostID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ContainerID",
                    |m: &LinuxIDMapping| { &m.ContainerID },
                    |m: &mut LinuxIDMapping| { &mut m.ContainerID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Size",
                    |m: &LinuxIDMapping| { &m.Size },
                    |m: &mut LinuxIDMapping| { &mut m.Size },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxIDMapping>(
                    "LinuxIDMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxIDMapping {
        static mut instance: ::protobuf::lazy::Lazy<LinuxIDMapping> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxIDMapping::new)
        }
    }
}

impl ::protobuf::Clear for LinuxIDMapping {
    fn clear(&mut self) {
        self.HostID = 0;
        self.ContainerID = 0;
        self.Size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxIDMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxIDMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxNamespace {
    // message fields
    pub Type: ::std::string::String,
    pub Path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxNamespace {
    fn default() -> &'a LinuxNamespace {
        <LinuxNamespace as ::protobuf::Message>::default_instance()
    }
}

impl LinuxNamespace {
    pub fn new() -> LinuxNamespace {
        ::std::default::Default::default()
    }

    // string Type = 1;


    pub fn get_Type(&self) -> &str {
        &self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // string Path = 2;


    pub fn get_Path(&self) -> &str {
        &self.Path
    }
    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxNamespace {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Type);
        }
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Type.is_empty() {
            os.write_string(1, &self.Type)?;
        }
        if !self.Path.is_empty() {
            os.write_string(2, &self.Path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxNamespace {
        LinuxNamespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Type",
                    |m: &LinuxNamespace| { &m.Type },
                    |m: &mut LinuxNamespace| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Path",
                    |m: &LinuxNamespace| { &m.Path },
                    |m: &mut LinuxNamespace| { &mut m.Path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxNamespace>(
                    "LinuxNamespace",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxNamespace {
        static mut instance: ::protobuf::lazy::Lazy<LinuxNamespace> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxNamespace::new)
        }
    }
}

impl ::protobuf::Clear for LinuxNamespace {
    fn clear(&mut self) {
        self.Type.clear();
        self.Path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxNamespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxNamespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxDevice {
    // message fields
    pub Path: ::std::string::String,
    pub Type: ::std::string::String,
    pub Major: i64,
    pub Minor: i64,
    pub FileMode: u32,
    pub UID: u32,
    pub GID: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxDevice {
    fn default() -> &'a LinuxDevice {
        <LinuxDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxDevice {
    pub fn new() -> LinuxDevice {
        ::std::default::Default::default()
    }

    // string Path = 1;


    pub fn get_Path(&self) -> &str {
        &self.Path
    }
    pub fn clear_Path(&mut self) {
        self.Path.clear();
    }

    // Param is passed by value, moved
    pub fn set_Path(&mut self, v: ::std::string::String) {
        self.Path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Path(&mut self) -> &mut ::std::string::String {
        &mut self.Path
    }

    // Take field
    pub fn take_Path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Path, ::std::string::String::new())
    }

    // string Type = 2;


    pub fn get_Type(&self) -> &str {
        &self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // int64 Major = 3;


    pub fn get_Major(&self) -> i64 {
        self.Major
    }
    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 4;


    pub fn get_Minor(&self) -> i64 {
        self.Minor
    }
    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint32 FileMode = 5;


    pub fn get_FileMode(&self) -> u32 {
        self.FileMode
    }
    pub fn clear_FileMode(&mut self) {
        self.FileMode = 0;
    }

    // Param is passed by value, moved
    pub fn set_FileMode(&mut self, v: u32) {
        self.FileMode = v;
    }

    // uint32 UID = 6;


    pub fn get_UID(&self) -> u32 {
        self.UID
    }
    pub fn clear_UID(&mut self) {
        self.UID = 0;
    }

    // Param is passed by value, moved
    pub fn set_UID(&mut self, v: u32) {
        self.UID = v;
    }

    // uint32 GID = 7;


    pub fn get_GID(&self) -> u32 {
        self.GID
    }
    pub fn clear_GID(&mut self) {
        self.GID = 0;
    }

    // Param is passed by value, moved
    pub fn set_GID(&mut self, v: u32) {
        self.GID = v;
    }
}

impl ::protobuf::Message for LinuxDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Major = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Minor = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.FileMode = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.UID = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.GID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Path);
        }
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Type);
        }
        if self.Major != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.FileMode != 0 {
            my_size += ::protobuf::rt::value_size(5, self.FileMode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.UID != 0 {
            my_size += ::protobuf::rt::value_size(6, self.UID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GID != 0 {
            my_size += ::protobuf::rt::value_size(7, self.GID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Path.is_empty() {
            os.write_string(1, &self.Path)?;
        }
        if !self.Type.is_empty() {
            os.write_string(2, &self.Type)?;
        }
        if self.Major != 0 {
            os.write_int64(3, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(4, self.Minor)?;
        }
        if self.FileMode != 0 {
            os.write_uint32(5, self.FileMode)?;
        }
        if self.UID != 0 {
            os.write_uint32(6, self.UID)?;
        }
        if self.GID != 0 {
            os.write_uint32(7, self.GID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxDevice {
        LinuxDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Path",
                    |m: &LinuxDevice| { &m.Path },
                    |m: &mut LinuxDevice| { &mut m.Path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Type",
                    |m: &LinuxDevice| { &m.Type },
                    |m: &mut LinuxDevice| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Major",
                    |m: &LinuxDevice| { &m.Major },
                    |m: &mut LinuxDevice| { &mut m.Major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Minor",
                    |m: &LinuxDevice| { &m.Minor },
                    |m: &mut LinuxDevice| { &mut m.Minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "FileMode",
                    |m: &LinuxDevice| { &m.FileMode },
                    |m: &mut LinuxDevice| { &mut m.FileMode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "UID",
                    |m: &LinuxDevice| { &m.UID },
                    |m: &mut LinuxDevice| { &mut m.UID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "GID",
                    |m: &LinuxDevice| { &m.GID },
                    |m: &mut LinuxDevice| { &mut m.GID },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxDevice>(
                    "LinuxDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxDevice {
        static mut instance: ::protobuf::lazy::Lazy<LinuxDevice> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxDevice::new)
        }
    }
}

impl ::protobuf::Clear for LinuxDevice {
    fn clear(&mut self) {
        self.Path.clear();
        self.Type.clear();
        self.Major = 0;
        self.Minor = 0;
        self.FileMode = 0;
        self.UID = 0;
        self.GID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxResources {
    // message fields
    pub Devices: ::protobuf::RepeatedField<LinuxDeviceCgroup>,
    pub Memory: ::protobuf::SingularPtrField<LinuxMemory>,
    pub CPU: ::protobuf::SingularPtrField<LinuxCPU>,
    pub Pids: ::protobuf::SingularPtrField<LinuxPids>,
    pub BlockIO: ::protobuf::SingularPtrField<LinuxBlockIO>,
    pub HugepageLimits: ::protobuf::RepeatedField<LinuxHugepageLimit>,
    pub Network: ::protobuf::SingularPtrField<LinuxNetwork>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxResources {
    fn default() -> &'a LinuxResources {
        <LinuxResources as ::protobuf::Message>::default_instance()
    }
}

impl LinuxResources {
    pub fn new() -> LinuxResources {
        ::std::default::Default::default()
    }

    // repeated .grpc.LinuxDeviceCgroup Devices = 1;


    pub fn get_Devices(&self) -> &[LinuxDeviceCgroup] {
        &self.Devices
    }
    pub fn clear_Devices(&mut self) {
        self.Devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_Devices(&mut self, v: ::protobuf::RepeatedField<LinuxDeviceCgroup>) {
        self.Devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Devices(&mut self) -> &mut ::protobuf::RepeatedField<LinuxDeviceCgroup> {
        &mut self.Devices
    }

    // Take field
    pub fn take_Devices(&mut self) -> ::protobuf::RepeatedField<LinuxDeviceCgroup> {
        ::std::mem::replace(&mut self.Devices, ::protobuf::RepeatedField::new())
    }

    // .grpc.LinuxMemory Memory = 2;


    pub fn get_Memory(&self) -> &LinuxMemory {
        self.Memory.as_ref().unwrap_or_else(|| LinuxMemory::default_instance())
    }
    pub fn clear_Memory(&mut self) {
        self.Memory.clear();
    }

    pub fn has_Memory(&self) -> bool {
        self.Memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Memory(&mut self, v: LinuxMemory) {
        self.Memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Memory(&mut self) -> &mut LinuxMemory {
        if self.Memory.is_none() {
            self.Memory.set_default();
        }
        self.Memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_Memory(&mut self) -> LinuxMemory {
        self.Memory.take().unwrap_or_else(|| LinuxMemory::new())
    }

    // .grpc.LinuxCPU CPU = 3;


    pub fn get_CPU(&self) -> &LinuxCPU {
        self.CPU.as_ref().unwrap_or_else(|| LinuxCPU::default_instance())
    }
    pub fn clear_CPU(&mut self) {
        self.CPU.clear();
    }

    pub fn has_CPU(&self) -> bool {
        self.CPU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CPU(&mut self, v: LinuxCPU) {
        self.CPU = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CPU(&mut self) -> &mut LinuxCPU {
        if self.CPU.is_none() {
            self.CPU.set_default();
        }
        self.CPU.as_mut().unwrap()
    }

    // Take field
    pub fn take_CPU(&mut self) -> LinuxCPU {
        self.CPU.take().unwrap_or_else(|| LinuxCPU::new())
    }

    // .grpc.LinuxPids Pids = 4;


    pub fn get_Pids(&self) -> &LinuxPids {
        self.Pids.as_ref().unwrap_or_else(|| LinuxPids::default_instance())
    }
    pub fn clear_Pids(&mut self) {
        self.Pids.clear();
    }

    pub fn has_Pids(&self) -> bool {
        self.Pids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Pids(&mut self, v: LinuxPids) {
        self.Pids = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pids(&mut self) -> &mut LinuxPids {
        if self.Pids.is_none() {
            self.Pids.set_default();
        }
        self.Pids.as_mut().unwrap()
    }

    // Take field
    pub fn take_Pids(&mut self) -> LinuxPids {
        self.Pids.take().unwrap_or_else(|| LinuxPids::new())
    }

    // .grpc.LinuxBlockIO BlockIO = 5;


    pub fn get_BlockIO(&self) -> &LinuxBlockIO {
        self.BlockIO.as_ref().unwrap_or_else(|| LinuxBlockIO::default_instance())
    }
    pub fn clear_BlockIO(&mut self) {
        self.BlockIO.clear();
    }

    pub fn has_BlockIO(&self) -> bool {
        self.BlockIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BlockIO(&mut self, v: LinuxBlockIO) {
        self.BlockIO = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BlockIO(&mut self) -> &mut LinuxBlockIO {
        if self.BlockIO.is_none() {
            self.BlockIO.set_default();
        }
        self.BlockIO.as_mut().unwrap()
    }

    // Take field
    pub fn take_BlockIO(&mut self) -> LinuxBlockIO {
        self.BlockIO.take().unwrap_or_else(|| LinuxBlockIO::new())
    }

    // repeated .grpc.LinuxHugepageLimit HugepageLimits = 6;


    pub fn get_HugepageLimits(&self) -> &[LinuxHugepageLimit] {
        &self.HugepageLimits
    }
    pub fn clear_HugepageLimits(&mut self) {
        self.HugepageLimits.clear();
    }

    // Param is passed by value, moved
    pub fn set_HugepageLimits(&mut self, v: ::protobuf::RepeatedField<LinuxHugepageLimit>) {
        self.HugepageLimits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HugepageLimits(&mut self) -> &mut ::protobuf::RepeatedField<LinuxHugepageLimit> {
        &mut self.HugepageLimits
    }

    // Take field
    pub fn take_HugepageLimits(&mut self) -> ::protobuf::RepeatedField<LinuxHugepageLimit> {
        ::std::mem::replace(&mut self.HugepageLimits, ::protobuf::RepeatedField::new())
    }

    // .grpc.LinuxNetwork Network = 7;


    pub fn get_Network(&self) -> &LinuxNetwork {
        self.Network.as_ref().unwrap_or_else(|| LinuxNetwork::default_instance())
    }
    pub fn clear_Network(&mut self) {
        self.Network.clear();
    }

    pub fn has_Network(&self) -> bool {
        self.Network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Network(&mut self, v: LinuxNetwork) {
        self.Network = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Network(&mut self) -> &mut LinuxNetwork {
        if self.Network.is_none() {
            self.Network.set_default();
        }
        self.Network.as_mut().unwrap()
    }

    // Take field
    pub fn take_Network(&mut self) -> LinuxNetwork {
        self.Network.take().unwrap_or_else(|| LinuxNetwork::new())
    }
}

impl ::protobuf::Message for LinuxResources {
    fn is_initialized(&self) -> bool {
        for v in &self.Devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Memory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CPU {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Pids {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BlockIO {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HugepageLimits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Network {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Devices)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Memory)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CPU)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Pids)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BlockIO)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HugepageLimits)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Network)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CPU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Pids.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BlockIO.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.HugepageLimits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Devices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Memory.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CPU.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Pids.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BlockIO.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.HugepageLimits {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Network.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxResources {
        LinuxResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxDeviceCgroup>>(
                    "Devices",
                    |m: &LinuxResources| { &m.Devices },
                    |m: &mut LinuxResources| { &mut m.Devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxMemory>>(
                    "Memory",
                    |m: &LinuxResources| { &m.Memory },
                    |m: &mut LinuxResources| { &mut m.Memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxCPU>>(
                    "CPU",
                    |m: &LinuxResources| { &m.CPU },
                    |m: &mut LinuxResources| { &mut m.CPU },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxPids>>(
                    "Pids",
                    |m: &LinuxResources| { &m.Pids },
                    |m: &mut LinuxResources| { &mut m.Pids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxBlockIO>>(
                    "BlockIO",
                    |m: &LinuxResources| { &m.BlockIO },
                    |m: &mut LinuxResources| { &mut m.BlockIO },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxHugepageLimit>>(
                    "HugepageLimits",
                    |m: &LinuxResources| { &m.HugepageLimits },
                    |m: &mut LinuxResources| { &mut m.HugepageLimits },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxNetwork>>(
                    "Network",
                    |m: &LinuxResources| { &m.Network },
                    |m: &mut LinuxResources| { &mut m.Network },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxResources>(
                    "LinuxResources",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxResources {
        static mut instance: ::protobuf::lazy::Lazy<LinuxResources> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxResources::new)
        }
    }
}

impl ::protobuf::Clear for LinuxResources {
    fn clear(&mut self) {
        self.Devices.clear();
        self.Memory.clear();
        self.CPU.clear();
        self.Pids.clear();
        self.BlockIO.clear();
        self.HugepageLimits.clear();
        self.Network.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxMemory {
    // message fields
    pub Limit: i64,
    pub Reservation: i64,
    pub Swap: i64,
    pub Kernel: i64,
    pub KernelTCP: i64,
    pub Swappiness: u64,
    pub DisableOOMKiller: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxMemory {
    fn default() -> &'a LinuxMemory {
        <LinuxMemory as ::protobuf::Message>::default_instance()
    }
}

impl LinuxMemory {
    pub fn new() -> LinuxMemory {
        ::std::default::Default::default()
    }

    // int64 Limit = 1;


    pub fn get_Limit(&self) -> i64 {
        self.Limit
    }
    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: i64) {
        self.Limit = v;
    }

    // int64 Reservation = 2;


    pub fn get_Reservation(&self) -> i64 {
        self.Reservation
    }
    pub fn clear_Reservation(&mut self) {
        self.Reservation = 0;
    }

    // Param is passed by value, moved
    pub fn set_Reservation(&mut self, v: i64) {
        self.Reservation = v;
    }

    // int64 Swap = 3;


    pub fn get_Swap(&self) -> i64 {
        self.Swap
    }
    pub fn clear_Swap(&mut self) {
        self.Swap = 0;
    }

    // Param is passed by value, moved
    pub fn set_Swap(&mut self, v: i64) {
        self.Swap = v;
    }

    // int64 Kernel = 4;


    pub fn get_Kernel(&self) -> i64 {
        self.Kernel
    }
    pub fn clear_Kernel(&mut self) {
        self.Kernel = 0;
    }

    // Param is passed by value, moved
    pub fn set_Kernel(&mut self, v: i64) {
        self.Kernel = v;
    }

    // int64 KernelTCP = 5;


    pub fn get_KernelTCP(&self) -> i64 {
        self.KernelTCP
    }
    pub fn clear_KernelTCP(&mut self) {
        self.KernelTCP = 0;
    }

    // Param is passed by value, moved
    pub fn set_KernelTCP(&mut self, v: i64) {
        self.KernelTCP = v;
    }

    // uint64 Swappiness = 6;


    pub fn get_Swappiness(&self) -> u64 {
        self.Swappiness
    }
    pub fn clear_Swappiness(&mut self) {
        self.Swappiness = 0;
    }

    // Param is passed by value, moved
    pub fn set_Swappiness(&mut self, v: u64) {
        self.Swappiness = v;
    }

    // bool DisableOOMKiller = 7;


    pub fn get_DisableOOMKiller(&self) -> bool {
        self.DisableOOMKiller
    }
    pub fn clear_DisableOOMKiller(&mut self) {
        self.DisableOOMKiller = false;
    }

    // Param is passed by value, moved
    pub fn set_DisableOOMKiller(&mut self, v: bool) {
        self.DisableOOMKiller = v;
    }
}

impl ::protobuf::Message for LinuxMemory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Reservation = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Swap = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Kernel = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.KernelTCP = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Swappiness = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.DisableOOMKiller = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Reservation != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Reservation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Swap != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Swap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Kernel != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Kernel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.KernelTCP != 0 {
            my_size += ::protobuf::rt::value_size(5, self.KernelTCP, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Swappiness != 0 {
            my_size += ::protobuf::rt::value_size(6, self.Swappiness, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DisableOOMKiller != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Limit != 0 {
            os.write_int64(1, self.Limit)?;
        }
        if self.Reservation != 0 {
            os.write_int64(2, self.Reservation)?;
        }
        if self.Swap != 0 {
            os.write_int64(3, self.Swap)?;
        }
        if self.Kernel != 0 {
            os.write_int64(4, self.Kernel)?;
        }
        if self.KernelTCP != 0 {
            os.write_int64(5, self.KernelTCP)?;
        }
        if self.Swappiness != 0 {
            os.write_uint64(6, self.Swappiness)?;
        }
        if self.DisableOOMKiller != false {
            os.write_bool(7, self.DisableOOMKiller)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxMemory {
        LinuxMemory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Limit",
                    |m: &LinuxMemory| { &m.Limit },
                    |m: &mut LinuxMemory| { &mut m.Limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Reservation",
                    |m: &LinuxMemory| { &m.Reservation },
                    |m: &mut LinuxMemory| { &mut m.Reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Swap",
                    |m: &LinuxMemory| { &m.Swap },
                    |m: &mut LinuxMemory| { &mut m.Swap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Kernel",
                    |m: &LinuxMemory| { &m.Kernel },
                    |m: &mut LinuxMemory| { &mut m.Kernel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "KernelTCP",
                    |m: &LinuxMemory| { &m.KernelTCP },
                    |m: &mut LinuxMemory| { &mut m.KernelTCP },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Swappiness",
                    |m: &LinuxMemory| { &m.Swappiness },
                    |m: &mut LinuxMemory| { &mut m.Swappiness },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "DisableOOMKiller",
                    |m: &LinuxMemory| { &m.DisableOOMKiller },
                    |m: &mut LinuxMemory| { &mut m.DisableOOMKiller },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxMemory>(
                    "LinuxMemory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxMemory {
        static mut instance: ::protobuf::lazy::Lazy<LinuxMemory> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxMemory::new)
        }
    }
}

impl ::protobuf::Clear for LinuxMemory {
    fn clear(&mut self) {
        self.Limit = 0;
        self.Reservation = 0;
        self.Swap = 0;
        self.Kernel = 0;
        self.KernelTCP = 0;
        self.Swappiness = 0;
        self.DisableOOMKiller = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxMemory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxCPU {
    // message fields
    pub Shares: u64,
    pub Quota: i64,
    pub Period: u64,
    pub RealtimeRuntime: i64,
    pub RealtimePeriod: u64,
    pub Cpus: ::std::string::String,
    pub Mems: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxCPU {
    fn default() -> &'a LinuxCPU {
        <LinuxCPU as ::protobuf::Message>::default_instance()
    }
}

impl LinuxCPU {
    pub fn new() -> LinuxCPU {
        ::std::default::Default::default()
    }

    // uint64 Shares = 1;


    pub fn get_Shares(&self) -> u64 {
        self.Shares
    }
    pub fn clear_Shares(&mut self) {
        self.Shares = 0;
    }

    // Param is passed by value, moved
    pub fn set_Shares(&mut self, v: u64) {
        self.Shares = v;
    }

    // int64 Quota = 2;


    pub fn get_Quota(&self) -> i64 {
        self.Quota
    }
    pub fn clear_Quota(&mut self) {
        self.Quota = 0;
    }

    // Param is passed by value, moved
    pub fn set_Quota(&mut self, v: i64) {
        self.Quota = v;
    }

    // uint64 Period = 3;


    pub fn get_Period(&self) -> u64 {
        self.Period
    }
    pub fn clear_Period(&mut self) {
        self.Period = 0;
    }

    // Param is passed by value, moved
    pub fn set_Period(&mut self, v: u64) {
        self.Period = v;
    }

    // int64 RealtimeRuntime = 4;


    pub fn get_RealtimeRuntime(&self) -> i64 {
        self.RealtimeRuntime
    }
    pub fn clear_RealtimeRuntime(&mut self) {
        self.RealtimeRuntime = 0;
    }

    // Param is passed by value, moved
    pub fn set_RealtimeRuntime(&mut self, v: i64) {
        self.RealtimeRuntime = v;
    }

    // uint64 RealtimePeriod = 5;


    pub fn get_RealtimePeriod(&self) -> u64 {
        self.RealtimePeriod
    }
    pub fn clear_RealtimePeriod(&mut self) {
        self.RealtimePeriod = 0;
    }

    // Param is passed by value, moved
    pub fn set_RealtimePeriod(&mut self, v: u64) {
        self.RealtimePeriod = v;
    }

    // string Cpus = 6;


    pub fn get_Cpus(&self) -> &str {
        &self.Cpus
    }
    pub fn clear_Cpus(&mut self) {
        self.Cpus.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cpus(&mut self, v: ::std::string::String) {
        self.Cpus = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cpus(&mut self) -> &mut ::std::string::String {
        &mut self.Cpus
    }

    // Take field
    pub fn take_Cpus(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cpus, ::std::string::String::new())
    }

    // string Mems = 7;


    pub fn get_Mems(&self) -> &str {
        &self.Mems
    }
    pub fn clear_Mems(&mut self) {
        self.Mems.clear();
    }

    // Param is passed by value, moved
    pub fn set_Mems(&mut self, v: ::std::string::String) {
        self.Mems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Mems(&mut self) -> &mut ::std::string::String {
        &mut self.Mems
    }

    // Take field
    pub fn take_Mems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Mems, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxCPU {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Shares = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Quota = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Period = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.RealtimeRuntime = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.RealtimePeriod = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Cpus)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Mems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Shares != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Shares, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Quota != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Quota, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Period != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Period, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.RealtimeRuntime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.RealtimeRuntime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.RealtimePeriod != 0 {
            my_size += ::protobuf::rt::value_size(5, self.RealtimePeriod, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Cpus.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Cpus);
        }
        if !self.Mems.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.Mems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Shares != 0 {
            os.write_uint64(1, self.Shares)?;
        }
        if self.Quota != 0 {
            os.write_int64(2, self.Quota)?;
        }
        if self.Period != 0 {
            os.write_uint64(3, self.Period)?;
        }
        if self.RealtimeRuntime != 0 {
            os.write_int64(4, self.RealtimeRuntime)?;
        }
        if self.RealtimePeriod != 0 {
            os.write_uint64(5, self.RealtimePeriod)?;
        }
        if !self.Cpus.is_empty() {
            os.write_string(6, &self.Cpus)?;
        }
        if !self.Mems.is_empty() {
            os.write_string(7, &self.Mems)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxCPU {
        LinuxCPU::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Shares",
                    |m: &LinuxCPU| { &m.Shares },
                    |m: &mut LinuxCPU| { &mut m.Shares },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Quota",
                    |m: &LinuxCPU| { &m.Quota },
                    |m: &mut LinuxCPU| { &mut m.Quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Period",
                    |m: &LinuxCPU| { &m.Period },
                    |m: &mut LinuxCPU| { &mut m.Period },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "RealtimeRuntime",
                    |m: &LinuxCPU| { &m.RealtimeRuntime },
                    |m: &mut LinuxCPU| { &mut m.RealtimeRuntime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "RealtimePeriod",
                    |m: &LinuxCPU| { &m.RealtimePeriod },
                    |m: &mut LinuxCPU| { &mut m.RealtimePeriod },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Cpus",
                    |m: &LinuxCPU| { &m.Cpus },
                    |m: &mut LinuxCPU| { &mut m.Cpus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Mems",
                    |m: &LinuxCPU| { &m.Mems },
                    |m: &mut LinuxCPU| { &mut m.Mems },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxCPU>(
                    "LinuxCPU",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxCPU {
        static mut instance: ::protobuf::lazy::Lazy<LinuxCPU> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxCPU::new)
        }
    }
}

impl ::protobuf::Clear for LinuxCPU {
    fn clear(&mut self) {
        self.Shares = 0;
        self.Quota = 0;
        self.Period = 0;
        self.RealtimeRuntime = 0;
        self.RealtimePeriod = 0;
        self.Cpus.clear();
        self.Mems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxCPU {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxCPU {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxWeightDevice {
    // message fields
    pub Major: i64,
    pub Minor: i64,
    pub Weight: u32,
    pub LeafWeight: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxWeightDevice {
    fn default() -> &'a LinuxWeightDevice {
        <LinuxWeightDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxWeightDevice {
    pub fn new() -> LinuxWeightDevice {
        ::std::default::Default::default()
    }

    // int64 Major = 1;


    pub fn get_Major(&self) -> i64 {
        self.Major
    }
    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 2;


    pub fn get_Minor(&self) -> i64 {
        self.Minor
    }
    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint32 Weight = 3;


    pub fn get_Weight(&self) -> u32 {
        self.Weight
    }
    pub fn clear_Weight(&mut self) {
        self.Weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_Weight(&mut self, v: u32) {
        self.Weight = v;
    }

    // uint32 LeafWeight = 4;


    pub fn get_LeafWeight(&self) -> u32 {
        self.LeafWeight
    }
    pub fn clear_LeafWeight(&mut self) {
        self.LeafWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_LeafWeight(&mut self, v: u32) {
        self.LeafWeight = v;
    }
}

impl ::protobuf::Message for LinuxWeightDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Minor = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Weight = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.LeafWeight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Weight != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.LeafWeight != 0 {
            my_size += ::protobuf::rt::value_size(4, self.LeafWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Major != 0 {
            os.write_int64(1, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(2, self.Minor)?;
        }
        if self.Weight != 0 {
            os.write_uint32(3, self.Weight)?;
        }
        if self.LeafWeight != 0 {
            os.write_uint32(4, self.LeafWeight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxWeightDevice {
        LinuxWeightDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Major",
                    |m: &LinuxWeightDevice| { &m.Major },
                    |m: &mut LinuxWeightDevice| { &mut m.Major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Minor",
                    |m: &LinuxWeightDevice| { &m.Minor },
                    |m: &mut LinuxWeightDevice| { &mut m.Minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Weight",
                    |m: &LinuxWeightDevice| { &m.Weight },
                    |m: &mut LinuxWeightDevice| { &mut m.Weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "LeafWeight",
                    |m: &LinuxWeightDevice| { &m.LeafWeight },
                    |m: &mut LinuxWeightDevice| { &mut m.LeafWeight },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxWeightDevice>(
                    "LinuxWeightDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxWeightDevice {
        static mut instance: ::protobuf::lazy::Lazy<LinuxWeightDevice> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxWeightDevice::new)
        }
    }
}

impl ::protobuf::Clear for LinuxWeightDevice {
    fn clear(&mut self) {
        self.Major = 0;
        self.Minor = 0;
        self.Weight = 0;
        self.LeafWeight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxWeightDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxWeightDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxThrottleDevice {
    // message fields
    pub Major: i64,
    pub Minor: i64,
    pub Rate: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxThrottleDevice {
    fn default() -> &'a LinuxThrottleDevice {
        <LinuxThrottleDevice as ::protobuf::Message>::default_instance()
    }
}

impl LinuxThrottleDevice {
    pub fn new() -> LinuxThrottleDevice {
        ::std::default::Default::default()
    }

    // int64 Major = 1;


    pub fn get_Major(&self) -> i64 {
        self.Major
    }
    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 2;


    pub fn get_Minor(&self) -> i64 {
        self.Minor
    }
    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // uint64 Rate = 3;


    pub fn get_Rate(&self) -> u64 {
        self.Rate
    }
    pub fn clear_Rate(&mut self) {
        self.Rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_Rate(&mut self, v: u64) {
        self.Rate = v;
    }
}

impl ::protobuf::Message for LinuxThrottleDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Minor = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Rate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Rate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Major != 0 {
            os.write_int64(1, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(2, self.Minor)?;
        }
        if self.Rate != 0 {
            os.write_uint64(3, self.Rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxThrottleDevice {
        LinuxThrottleDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Major",
                    |m: &LinuxThrottleDevice| { &m.Major },
                    |m: &mut LinuxThrottleDevice| { &mut m.Major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Minor",
                    |m: &LinuxThrottleDevice| { &m.Minor },
                    |m: &mut LinuxThrottleDevice| { &mut m.Minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Rate",
                    |m: &LinuxThrottleDevice| { &m.Rate },
                    |m: &mut LinuxThrottleDevice| { &mut m.Rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxThrottleDevice>(
                    "LinuxThrottleDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxThrottleDevice {
        static mut instance: ::protobuf::lazy::Lazy<LinuxThrottleDevice> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxThrottleDevice::new)
        }
    }
}

impl ::protobuf::Clear for LinuxThrottleDevice {
    fn clear(&mut self) {
        self.Major = 0;
        self.Minor = 0;
        self.Rate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxThrottleDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxThrottleDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxBlockIO {
    // message fields
    pub Weight: u32,
    pub LeafWeight: u32,
    pub WeightDevice: ::protobuf::RepeatedField<LinuxWeightDevice>,
    pub ThrottleReadBpsDevice: ::protobuf::RepeatedField<LinuxThrottleDevice>,
    pub ThrottleWriteBpsDevice: ::protobuf::RepeatedField<LinuxThrottleDevice>,
    pub ThrottleReadIOPSDevice: ::protobuf::RepeatedField<LinuxThrottleDevice>,
    pub ThrottleWriteIOPSDevice: ::protobuf::RepeatedField<LinuxThrottleDevice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxBlockIO {
    fn default() -> &'a LinuxBlockIO {
        <LinuxBlockIO as ::protobuf::Message>::default_instance()
    }
}

impl LinuxBlockIO {
    pub fn new() -> LinuxBlockIO {
        ::std::default::Default::default()
    }

    // uint32 Weight = 1;


    pub fn get_Weight(&self) -> u32 {
        self.Weight
    }
    pub fn clear_Weight(&mut self) {
        self.Weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_Weight(&mut self, v: u32) {
        self.Weight = v;
    }

    // uint32 LeafWeight = 2;


    pub fn get_LeafWeight(&self) -> u32 {
        self.LeafWeight
    }
    pub fn clear_LeafWeight(&mut self) {
        self.LeafWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_LeafWeight(&mut self, v: u32) {
        self.LeafWeight = v;
    }

    // repeated .grpc.LinuxWeightDevice WeightDevice = 3;


    pub fn get_WeightDevice(&self) -> &[LinuxWeightDevice] {
        &self.WeightDevice
    }
    pub fn clear_WeightDevice(&mut self) {
        self.WeightDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_WeightDevice(&mut self, v: ::protobuf::RepeatedField<LinuxWeightDevice>) {
        self.WeightDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_WeightDevice(&mut self) -> &mut ::protobuf::RepeatedField<LinuxWeightDevice> {
        &mut self.WeightDevice
    }

    // Take field
    pub fn take_WeightDevice(&mut self) -> ::protobuf::RepeatedField<LinuxWeightDevice> {
        ::std::mem::replace(&mut self.WeightDevice, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleReadBpsDevice = 4;


    pub fn get_ThrottleReadBpsDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleReadBpsDevice
    }
    pub fn clear_ThrottleReadBpsDevice(&mut self) {
        self.ThrottleReadBpsDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleReadBpsDevice(&mut self, v: ::protobuf::RepeatedField<LinuxThrottleDevice>) {
        self.ThrottleReadBpsDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleReadBpsDevice(&mut self) -> &mut ::protobuf::RepeatedField<LinuxThrottleDevice> {
        &mut self.ThrottleReadBpsDevice
    }

    // Take field
    pub fn take_ThrottleReadBpsDevice(&mut self) -> ::protobuf::RepeatedField<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleReadBpsDevice, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleWriteBpsDevice = 5;


    pub fn get_ThrottleWriteBpsDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleWriteBpsDevice
    }
    pub fn clear_ThrottleWriteBpsDevice(&mut self) {
        self.ThrottleWriteBpsDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleWriteBpsDevice(&mut self, v: ::protobuf::RepeatedField<LinuxThrottleDevice>) {
        self.ThrottleWriteBpsDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleWriteBpsDevice(&mut self) -> &mut ::protobuf::RepeatedField<LinuxThrottleDevice> {
        &mut self.ThrottleWriteBpsDevice
    }

    // Take field
    pub fn take_ThrottleWriteBpsDevice(&mut self) -> ::protobuf::RepeatedField<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleWriteBpsDevice, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleReadIOPSDevice = 6;


    pub fn get_ThrottleReadIOPSDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleReadIOPSDevice
    }
    pub fn clear_ThrottleReadIOPSDevice(&mut self) {
        self.ThrottleReadIOPSDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleReadIOPSDevice(&mut self, v: ::protobuf::RepeatedField<LinuxThrottleDevice>) {
        self.ThrottleReadIOPSDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleReadIOPSDevice(&mut self) -> &mut ::protobuf::RepeatedField<LinuxThrottleDevice> {
        &mut self.ThrottleReadIOPSDevice
    }

    // Take field
    pub fn take_ThrottleReadIOPSDevice(&mut self) -> ::protobuf::RepeatedField<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleReadIOPSDevice, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxThrottleDevice ThrottleWriteIOPSDevice = 7;


    pub fn get_ThrottleWriteIOPSDevice(&self) -> &[LinuxThrottleDevice] {
        &self.ThrottleWriteIOPSDevice
    }
    pub fn clear_ThrottleWriteIOPSDevice(&mut self) {
        self.ThrottleWriteIOPSDevice.clear();
    }

    // Param is passed by value, moved
    pub fn set_ThrottleWriteIOPSDevice(&mut self, v: ::protobuf::RepeatedField<LinuxThrottleDevice>) {
        self.ThrottleWriteIOPSDevice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ThrottleWriteIOPSDevice(&mut self) -> &mut ::protobuf::RepeatedField<LinuxThrottleDevice> {
        &mut self.ThrottleWriteIOPSDevice
    }

    // Take field
    pub fn take_ThrottleWriteIOPSDevice(&mut self) -> ::protobuf::RepeatedField<LinuxThrottleDevice> {
        ::std::mem::replace(&mut self.ThrottleWriteIOPSDevice, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxBlockIO {
    fn is_initialized(&self) -> bool {
        for v in &self.WeightDevice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ThrottleReadBpsDevice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ThrottleWriteBpsDevice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ThrottleReadIOPSDevice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ThrottleWriteIOPSDevice {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Weight = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.LeafWeight = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.WeightDevice)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ThrottleReadBpsDevice)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ThrottleWriteBpsDevice)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ThrottleReadIOPSDevice)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ThrottleWriteIOPSDevice)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Weight != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.LeafWeight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.LeafWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.WeightDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ThrottleReadBpsDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ThrottleWriteBpsDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ThrottleReadIOPSDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ThrottleWriteIOPSDevice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Weight != 0 {
            os.write_uint32(1, self.Weight)?;
        }
        if self.LeafWeight != 0 {
            os.write_uint32(2, self.LeafWeight)?;
        }
        for v in &self.WeightDevice {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ThrottleReadBpsDevice {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ThrottleWriteBpsDevice {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ThrottleReadIOPSDevice {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ThrottleWriteIOPSDevice {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxBlockIO {
        LinuxBlockIO::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Weight",
                    |m: &LinuxBlockIO| { &m.Weight },
                    |m: &mut LinuxBlockIO| { &mut m.Weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "LeafWeight",
                    |m: &LinuxBlockIO| { &m.LeafWeight },
                    |m: &mut LinuxBlockIO| { &mut m.LeafWeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxWeightDevice>>(
                    "WeightDevice",
                    |m: &LinuxBlockIO| { &m.WeightDevice },
                    |m: &mut LinuxBlockIO| { &mut m.WeightDevice },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxThrottleDevice>>(
                    "ThrottleReadBpsDevice",
                    |m: &LinuxBlockIO| { &m.ThrottleReadBpsDevice },
                    |m: &mut LinuxBlockIO| { &mut m.ThrottleReadBpsDevice },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxThrottleDevice>>(
                    "ThrottleWriteBpsDevice",
                    |m: &LinuxBlockIO| { &m.ThrottleWriteBpsDevice },
                    |m: &mut LinuxBlockIO| { &mut m.ThrottleWriteBpsDevice },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxThrottleDevice>>(
                    "ThrottleReadIOPSDevice",
                    |m: &LinuxBlockIO| { &m.ThrottleReadIOPSDevice },
                    |m: &mut LinuxBlockIO| { &mut m.ThrottleReadIOPSDevice },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxThrottleDevice>>(
                    "ThrottleWriteIOPSDevice",
                    |m: &LinuxBlockIO| { &m.ThrottleWriteIOPSDevice },
                    |m: &mut LinuxBlockIO| { &mut m.ThrottleWriteIOPSDevice },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxBlockIO>(
                    "LinuxBlockIO",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxBlockIO {
        static mut instance: ::protobuf::lazy::Lazy<LinuxBlockIO> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxBlockIO::new)
        }
    }
}

impl ::protobuf::Clear for LinuxBlockIO {
    fn clear(&mut self) {
        self.Weight = 0;
        self.LeafWeight = 0;
        self.WeightDevice.clear();
        self.ThrottleReadBpsDevice.clear();
        self.ThrottleWriteBpsDevice.clear();
        self.ThrottleReadIOPSDevice.clear();
        self.ThrottleWriteIOPSDevice.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxBlockIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxBlockIO {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxPids {
    // message fields
    pub Limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxPids {
    fn default() -> &'a LinuxPids {
        <LinuxPids as ::protobuf::Message>::default_instance()
    }
}

impl LinuxPids {
    pub fn new() -> LinuxPids {
        ::std::default::Default::default()
    }

    // int64 Limit = 1;


    pub fn get_Limit(&self) -> i64 {
        self.Limit
    }
    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: i64) {
        self.Limit = v;
    }
}

impl ::protobuf::Message for LinuxPids {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Limit != 0 {
            os.write_int64(1, self.Limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxPids {
        LinuxPids::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Limit",
                    |m: &LinuxPids| { &m.Limit },
                    |m: &mut LinuxPids| { &mut m.Limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxPids>(
                    "LinuxPids",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxPids {
        static mut instance: ::protobuf::lazy::Lazy<LinuxPids> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxPids::new)
        }
    }
}

impl ::protobuf::Clear for LinuxPids {
    fn clear(&mut self) {
        self.Limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxPids {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxPids {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxDeviceCgroup {
    // message fields
    pub Allow: bool,
    pub Type: ::std::string::String,
    pub Major: i64,
    pub Minor: i64,
    pub Access: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxDeviceCgroup {
    fn default() -> &'a LinuxDeviceCgroup {
        <LinuxDeviceCgroup as ::protobuf::Message>::default_instance()
    }
}

impl LinuxDeviceCgroup {
    pub fn new() -> LinuxDeviceCgroup {
        ::std::default::Default::default()
    }

    // bool Allow = 1;


    pub fn get_Allow(&self) -> bool {
        self.Allow
    }
    pub fn clear_Allow(&mut self) {
        self.Allow = false;
    }

    // Param is passed by value, moved
    pub fn set_Allow(&mut self, v: bool) {
        self.Allow = v;
    }

    // string Type = 2;


    pub fn get_Type(&self) -> &str {
        &self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type.clear();
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: ::std::string::String) {
        self.Type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Type(&mut self) -> &mut ::std::string::String {
        &mut self.Type
    }

    // Take field
    pub fn take_Type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Type, ::std::string::String::new())
    }

    // int64 Major = 3;


    pub fn get_Major(&self) -> i64 {
        self.Major
    }
    pub fn clear_Major(&mut self) {
        self.Major = 0;
    }

    // Param is passed by value, moved
    pub fn set_Major(&mut self, v: i64) {
        self.Major = v;
    }

    // int64 Minor = 4;


    pub fn get_Minor(&self) -> i64 {
        self.Minor
    }
    pub fn clear_Minor(&mut self) {
        self.Minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_Minor(&mut self, v: i64) {
        self.Minor = v;
    }

    // string Access = 5;


    pub fn get_Access(&self) -> &str {
        &self.Access
    }
    pub fn clear_Access(&mut self) {
        self.Access.clear();
    }

    // Param is passed by value, moved
    pub fn set_Access(&mut self, v: ::std::string::String) {
        self.Access = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Access(&mut self) -> &mut ::std::string::String {
        &mut self.Access
    }

    // Take field
    pub fn take_Access(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Access, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxDeviceCgroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Allow = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Major = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.Minor = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Access)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Allow != false {
            my_size += 2;
        }
        if !self.Type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Type);
        }
        if self.Major != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Minor != 0 {
            my_size += ::protobuf::rt::value_size(4, self.Minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Access.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Access);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Allow != false {
            os.write_bool(1, self.Allow)?;
        }
        if !self.Type.is_empty() {
            os.write_string(2, &self.Type)?;
        }
        if self.Major != 0 {
            os.write_int64(3, self.Major)?;
        }
        if self.Minor != 0 {
            os.write_int64(4, self.Minor)?;
        }
        if !self.Access.is_empty() {
            os.write_string(5, &self.Access)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxDeviceCgroup {
        LinuxDeviceCgroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Allow",
                    |m: &LinuxDeviceCgroup| { &m.Allow },
                    |m: &mut LinuxDeviceCgroup| { &mut m.Allow },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Type",
                    |m: &LinuxDeviceCgroup| { &m.Type },
                    |m: &mut LinuxDeviceCgroup| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Major",
                    |m: &LinuxDeviceCgroup| { &m.Major },
                    |m: &mut LinuxDeviceCgroup| { &mut m.Major },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Minor",
                    |m: &LinuxDeviceCgroup| { &m.Minor },
                    |m: &mut LinuxDeviceCgroup| { &mut m.Minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Access",
                    |m: &LinuxDeviceCgroup| { &m.Access },
                    |m: &mut LinuxDeviceCgroup| { &mut m.Access },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxDeviceCgroup>(
                    "LinuxDeviceCgroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxDeviceCgroup {
        static mut instance: ::protobuf::lazy::Lazy<LinuxDeviceCgroup> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxDeviceCgroup::new)
        }
    }
}

impl ::protobuf::Clear for LinuxDeviceCgroup {
    fn clear(&mut self) {
        self.Allow = false;
        self.Type.clear();
        self.Major = 0;
        self.Minor = 0;
        self.Access.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxDeviceCgroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxDeviceCgroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxNetwork {
    // message fields
    pub ClassID: u32,
    pub Priorities: ::protobuf::RepeatedField<LinuxInterfacePriority>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxNetwork {
    fn default() -> &'a LinuxNetwork {
        <LinuxNetwork as ::protobuf::Message>::default_instance()
    }
}

impl LinuxNetwork {
    pub fn new() -> LinuxNetwork {
        ::std::default::Default::default()
    }

    // uint32 ClassID = 1;


    pub fn get_ClassID(&self) -> u32 {
        self.ClassID
    }
    pub fn clear_ClassID(&mut self) {
        self.ClassID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ClassID(&mut self, v: u32) {
        self.ClassID = v;
    }

    // repeated .grpc.LinuxInterfacePriority Priorities = 2;


    pub fn get_Priorities(&self) -> &[LinuxInterfacePriority] {
        &self.Priorities
    }
    pub fn clear_Priorities(&mut self) {
        self.Priorities.clear();
    }

    // Param is passed by value, moved
    pub fn set_Priorities(&mut self, v: ::protobuf::RepeatedField<LinuxInterfacePriority>) {
        self.Priorities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Priorities(&mut self) -> &mut ::protobuf::RepeatedField<LinuxInterfacePriority> {
        &mut self.Priorities
    }

    // Take field
    pub fn take_Priorities(&mut self) -> ::protobuf::RepeatedField<LinuxInterfacePriority> {
        ::std::mem::replace(&mut self.Priorities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxNetwork {
    fn is_initialized(&self) -> bool {
        for v in &self.Priorities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ClassID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Priorities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ClassID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ClassID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Priorities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ClassID != 0 {
            os.write_uint32(1, self.ClassID)?;
        }
        for v in &self.Priorities {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxNetwork {
        LinuxNetwork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ClassID",
                    |m: &LinuxNetwork| { &m.ClassID },
                    |m: &mut LinuxNetwork| { &mut m.ClassID },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxInterfacePriority>>(
                    "Priorities",
                    |m: &LinuxNetwork| { &m.Priorities },
                    |m: &mut LinuxNetwork| { &mut m.Priorities },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxNetwork>(
                    "LinuxNetwork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxNetwork {
        static mut instance: ::protobuf::lazy::Lazy<LinuxNetwork> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxNetwork::new)
        }
    }
}

impl ::protobuf::Clear for LinuxNetwork {
    fn clear(&mut self) {
        self.ClassID = 0;
        self.Priorities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxNetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxNetwork {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxHugepageLimit {
    // message fields
    pub Pagesize: ::std::string::String,
    pub Limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxHugepageLimit {
    fn default() -> &'a LinuxHugepageLimit {
        <LinuxHugepageLimit as ::protobuf::Message>::default_instance()
    }
}

impl LinuxHugepageLimit {
    pub fn new() -> LinuxHugepageLimit {
        ::std::default::Default::default()
    }

    // string Pagesize = 1;


    pub fn get_Pagesize(&self) -> &str {
        &self.Pagesize
    }
    pub fn clear_Pagesize(&mut self) {
        self.Pagesize.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pagesize(&mut self, v: ::std::string::String) {
        self.Pagesize = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pagesize(&mut self) -> &mut ::std::string::String {
        &mut self.Pagesize
    }

    // Take field
    pub fn take_Pagesize(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Pagesize, ::std::string::String::new())
    }

    // uint64 Limit = 2;


    pub fn get_Limit(&self) -> u64 {
        self.Limit
    }
    pub fn clear_Limit(&mut self) {
        self.Limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_Limit(&mut self, v: u64) {
        self.Limit = v;
    }
}

impl ::protobuf::Message for LinuxHugepageLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Pagesize)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Pagesize.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Pagesize);
        }
        if self.Limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Pagesize.is_empty() {
            os.write_string(1, &self.Pagesize)?;
        }
        if self.Limit != 0 {
            os.write_uint64(2, self.Limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxHugepageLimit {
        LinuxHugepageLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Pagesize",
                    |m: &LinuxHugepageLimit| { &m.Pagesize },
                    |m: &mut LinuxHugepageLimit| { &mut m.Pagesize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Limit",
                    |m: &LinuxHugepageLimit| { &m.Limit },
                    |m: &mut LinuxHugepageLimit| { &mut m.Limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxHugepageLimit>(
                    "LinuxHugepageLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxHugepageLimit {
        static mut instance: ::protobuf::lazy::Lazy<LinuxHugepageLimit> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxHugepageLimit::new)
        }
    }
}

impl ::protobuf::Clear for LinuxHugepageLimit {
    fn clear(&mut self) {
        self.Pagesize.clear();
        self.Limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxHugepageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxHugepageLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxInterfacePriority {
    // message fields
    pub Name: ::std::string::String,
    pub Priority: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxInterfacePriority {
    fn default() -> &'a LinuxInterfacePriority {
        <LinuxInterfacePriority as ::protobuf::Message>::default_instance()
    }
}

impl LinuxInterfacePriority {
    pub fn new() -> LinuxInterfacePriority {
        ::std::default::Default::default()
    }

    // string Name = 1;


    pub fn get_Name(&self) -> &str {
        &self.Name
    }
    pub fn clear_Name(&mut self) {
        self.Name.clear();
    }

    // Param is passed by value, moved
    pub fn set_Name(&mut self, v: ::std::string::String) {
        self.Name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Name(&mut self) -> &mut ::std::string::String {
        &mut self.Name
    }

    // Take field
    pub fn take_Name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Name, ::std::string::String::new())
    }

    // uint32 Priority = 2;


    pub fn get_Priority(&self) -> u32 {
        self.Priority
    }
    pub fn clear_Priority(&mut self) {
        self.Priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_Priority(&mut self, v: u32) {
        self.Priority = v;
    }
}

impl ::protobuf::Message for LinuxInterfacePriority {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Priority = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Name);
        }
        if self.Priority != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Priority, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Name.is_empty() {
            os.write_string(1, &self.Name)?;
        }
        if self.Priority != 0 {
            os.write_uint32(2, self.Priority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxInterfacePriority {
        LinuxInterfacePriority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Name",
                    |m: &LinuxInterfacePriority| { &m.Name },
                    |m: &mut LinuxInterfacePriority| { &mut m.Name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "Priority",
                    |m: &LinuxInterfacePriority| { &m.Priority },
                    |m: &mut LinuxInterfacePriority| { &mut m.Priority },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxInterfacePriority>(
                    "LinuxInterfacePriority",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxInterfacePriority {
        static mut instance: ::protobuf::lazy::Lazy<LinuxInterfacePriority> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxInterfacePriority::new)
        }
    }
}

impl ::protobuf::Clear for LinuxInterfacePriority {
    fn clear(&mut self) {
        self.Name.clear();
        self.Priority = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxInterfacePriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxInterfacePriority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxSeccomp {
    // message fields
    pub DefaultAction: ::std::string::String,
    pub Architectures: ::protobuf::RepeatedField<::std::string::String>,
    pub Syscalls: ::protobuf::RepeatedField<LinuxSyscall>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxSeccomp {
    fn default() -> &'a LinuxSeccomp {
        <LinuxSeccomp as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSeccomp {
    pub fn new() -> LinuxSeccomp {
        ::std::default::Default::default()
    }

    // string DefaultAction = 1;


    pub fn get_DefaultAction(&self) -> &str {
        &self.DefaultAction
    }
    pub fn clear_DefaultAction(&mut self) {
        self.DefaultAction.clear();
    }

    // Param is passed by value, moved
    pub fn set_DefaultAction(&mut self, v: ::std::string::String) {
        self.DefaultAction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DefaultAction(&mut self) -> &mut ::std::string::String {
        &mut self.DefaultAction
    }

    // Take field
    pub fn take_DefaultAction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.DefaultAction, ::std::string::String::new())
    }

    // repeated string Architectures = 2;


    pub fn get_Architectures(&self) -> &[::std::string::String] {
        &self.Architectures
    }
    pub fn clear_Architectures(&mut self) {
        self.Architectures.clear();
    }

    // Param is passed by value, moved
    pub fn set_Architectures(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Architectures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Architectures(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Architectures
    }

    // Take field
    pub fn take_Architectures(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Architectures, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.LinuxSyscall Syscalls = 3;


    pub fn get_Syscalls(&self) -> &[LinuxSyscall] {
        &self.Syscalls
    }
    pub fn clear_Syscalls(&mut self) {
        self.Syscalls.clear();
    }

    // Param is passed by value, moved
    pub fn set_Syscalls(&mut self, v: ::protobuf::RepeatedField<LinuxSyscall>) {
        self.Syscalls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Syscalls(&mut self) -> &mut ::protobuf::RepeatedField<LinuxSyscall> {
        &mut self.Syscalls
    }

    // Take field
    pub fn take_Syscalls(&mut self) -> ::protobuf::RepeatedField<LinuxSyscall> {
        ::std::mem::replace(&mut self.Syscalls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxSeccomp {
    fn is_initialized(&self) -> bool {
        for v in &self.Syscalls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.DefaultAction)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Architectures)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Syscalls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.DefaultAction.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.DefaultAction);
        }
        for value in &self.Architectures {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.Syscalls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.DefaultAction.is_empty() {
            os.write_string(1, &self.DefaultAction)?;
        }
        for v in &self.Architectures {
            os.write_string(2, &v)?;
        };
        for v in &self.Syscalls {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxSeccomp {
        LinuxSeccomp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "DefaultAction",
                    |m: &LinuxSeccomp| { &m.DefaultAction },
                    |m: &mut LinuxSeccomp| { &mut m.DefaultAction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Architectures",
                    |m: &LinuxSeccomp| { &m.Architectures },
                    |m: &mut LinuxSeccomp| { &mut m.Architectures },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxSyscall>>(
                    "Syscalls",
                    |m: &LinuxSeccomp| { &m.Syscalls },
                    |m: &mut LinuxSeccomp| { &mut m.Syscalls },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxSeccomp>(
                    "LinuxSeccomp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxSeccomp {
        static mut instance: ::protobuf::lazy::Lazy<LinuxSeccomp> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxSeccomp::new)
        }
    }
}

impl ::protobuf::Clear for LinuxSeccomp {
    fn clear(&mut self) {
        self.DefaultAction.clear();
        self.Architectures.clear();
        self.Syscalls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxSeccomp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSeccomp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxSeccompArg {
    // message fields
    pub Index: u64,
    pub Value: u64,
    pub ValueTwo: u64,
    pub Op: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxSeccompArg {
    fn default() -> &'a LinuxSeccompArg {
        <LinuxSeccompArg as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSeccompArg {
    pub fn new() -> LinuxSeccompArg {
        ::std::default::Default::default()
    }

    // uint64 Index = 1;


    pub fn get_Index(&self) -> u64 {
        self.Index
    }
    pub fn clear_Index(&mut self) {
        self.Index = 0;
    }

    // Param is passed by value, moved
    pub fn set_Index(&mut self, v: u64) {
        self.Index = v;
    }

    // uint64 Value = 2;


    pub fn get_Value(&self) -> u64 {
        self.Value
    }
    pub fn clear_Value(&mut self) {
        self.Value = 0;
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: u64) {
        self.Value = v;
    }

    // uint64 ValueTwo = 3;


    pub fn get_ValueTwo(&self) -> u64 {
        self.ValueTwo
    }
    pub fn clear_ValueTwo(&mut self) {
        self.ValueTwo = 0;
    }

    // Param is passed by value, moved
    pub fn set_ValueTwo(&mut self, v: u64) {
        self.ValueTwo = v;
    }

    // string Op = 4;


    pub fn get_Op(&self) -> &str {
        &self.Op
    }
    pub fn clear_Op(&mut self) {
        self.Op.clear();
    }

    // Param is passed by value, moved
    pub fn set_Op(&mut self, v: ::std::string::String) {
        self.Op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Op(&mut self) -> &mut ::std::string::String {
        &mut self.Op
    }

    // Take field
    pub fn take_Op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Op, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxSeccompArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ValueTwo = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Op)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ValueTwo != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ValueTwo, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Op.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Op);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Index != 0 {
            os.write_uint64(1, self.Index)?;
        }
        if self.Value != 0 {
            os.write_uint64(2, self.Value)?;
        }
        if self.ValueTwo != 0 {
            os.write_uint64(3, self.ValueTwo)?;
        }
        if !self.Op.is_empty() {
            os.write_string(4, &self.Op)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxSeccompArg {
        LinuxSeccompArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Index",
                    |m: &LinuxSeccompArg| { &m.Index },
                    |m: &mut LinuxSeccompArg| { &mut m.Index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Value",
                    |m: &LinuxSeccompArg| { &m.Value },
                    |m: &mut LinuxSeccompArg| { &mut m.Value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ValueTwo",
                    |m: &LinuxSeccompArg| { &m.ValueTwo },
                    |m: &mut LinuxSeccompArg| { &mut m.ValueTwo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Op",
                    |m: &LinuxSeccompArg| { &m.Op },
                    |m: &mut LinuxSeccompArg| { &mut m.Op },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxSeccompArg>(
                    "LinuxSeccompArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxSeccompArg {
        static mut instance: ::protobuf::lazy::Lazy<LinuxSeccompArg> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxSeccompArg::new)
        }
    }
}

impl ::protobuf::Clear for LinuxSeccompArg {
    fn clear(&mut self) {
        self.Index = 0;
        self.Value = 0;
        self.ValueTwo = 0;
        self.Op.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxSeccompArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSeccompArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxSyscall {
    // message fields
    pub Names: ::protobuf::RepeatedField<::std::string::String>,
    pub Action: ::std::string::String,
    pub Args: ::protobuf::RepeatedField<LinuxSeccompArg>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxSyscall {
    fn default() -> &'a LinuxSyscall {
        <LinuxSyscall as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSyscall {
    pub fn new() -> LinuxSyscall {
        ::std::default::Default::default()
    }

    // repeated string Names = 1;


    pub fn get_Names(&self) -> &[::std::string::String] {
        &self.Names
    }
    pub fn clear_Names(&mut self) {
        self.Names.clear();
    }

    // Param is passed by value, moved
    pub fn set_Names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Names
    }

    // Take field
    pub fn take_Names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Names, ::protobuf::RepeatedField::new())
    }

    // string Action = 2;


    pub fn get_Action(&self) -> &str {
        &self.Action
    }
    pub fn clear_Action(&mut self) {
        self.Action.clear();
    }

    // Param is passed by value, moved
    pub fn set_Action(&mut self, v: ::std::string::String) {
        self.Action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Action(&mut self) -> &mut ::std::string::String {
        &mut self.Action
    }

    // Take field
    pub fn take_Action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Action, ::std::string::String::new())
    }

    // repeated .grpc.LinuxSeccompArg Args = 3;


    pub fn get_Args(&self) -> &[LinuxSeccompArg] {
        &self.Args
    }
    pub fn clear_Args(&mut self) {
        self.Args.clear();
    }

    // Param is passed by value, moved
    pub fn set_Args(&mut self, v: ::protobuf::RepeatedField<LinuxSeccompArg>) {
        self.Args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Args(&mut self) -> &mut ::protobuf::RepeatedField<LinuxSeccompArg> {
        &mut self.Args
    }

    // Take field
    pub fn take_Args(&mut self) -> ::protobuf::RepeatedField<LinuxSeccompArg> {
        ::std::mem::replace(&mut self.Args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxSyscall {
    fn is_initialized(&self) -> bool {
        for v in &self.Args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Names)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Action)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.Action.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Action);
        }
        for value in &self.Args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Names {
            os.write_string(1, &v)?;
        };
        if !self.Action.is_empty() {
            os.write_string(2, &self.Action)?;
        }
        for v in &self.Args {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxSyscall {
        LinuxSyscall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Names",
                    |m: &LinuxSyscall| { &m.Names },
                    |m: &mut LinuxSyscall| { &mut m.Names },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Action",
                    |m: &LinuxSyscall| { &m.Action },
                    |m: &mut LinuxSyscall| { &mut m.Action },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxSeccompArg>>(
                    "Args",
                    |m: &LinuxSyscall| { &m.Args },
                    |m: &mut LinuxSyscall| { &mut m.Args },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxSyscall>(
                    "LinuxSyscall",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxSyscall {
        static mut instance: ::protobuf::lazy::Lazy<LinuxSyscall> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxSyscall::new)
        }
    }
}

impl ::protobuf::Clear for LinuxSyscall {
    fn clear(&mut self) {
        self.Names.clear();
        self.Action.clear();
        self.Args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxSyscall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSyscall {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxIntelRdt {
    // message fields
    pub L3CacheSchema: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxIntelRdt {
    fn default() -> &'a LinuxIntelRdt {
        <LinuxIntelRdt as ::protobuf::Message>::default_instance()
    }
}

impl LinuxIntelRdt {
    pub fn new() -> LinuxIntelRdt {
        ::std::default::Default::default()
    }

    // string L3CacheSchema = 1;


    pub fn get_L3CacheSchema(&self) -> &str {
        &self.L3CacheSchema
    }
    pub fn clear_L3CacheSchema(&mut self) {
        self.L3CacheSchema.clear();
    }

    // Param is passed by value, moved
    pub fn set_L3CacheSchema(&mut self, v: ::std::string::String) {
        self.L3CacheSchema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_L3CacheSchema(&mut self) -> &mut ::std::string::String {
        &mut self.L3CacheSchema
    }

    // Take field
    pub fn take_L3CacheSchema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.L3CacheSchema, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxIntelRdt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.L3CacheSchema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.L3CacheSchema.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.L3CacheSchema);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.L3CacheSchema.is_empty() {
            os.write_string(1, &self.L3CacheSchema)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxIntelRdt {
        LinuxIntelRdt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "L3CacheSchema",
                    |m: &LinuxIntelRdt| { &m.L3CacheSchema },
                    |m: &mut LinuxIntelRdt| { &mut m.L3CacheSchema },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxIntelRdt>(
                    "LinuxIntelRdt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinuxIntelRdt {
        static mut instance: ::protobuf::lazy::Lazy<LinuxIntelRdt> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LinuxIntelRdt::new)
        }
    }
}

impl ::protobuf::Clear for LinuxIntelRdt {
    fn clear(&mut self) {
        self.L3CacheSchema.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxIntelRdt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxIntelRdt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nOgithub.com/kata-containers/kata-containers/src/agent/protocols/protos\
    /oci.proto\x12\x04grpc\x1a-github.com/gogo/protobuf/gogoproto/gogo.proto\
    \x1a\x1egoogle/protobuf/wrappers.proto\"\xc7\x03\n\x04Spec\x12\x18\n\x07\
    Version\x18\x01\x20\x01(\tR\x07Version\x12'\n\x07Process\x18\x02\x20\x01\
    (\x0b2\r.grpc.ProcessR\x07Process\x12\x1e\n\x04Root\x18\x03\x20\x01(\x0b\
    2\n.grpc.RootR\x04Root\x12\x1a\n\x08Hostname\x18\x04\x20\x01(\tR\x08Host\
    name\x12)\n\x06Mounts\x18\x05\x20\x03(\x0b2\x0b.grpc.MountR\x06MountsB\
    \x04\xc8\xde\x1f\0\x12!\n\x05Hooks\x18\x06\x20\x01(\x0b2\x0b.grpc.HooksR\
    \x05Hooks\x12=\n\x0bAnnotations\x18\x07\x20\x03(\x0b2\x1b.grpc.Spec.Anno\
    tationsEntryR\x0bAnnotations\x12!\n\x05Linux\x18\x08\x20\x01(\x0b2\x0b.g\
    rpc.LinuxR\x05Linux\x12'\n\x07Solaris\x18\t\x20\x01(\x0b2\r.grpc.Solaris\
    R\x07Solaris\x12'\n\x07Windows\x18\n\x20\x01(\x0b2\r.grpc.WindowsR\x07Wi\
    ndows\x1a>\n\x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xba\
    \x03\n\x07Process\x12\x1a\n\x08Terminal\x18\x01\x20\x01(\x08R\x08Termina\
    l\x12+\n\x0bConsoleSize\x18\x02\x20\x01(\x0b2\t.grpc.BoxR\x0bConsoleSize\
    \x12$\n\x04User\x18\x03\x20\x01(\x0b2\n.grpc.UserR\x04UserB\x04\xc8\xde\
    \x1f\0\x12\x12\n\x04Args\x18\x04\x20\x03(\tR\x04Args\x12\x10\n\x03Env\
    \x18\x05\x20\x03(\tR\x03Env\x12\x10\n\x03Cwd\x18\x06\x20\x01(\tR\x03Cwd\
    \x12;\n\x0cCapabilities\x18\x07\x20\x01(\x0b2\x17.grpc.LinuxCapabilities\
    R\x0cCapabilities\x121\n\x07Rlimits\x18\x08\x20\x03(\x0b2\x11.grpc.POSIX\
    RlimitR\x07RlimitsB\x04\xc8\xde\x1f\0\x12(\n\x0fNoNewPrivileges\x18\t\
    \x20\x01(\x08R\x0fNoNewPrivileges\x12(\n\x0fApparmorProfile\x18\n\x20\
    \x01(\tR\x0fApparmorProfile\x12\x20\n\x0bOOMScoreAdj\x18\x0b\x20\x01(\
    \x03R\x0bOOMScoreAdj\x12\"\n\x0cSelinuxLabel\x18\x0c\x20\x01(\tR\x0cSeli\
    nuxLabel\"3\n\x03Box\x12\x16\n\x06Height\x18\x01\x20\x01(\rR\x06Height\
    \x12\x14\n\x05Width\x18\x02\x20\x01(\rR\x05Width\"n\n\x04User\x12\x10\n\
    \x03UID\x18\x01\x20\x01(\rR\x03UID\x12\x10\n\x03GID\x18\x02\x20\x01(\rR\
    \x03GID\x12&\n\x0eAdditionalGids\x18\x03\x20\x03(\rR\x0eAdditionalGids\
    \x12\x1a\n\x08Username\x18\x04\x20\x01(\tR\x08Username\"\xa7\x01\n\x11Li\
    nuxCapabilities\x12\x1a\n\x08Bounding\x18\x01\x20\x03(\tR\x08Bounding\
    \x12\x1c\n\tEffective\x18\x02\x20\x03(\tR\tEffective\x12\x20\n\x0bInheri\
    table\x18\x03\x20\x03(\tR\x0bInheritable\x12\x1c\n\tPermitted\x18\x04\
    \x20\x03(\tR\tPermitted\x12\x18\n\x07Ambient\x18\x05\x20\x03(\tR\x07Ambi\
    ent\"I\n\x0bPOSIXRlimit\x12\x12\n\x04Type\x18\x01\x20\x01(\tR\x04Type\
    \x12\x12\n\x04Hard\x18\x02\x20\x01(\x04R\x04Hard\x12\x12\n\x04Soft\x18\
    \x03\x20\x01(\x04R\x04Soft\"o\n\x05Mount\x12\x20\n\x0bdestination\x18\
    \x01\x20\x01(\tR\x0bdestination\x12\x16\n\x06source\x18\x02\x20\x01(\tR\
    \x06source\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x18\n\x07op\
    tions\x18\x04\x20\x03(\tR\x07options\"6\n\x04Root\x12\x12\n\x04Path\x18\
    \x01\x20\x01(\tR\x04Path\x12\x1a\n\x08Readonly\x18\x02\x20\x01(\x08R\x08\
    Readonly\"\x93\x01\n\x05Hooks\x12,\n\x08Prestart\x18\x01\x20\x03(\x0b2\n\
    .grpc.HookR\x08PrestartB\x04\xc8\xde\x1f\0\x12.\n\tPoststart\x18\x02\x20\
    \x03(\x0b2\n.grpc.HookR\tPoststartB\x04\xc8\xde\x1f\0\x12,\n\x08Poststop\
    \x18\x03\x20\x03(\x0b2\n.grpc.HookR\x08PoststopB\x04\xc8\xde\x1f\0\"Z\n\
    \x04Hook\x12\x12\n\x04Path\x18\x01\x20\x01(\tR\x04Path\x12\x12\n\x04Args\
    \x18\x02\x20\x03(\tR\x04Args\x12\x10\n\x03Env\x18\x03\x20\x03(\tR\x03Env\
    \x12\x18\n\x07Timeout\x18\x04\x20\x01(\x03R\x07Timeout\"\xa9\x05\n\x05Li\
    nux\x12<\n\x0bUIDMappings\x18\x01\x20\x03(\x0b2\x14.grpc.LinuxIDMappingR\
    \x0bUIDMappingsB\x04\xc8\xde\x1f\0\x12<\n\x0bGIDMappings\x18\x02\x20\x03\
    (\x0b2\x14.grpc.LinuxIDMappingR\x0bGIDMappingsB\x04\xc8\xde\x1f\0\x12/\n\
    \x06Sysctl\x18\x03\x20\x03(\x0b2\x17.grpc.Linux.SysctlEntryR\x06Sysctl\
    \x122\n\tResources\x18\x04\x20\x01(\x0b2\x14.grpc.LinuxResourcesR\tResou\
    rces\x12\x20\n\x0bCgroupsPath\x18\x05\x20\x01(\tR\x0bCgroupsPath\x12:\n\
    \nNamespaces\x18\x06\x20\x03(\x0b2\x14.grpc.LinuxNamespaceR\nNamespacesB\
    \x04\xc8\xde\x1f\0\x121\n\x07Devices\x18\x07\x20\x03(\x0b2\x11.grpc.Linu\
    xDeviceR\x07DevicesB\x04\xc8\xde\x1f\0\x12,\n\x07Seccomp\x18\x08\x20\x01\
    (\x0b2\x12.grpc.LinuxSeccompR\x07Seccomp\x12,\n\x11RootfsPropagation\x18\
    \t\x20\x01(\tR\x11RootfsPropagation\x12\x20\n\x0bMaskedPaths\x18\n\x20\
    \x03(\tR\x0bMaskedPaths\x12$\n\rReadonlyPaths\x18\x0b\x20\x03(\tR\rReado\
    nlyPaths\x12\x1e\n\nMountLabel\x18\x0c\x20\x01(\tR\nMountLabel\x12/\n\
    \x08IntelRdt\x18\r\x20\x01(\x0b2\x13.grpc.LinuxIntelRdtR\x08IntelRdt\x1a\
    9\n\x0bSysctlEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x1f\n\x07Windows\x12\
    \x14\n\x05dummy\x18\x01\x20\x01(\tR\x05dummy\"\x1f\n\x07Solaris\x12\x14\
    \n\x05dummy\x18\x01\x20\x01(\tR\x05dummy\"^\n\x0eLinuxIDMapping\x12\x16\
    \n\x06HostID\x18\x01\x20\x01(\rR\x06HostID\x12\x20\n\x0bContainerID\x18\
    \x02\x20\x01(\rR\x0bContainerID\x12\x12\n\x04Size\x18\x03\x20\x01(\rR\
    \x04Size\"8\n\x0eLinuxNamespace\x12\x12\n\x04Type\x18\x01\x20\x01(\tR\
    \x04Type\x12\x12\n\x04Path\x18\x02\x20\x01(\tR\x04Path\"\xa1\x01\n\x0bLi\
    nuxDevice\x12\x12\n\x04Path\x18\x01\x20\x01(\tR\x04Path\x12\x12\n\x04Typ\
    e\x18\x02\x20\x01(\tR\x04Type\x12\x14\n\x05Major\x18\x03\x20\x01(\x03R\
    \x05Major\x12\x14\n\x05Minor\x18\x04\x20\x01(\x03R\x05Minor\x12\x1a\n\
    \x08FileMode\x18\x05\x20\x01(\rR\x08FileMode\x12\x10\n\x03UID\x18\x06\
    \x20\x01(\rR\x03UID\x12\x10\n\x03GID\x18\x07\x20\x01(\rR\x03GID\"\xdf\
    \x02\n\x0eLinuxResources\x127\n\x07Devices\x18\x01\x20\x03(\x0b2\x17.grp\
    c.LinuxDeviceCgroupR\x07DevicesB\x04\xc8\xde\x1f\0\x12)\n\x06Memory\x18\
    \x02\x20\x01(\x0b2\x11.grpc.LinuxMemoryR\x06Memory\x12\x20\n\x03CPU\x18\
    \x03\x20\x01(\x0b2\x0e.grpc.LinuxCPUR\x03CPU\x12#\n\x04Pids\x18\x04\x20\
    \x01(\x0b2\x0f.grpc.LinuxPidsR\x04Pids\x12,\n\x07BlockIO\x18\x05\x20\x01\
    (\x0b2\x12.grpc.LinuxBlockIOR\x07BlockIO\x12F\n\x0eHugepageLimits\x18\
    \x06\x20\x03(\x0b2\x18.grpc.LinuxHugepageLimitR\x0eHugepageLimitsB\x04\
    \xc8\xde\x1f\0\x12,\n\x07Network\x18\x07\x20\x01(\x0b2\x12.grpc.LinuxNet\
    workR\x07Network\"\xdb\x01\n\x0bLinuxMemory\x12\x14\n\x05Limit\x18\x01\
    \x20\x01(\x03R\x05Limit\x12\x20\n\x0bReservation\x18\x02\x20\x01(\x03R\
    \x0bReservation\x12\x12\n\x04Swap\x18\x03\x20\x01(\x03R\x04Swap\x12\x16\
    \n\x06Kernel\x18\x04\x20\x01(\x03R\x06Kernel\x12\x1c\n\tKernelTCP\x18\
    \x05\x20\x01(\x03R\tKernelTCP\x12\x1e\n\nSwappiness\x18\x06\x20\x01(\x04\
    R\nSwappiness\x12*\n\x10DisableOOMKiller\x18\x07\x20\x01(\x08R\x10Disabl\
    eOOMKiller\"\xca\x01\n\x08LinuxCPU\x12\x16\n\x06Shares\x18\x01\x20\x01(\
    \x04R\x06Shares\x12\x14\n\x05Quota\x18\x02\x20\x01(\x03R\x05Quota\x12\
    \x16\n\x06Period\x18\x03\x20\x01(\x04R\x06Period\x12(\n\x0fRealtimeRunti\
    me\x18\x04\x20\x01(\x03R\x0fRealtimeRuntime\x12&\n\x0eRealtimePeriod\x18\
    \x05\x20\x01(\x04R\x0eRealtimePeriod\x12\x12\n\x04Cpus\x18\x06\x20\x01(\
    \tR\x04Cpus\x12\x12\n\x04Mems\x18\x07\x20\x01(\tR\x04Mems\"w\n\x11LinuxW\
    eightDevice\x12\x14\n\x05Major\x18\x01\x20\x01(\x03R\x05Major\x12\x14\n\
    \x05Minor\x18\x02\x20\x01(\x03R\x05Minor\x12\x16\n\x06Weight\x18\x03\x20\
    \x01(\rR\x06Weight\x12\x1e\n\nLeafWeight\x18\x04\x20\x01(\rR\nLeafWeight\
    \"U\n\x13LinuxThrottleDevice\x12\x14\n\x05Major\x18\x01\x20\x01(\x03R\
    \x05Major\x12\x14\n\x05Minor\x18\x02\x20\x01(\x03R\x05Minor\x12\x12\n\
    \x04Rate\x18\x03\x20\x01(\x04R\x04Rate\"\xed\x03\n\x0cLinuxBlockIO\x12\
    \x16\n\x06Weight\x18\x01\x20\x01(\rR\x06Weight\x12\x1e\n\nLeafWeight\x18\
    \x02\x20\x01(\rR\nLeafWeight\x12A\n\x0cWeightDevice\x18\x03\x20\x03(\x0b\
    2\x17.grpc.LinuxWeightDeviceR\x0cWeightDeviceB\x04\xc8\xde\x1f\0\x12U\n\
    \x15ThrottleReadBpsDevice\x18\x04\x20\x03(\x0b2\x19.grpc.LinuxThrottleDe\
    viceR\x15ThrottleReadBpsDeviceB\x04\xc8\xde\x1f\0\x12W\n\x16ThrottleWrit\
    eBpsDevice\x18\x05\x20\x03(\x0b2\x19.grpc.LinuxThrottleDeviceR\x16Thrott\
    leWriteBpsDeviceB\x04\xc8\xde\x1f\0\x12W\n\x16ThrottleReadIOPSDevice\x18\
    \x06\x20\x03(\x0b2\x19.grpc.LinuxThrottleDeviceR\x16ThrottleReadIOPSDevi\
    ceB\x04\xc8\xde\x1f\0\x12Y\n\x17ThrottleWriteIOPSDevice\x18\x07\x20\x03(\
    \x0b2\x19.grpc.LinuxThrottleDeviceR\x17ThrottleWriteIOPSDeviceB\x04\xc8\
    \xde\x1f\0\"!\n\tLinuxPids\x12\x14\n\x05Limit\x18\x01\x20\x01(\x03R\x05L\
    imit\"\x81\x01\n\x11LinuxDeviceCgroup\x12\x14\n\x05Allow\x18\x01\x20\x01\
    (\x08R\x05Allow\x12\x12\n\x04Type\x18\x02\x20\x01(\tR\x04Type\x12\x14\n\
    \x05Major\x18\x03\x20\x01(\x03R\x05Major\x12\x14\n\x05Minor\x18\x04\x20\
    \x01(\x03R\x05Minor\x12\x16\n\x06Access\x18\x05\x20\x01(\tR\x06Access\"l\
    \n\x0cLinuxNetwork\x12\x18\n\x07ClassID\x18\x01\x20\x01(\rR\x07ClassID\
    \x12B\n\nPriorities\x18\x02\x20\x03(\x0b2\x1c.grpc.LinuxInterfacePriorit\
    yR\nPrioritiesB\x04\xc8\xde\x1f\0\"F\n\x12LinuxHugepageLimit\x12\x1a\n\
    \x08Pagesize\x18\x01\x20\x01(\tR\x08Pagesize\x12\x14\n\x05Limit\x18\x02\
    \x20\x01(\x04R\x05Limit\"H\n\x16LinuxInterfacePriority\x12\x12\n\x04Name\
    \x18\x01\x20\x01(\tR\x04Name\x12\x1a\n\x08Priority\x18\x02\x20\x01(\rR\
    \x08Priority\"\x90\x01\n\x0cLinuxSeccomp\x12$\n\rDefaultAction\x18\x01\
    \x20\x01(\tR\rDefaultAction\x12$\n\rArchitectures\x18\x02\x20\x03(\tR\rA\
    rchitectures\x124\n\x08Syscalls\x18\x03\x20\x03(\x0b2\x12.grpc.LinuxSysc\
    allR\x08SyscallsB\x04\xc8\xde\x1f\0\"i\n\x0fLinuxSeccompArg\x12\x14\n\
    \x05Index\x18\x01\x20\x01(\x04R\x05Index\x12\x14\n\x05Value\x18\x02\x20\
    \x01(\x04R\x05Value\x12\x1a\n\x08ValueTwo\x18\x03\x20\x01(\x04R\x08Value\
    Two\x12\x0e\n\x02Op\x18\x04\x20\x01(\tR\x02Op\"m\n\x0cLinuxSyscall\x12\
    \x14\n\x05Names\x18\x01\x20\x03(\tR\x05Names\x12\x16\n\x06Action\x18\x02\
    \x20\x01(\tR\x06Action\x12/\n\x04Args\x18\x03\x20\x03(\x0b2\x15.grpc.Lin\
    uxSeccompArgR\x04ArgsB\x04\xc8\xde\x1f\0\"5\n\rLinuxIntelRdt\x12$\n\rL3C\
    acheSchema\x18\x01\x20\x01(\tR\rL3CacheSchemaBpZ^github.com/kata-contain\
    ers/kata-containers/src/runtime/virtcontainers/pkg/agent/protocols/grpc\
    \xf8\xe1\x1e\x01\xa8\xe2\x1e\x01\xc0\xe2\x1e\x01\xb8\xe2\x1e\x01J\xfe\
    \x93\x01\n\x07\x12\x05\x07\0\xd0\x03\x01\nz\n\x01\x0c\x12\x03\x07\0\x122\
    p\n\x20Copyright\x20(c)\x202017\x20Intel\x20Corporation\n\x20Copyright\
    \x20(c)\x202019\x20Ant\x20Financial\n\n\x20SPDX-License-Identifier:\x20A\
    pache-2.0\n\n\n\x08\n\x01\x08\x12\x03\t\0u\n\t\n\x02\x08\x0b\x12\x03\t\0\
    u\n\x08\n\x01\x02\x12\x03\x0b\0\r\n\t\n\x02\x03\0\x12\x03\r\07\n\t\n\x02\
    \x03\x01\x12\x03\x0e\0(\n\x08\n\x01\x08\x12\x03\x10\0$\n\x0b\n\x04\x08\
    \xa5\xec\x03\x12\x03\x10\0$\n\x08\n\x01\x08\x12\x03\x11\0'\n\x0b\n\x04\
    \x08\x9f\xec\x03\x12\x03\x11\0'\n\x08\n\x01\x08\x12\x03\x12\0&\n\x0b\n\
    \x04\x08\xa7\xec\x03\x12\x03\x12\0&\n\x08\n\x01\x08\x12\x03\x13\0'\n\x0b\
    \n\x04\x08\xa8\xec\x03\x12\x03\x13\0'\n\n\n\x02\x04\0\x12\x04\x15\02\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\x15\x08\x0c\nm\n\x04\x04\0\x02\0\x12\x03\
    \x17\x08\x1b\x1a`\x20Version\x20of\x20the\x20Open\x20Container\x20Initia\
    tive\x20Runtime\x20Specification\x20with\x20which\x20the\x20bundle\x20co\
    mplies.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x17\x08\x15\x0e\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x17\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x17\x0f\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x17\x19\x1a\n8\n\x04\
    \x04\0\x02\x01\x12\x03\x1a\x08\x1c\x1a+\x20Process\x20configures\x20the\
    \x20container\x20process.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x1a\x08\
    \x17\x1b\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x1a\x08\x0f\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03\x1a\x10\x17\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03\x1a\x1a\x1b\n?\n\x04\x04\0\x02\x02\x12\x03\x1d\x08\x16\x1a2\x20Root\
    \x20configures\x20the\x20container's\x20root\x20filesystem.\n\n\r\n\x05\
    \x04\0\x02\x02\x04\x12\x04\x1d\x08\x1a\x1c\n\x0c\n\x05\x04\0\x02\x02\x06\
    \x12\x03\x1d\x08\x0c\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x1d\r\x11\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1d\x14\x15\n<\n\x04\x04\0\x02\x03\
    \x12\x03\x20\x08\x1c\x1a/\x20Hostname\x20configures\x20the\x20container'\
    s\x20hostname.\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x20\x08\x1d\x16\n\
    \x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x20\x08\x0e\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03\x20\x0f\x17\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x20\
    \x1a\x1b\nD\n\x04\x04\0\x02\x04\x12\x03#\x08A\x1a7\x20Mounts\x20configur\
    es\x20additional\x20mounts\x20(on\x20top\x20of\x20Root).\n\n\x0c\n\x05\
    \x04\0\x02\x04\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x06\x12\
    \x03#\x11\x16\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03#\x17\x1d\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x03#\x20!\n\x0c\n\x05\x04\0\x02\x04\x08\x12\x03#\
    \"@\n\x0f\n\x08\x04\0\x02\x04\x08\xe9\xfb\x03\x12\x03##?\nI\n\x04\x04\0\
    \x02\x05\x12\x03&\x08\x18\x1a<\x20Hooks\x20configures\x20callbacks\x20fo\
    r\x20container\x20lifecycle\x20events.\n\n\r\n\x05\x04\0\x02\x05\x04\x12\
    \x04&\x08#A\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03&\x08\r\n\x0c\n\x05\x04\
    \0\x02\x05\x01\x12\x03&\x0e\x13\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03&\
    \x16\x17\nI\n\x04\x04\0\x02\x06\x12\x03)\x08,\x1a<\x20Annotations\x20con\
    tains\x20arbitrary\x20metadata\x20for\x20the\x20container.\n\n\r\n\x05\
    \x04\0\x02\x06\x04\x12\x04)\x08&\x18\n\x0c\n\x05\x04\0\x02\x06\x06\x12\
    \x03)\x08\x1b\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03)\x1c'\n\x0c\n\x05\
    \x04\0\x02\x06\x03\x12\x03)*+\nS\n\x04\x04\0\x02\x07\x12\x03,\x08\x18\
    \x1aF\x20Linux\x20is\x20platform-specific\x20configuration\x20for\x20Lin\
    ux\x20based\x20containers.\n\n\r\n\x05\x04\0\x02\x07\x04\x12\x04,\x08),\
    \n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03,\x08\r\n\x0c\n\x05\x04\0\x02\x07\
    \x01\x12\x03,\x0e\x13\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03,\x16\x17\nW\
    \n\x04\x04\0\x02\x08\x12\x03/\x08\x1c\x1aJ\x20Solaris\x20is\x20platform-\
    specific\x20configuration\x20for\x20Solaris\x20based\x20containers.\n\n\
    \r\n\x05\x04\0\x02\x08\x04\x12\x04/\x08,\x18\n\x0c\n\x05\x04\0\x02\x08\
    \x06\x12\x03/\x08\x0f\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03/\x10\x17\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03/\x1a\x1b\nW\n\x04\x04\0\x02\t\x12\
    \x031\x08\x1d\x1aJ\x20Windows\x20is\x20platform-specific\x20configuratio\
    n\x20for\x20Windows\x20based\x20containers.\n\n\r\n\x05\x04\0\x02\t\x04\
    \x12\x041\x08/\x1c\n\x0c\n\x05\x04\0\x02\t\x06\x12\x031\x08\x0f\n\x0c\n\
    \x05\x04\0\x02\t\x01\x12\x031\x10\x17\n\x0c\n\x05\x04\0\x02\t\x03\x12\
    \x031\x1a\x1c\n\n\n\x02\x04\x01\x12\x044\0Y\x01\n\n\n\x03\x04\x01\x01\
    \x12\x034\x08\x0f\nJ\n\x04\x04\x01\x02\0\x12\x036\x08\x1a\x1a=\x20Termin\
    al\x20creates\x20an\x20interactive\x20terminal\x20for\x20the\x20containe\
    r.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x046\x084\x11\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x036\x08\x0c\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x036\r\x15\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x036\x18\x19\n=\n\x04\x04\x01\x02\x01\
    \x12\x039\x08\x1c\x1a0\x20ConsoleSize\x20specifies\x20the\x20size\x20of\
    \x20the\x20console.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x049\x086\x1a\n\
    \x0c\n\x05\x04\x01\x02\x01\x06\x12\x039\x08\x0b\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x039\x0c\x17\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x039\x1a\
    \x1b\n?\n\x04\x04\x01\x02\x02\x12\x03<\x085\x1a2\x20User\x20specifies\
    \x20user\x20information\x20for\x20the\x20process.\n\n\r\n\x05\x04\x01\
    \x02\x02\x04\x12\x04<\x089\x1c\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03<\
    \x08\x0c\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03<\r\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x03<\x14\x15\n\x0c\n\x05\x04\x01\x02\x02\x08\x12\
    \x03<\x164\n\x0f\n\x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\x03<\x173\nV\
    \n\x04\x04\x01\x02\x03\x12\x03?\x08!\x1aI\x20Args\x20specifies\x20the\
    \x20binary\x20and\x20arguments\x20for\x20the\x20application\x20to\x20exe\
    cute.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03?\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x03\x05\x12\x03?\x11\x17\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\
    \x03?\x18\x1c\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03?\x1f\x20\nE\n\x04\
    \x04\x01\x02\x04\x12\x03B\x08\x20\x1a8\x20Env\x20populates\x20the\x20pro\
    cess\x20environment\x20for\x20the\x20process.\n\n\x0c\n\x05\x04\x01\x02\
    \x04\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03B\x11\
    \x17\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03B\x18\x1b\n\x0c\n\x05\x04\
    \x01\x02\x04\x03\x12\x03B\x1e\x1f\nr\n\x04\x04\x01\x02\x05\x12\x03F\x08\
    \x17\x1ae\x20Cwd\x20is\x20the\x20current\x20working\x20directory\x20for\
    \x20the\x20process\x20and\x20must\x20be\n\x20relative\x20to\x20the\x20co\
    ntainer's\x20root.\n\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04F\x08B\x20\n\
    \x0c\n\x05\x04\x01\x02\x05\x05\x12\x03F\x08\x0e\n\x0c\n\x05\x04\x01\x02\
    \x05\x01\x12\x03F\x0f\x12\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03F\x15\
    \x16\nQ\n\x04\x04\x01\x02\x06\x12\x03I\x08+\x1aD\x20Capabilities\x20are\
    \x20Linux\x20capabilities\x20that\x20are\x20kept\x20for\x20the\x20proces\
    s.\n\n\r\n\x05\x04\x01\x02\x06\x04\x12\x04I\x08F\x17\n\x0c\n\x05\x04\x01\
    \x02\x06\x06\x12\x03I\x08\x19\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03I\
    \x1a&\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03I)*\nH\n\x04\x04\x01\x02\
    \x07\x12\x03L\x08H\x1a;\x20Rlimits\x20specifies\x20rlimit\x20options\x20\
    to\x20apply\x20to\x20the\x20process.\n\n\x0c\n\x05\x04\x01\x02\x07\x04\
    \x12\x03L\x08\x10\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03L\x11\x1c\n\x0c\
    \n\x05\x04\x01\x02\x07\x01\x12\x03L\x1d$\n\x0c\n\x05\x04\x01\x02\x07\x03\
    \x12\x03L'(\n\x0c\n\x05\x04\x01\x02\x07\x08\x12\x03L)G\n\x0f\n\x08\x04\
    \x01\x02\x07\x08\xe9\xfb\x03\x12\x03L*F\nu\n\x04\x04\x01\x02\x08\x12\x03\
    O\x08!\x1ah\x20NoNewPrivileges\x20controls\x20whether\x20additional\x20p\
    rivileges\x20could\x20be\x20gained\x20by\x20processes\x20in\x20the\x20co\
    ntainer.\t\n\n\r\n\x05\x04\x01\x02\x08\x04\x12\x04O\x08LH\n\x0c\n\x05\
    \x04\x01\x02\x08\x05\x12\x03O\x08\x0c\n\x0c\n\x05\x04\x01\x02\x08\x01\
    \x12\x03O\r\x1c\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03O\x1f\x20\nP\n\
    \x04\x04\x01\x02\t\x12\x03R\x08$\x1aC\x20ApparmorProfile\x20specifies\
    \x20the\x20apparmor\x20profile\x20for\x20the\x20container.\n\n\r\n\x05\
    \x04\x01\x02\t\x04\x12\x04R\x08O!\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03R\
    \x08\x0e\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03R\x0f\x1e\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03R!#\n:\n\x04\x04\x01\x02\n\x12\x03U\x08\x1f\x1a-\
    \x20Specify\x20an\x20oom_score_adj\x20for\x20the\x20container.\n\n\r\n\
    \x05\x04\x01\x02\n\x04\x12\x04U\x08R$\n\x0c\n\x05\x04\x01\x02\n\x05\x12\
    \x03U\x08\r\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03U\x0e\x19\n\x0c\n\x05\
    \x04\x01\x02\n\x03\x12\x03U\x1c\x1e\n_\n\x04\x04\x01\x02\x0b\x12\x03X\
    \x08!\x1aR\x20SelinuxLabel\x20specifies\x20the\x20selinux\x20context\x20\
    that\x20the\x20container\x20process\x20is\x20run\x20as.\n\n\r\n\x05\x04\
    \x01\x02\x0b\x04\x12\x04X\x08U\x1f\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\
    \x03X\x08\x0e\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03X\x0f\x1b\n\x0c\n\
    \x05\x04\x01\x02\x0b\x03\x12\x03X\x1e\x20\n\n\n\x02\x04\x02\x12\x04[\0a\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03[\x08\x0b\n9\n\x04\x04\x02\x02\0\x12\
    \x03]\x08\x1a\x1a,\x20Height\x20is\x20the\x20vertical\x20dimension\x20of\
    \x20a\x20box.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x04]\x08[\r\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03]\x08\x0e\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03]\x0f\x15\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03]\x18\x19\n;\n\x04\
    \x04\x02\x02\x01\x12\x03`\x08\x19\x1a.\x20Width\x20is\x20the\x20horizont\
    al\x20dimension\x20of\x20a\x20box.\t\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\
    \x04`\x08]\x1a\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03`\x08\x0e\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03`\x0f\x14\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03`\x17\x18\n\n\n\x02\x04\x03\x12\x04c\0o\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03c\x08\x0c\n\"\n\x04\x04\x03\x02\0\x12\x03e\x08\x17\x1a\
    \x15\x20UID\x20is\x20the\x20user\x20id.\n\n\r\n\x05\x04\x03\x02\0\x04\
    \x12\x04e\x08c\x0e\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03e\x08\x0e\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03e\x0f\x12\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03e\x15\x16\n#\n\x04\x04\x03\x02\x01\x12\x03h\x08\x17\x1a\x16\x20G\
    ID\x20is\x20the\x20group\x20id.\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04h\
    \x08e\x17\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03h\x08\x0e\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03h\x0f\x12\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03h\x15\x16\nW\n\x04\x04\x03\x02\x02\x12\x03k\x08+\x1aJ\x20Additio\
    nalGids\x20are\x20additional\x20group\x20ids\x20set\x20for\x20the\x20con\
    tainer's\x20process.\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03k\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x03\
    \x02\x02\x01\x12\x03k\x18&\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03k)*\n)\
    \n\x04\x04\x03\x02\x03\x12\x03n\x08\x1c\x1a\x1c\x20Username\x20is\x20the\
    \x20user\x20name.\n\n\r\n\x05\x04\x03\x02\x03\x04\x12\x04n\x08k+\n\x0c\n\
    \x05\x04\x03\x02\x03\x05\x12\x03n\x08\x0e\n\x0c\n\x05\x04\x03\x02\x03\
    \x01\x12\x03n\x0f\x17\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03n\x1a\x1b\n\
    \x0b\n\x02\x04\x04\x12\x05q\0\x80\x01\x01\n\n\n\x03\x04\x04\x01\x12\x03q\
    \x08\x19\nI\n\x04\x04\x04\x02\0\x12\x03s\x08%\x1a<\x20Bounding\x20is\x20\
    the\x20set\x20of\x20capabilities\x20checked\x20by\x20the\x20kernel.\n\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03s\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03s\x18\x20\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03s#$\nJ\n\x04\x04\x04\x02\x01\x12\x03\
    v\x08&\x1a=\x20Effective\x20is\x20the\x20set\x20of\x20capabilities\x20ch\
    ecked\x20by\x20the\x20kernel.\n\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03v\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03v\x11\x17\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03v\x18!\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03v$%\nG\n\x04\x04\x04\x02\x02\x12\x03y\x08(\x1a:\x20Inheritable\x20is\
    \x20the\x20capabilities\x20preserved\x20across\x20execve.\n\n\x0c\n\x05\
    \x04\x04\x02\x02\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\
    \x12\x03y\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03y\x18#\n\x0c\n\
    \x05\x04\x04\x02\x02\x03\x12\x03y&'\nM\n\x04\x04\x04\x02\x03\x12\x03|\
    \x08&\x1a@\x20Permitted\x20is\x20the\x20limiting\x20superset\x20for\x20e\
    ffective\x20capabilities.\n\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03|\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\
    \x04\x02\x03\x01\x12\x03|\x18!\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03|$\
    %\nH\n\x04\x04\x04\x02\x04\x12\x03\x7f\x08$\x1a;\x20Ambient\x20is\x20the\
    \x20ambient\x20set\x20of\x20capabilities\x20that\x20are\x20kept.\n\n\x0c\
    \n\x05\x04\x04\x02\x04\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \x04\x05\x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03\x7f\
    \x18\x1f\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03\x7f\"#\n\x0c\n\x02\x04\
    \x05\x12\x06\x82\x01\0\x8b\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x82\
    \x01\x08\x13\n)\n\x04\x04\x05\x02\0\x12\x04\x84\x01\x08\x18\x1a\x1b\x20T\
    ype\x20of\x20the\x20rlimit\x20to\x20set\n\n\x0f\n\x05\x04\x05\x02\0\x04\
    \x12\x06\x84\x01\x08\x82\x01\x15\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x84\
    \x01\x08\x0e\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x84\x01\x0f\x13\n\r\n\
    \x05\x04\x05\x02\0\x03\x12\x04\x84\x01\x16\x17\n=\n\x04\x04\x05\x02\x01\
    \x12\x04\x87\x01\x08\x18\x1a/\x20Hard\x20is\x20the\x20hard\x20limit\x20f\
    or\x20the\x20specified\x20type\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\
    \x87\x01\x08\x84\x01\x18\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x87\x01\
    \x08\x0e\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x87\x01\x0f\x13\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\x87\x01\x16\x17\n=\n\x04\x04\x05\x02\x02\
    \x12\x04\x8a\x01\x08\x18\x1a/\x20Soft\x20is\x20the\x20soft\x20limit\x20f\
    or\x20the\x20specified\x20type\n\n\x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\
    \x8a\x01\x08\x87\x01\x18\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x8a\x01\
    \x08\x0e\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x8a\x01\x0f\x13\n\r\n\x05\
    \x04\x05\x02\x02\x03\x12\x04\x8a\x01\x16\x17\n\x0c\n\x02\x04\x06\x12\x06\
    \x8d\x01\0\x98\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x8d\x01\x08\r\n_\
    \n\x04\x04\x06\x02\0\x12\x04\x8f\x01\x08\x1f\x1aQ\x20destination\x20is\
    \x20the\x20path\x20inside\x20the\x20container\x20expect\x20when\x20it\
    \x20starts\x20with\x20\"tmp:/\"\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\
    \x8f\x01\x08\x8d\x01\x0f\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x8f\x01\x08\
    \x0e\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x8f\x01\x0f\x1a\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\x8f\x01\x1d\x1e\n\xb4\x02\n\x04\x04\x06\x02\x01\
    \x12\x04\x95\x01\x08\x1a\x1a\xa5\x02\x20source\x20is\x20the\x20path\x20i\
    nside\x20the\x20container\x20expect\x20when\x20it\x20starts\x20with\x20\
    \"vm:/dev/\"\x20or\x20\"tmp:/\"\n\x20the\x20path\x20which\x20starts\x20w\
    ith\x20\"vm:/dev/\"\x20refers\x20the\x20guest\x20vm's\x20\"/dev\",\n\x20\
    especially,\x20\"vm:/dev/hostfs/\"\x20refers\x20to\x20the\x20shared\x20f\
    ilesystem.\n\x20\"tmp:/\"\x20is\x20a\x20temporary\x20directory\x20which\
    \x20is\x20used\x20for\x20temporary\x20mounts.\n\n\x0f\n\x05\x04\x06\x02\
    \x01\x04\x12\x06\x95\x01\x08\x8f\x01\x1f\n\r\n\x05\x04\x06\x02\x01\x05\
    \x12\x04\x95\x01\x08\x0e\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x95\x01\
    \x0f\x15\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x95\x01\x18\x19\n\x0c\n\
    \x04\x04\x06\x02\x02\x12\x04\x96\x01\x08\x18\n\x0f\n\x05\x04\x06\x02\x02\
    \x04\x12\x06\x96\x01\x08\x95\x01\x1a\n\r\n\x05\x04\x06\x02\x02\x05\x12\
    \x04\x96\x01\x08\x0e\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\x96\x01\x0f\
    \x13\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x96\x01\x16\x17\n\x0c\n\x04\
    \x04\x06\x02\x03\x12\x04\x97\x01\x08$\n\r\n\x05\x04\x06\x02\x03\x04\x12\
    \x04\x97\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\x97\x01\x11\
    \x17\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x97\x01\x18\x1f\n\r\n\x05\x04\
    \x06\x02\x03\x03\x12\x04\x97\x01\"#\n\x0c\n\x02\x04\x07\x12\x06\x9a\x01\
    \0\xa0\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x9a\x01\x08\x0c\nM\n\x04\
    \x04\x07\x02\0\x12\x04\x9c\x01\x08\x18\x1a?\x20Path\x20is\x20the\x20abso\
    lute\x20path\x20to\x20the\x20container's\x20root\x20filesystem.\n\n\x0f\
    \n\x05\x04\x07\x02\0\x04\x12\x06\x9c\x01\x08\x9a\x01\x0e\n\r\n\x05\x04\
    \x07\x02\0\x05\x12\x04\x9c\x01\x08\x0e\n\r\n\x05\x04\x07\x02\0\x01\x12\
    \x04\x9c\x01\x0f\x13\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x9c\x01\x16\x17\
    \nm\n\x04\x04\x07\x02\x01\x12\x04\x9f\x01\x08\x1a\x1a_\x20Readonly\x20ma\
    kes\x20the\x20root\x20filesystem\x20for\x20the\x20container\x20readonly\
    \x20before\x20the\x20process\x20is\x20executed.\n\n\x0f\n\x05\x04\x07\
    \x02\x01\x04\x12\x06\x9f\x01\x08\x9c\x01\x18\n\r\n\x05\x04\x07\x02\x01\
    \x05\x12\x04\x9f\x01\x08\x0c\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x9f\
    \x01\r\x15\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9f\x01\x18\x19\n\x0c\n\
    \x02\x04\x08\x12\x06\xa2\x01\0\xab\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xa2\x01\x08\r\n_\n\x04\x04\x08\x02\0\x12\x04\xa4\x01\x08C\x1aQ\x20P\
    restart\x20is\x20a\x20list\x20of\x20hooks\x20to\x20be\x20run\x20before\
    \x20the\x20container\x20process\x20is\x20executed.\n\n\r\n\x05\x04\x08\
    \x02\0\x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\
    \xa4\x01\x11\x15\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xa4\x01\x16\x1e\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\xa4\x01!\"\n\r\n\x05\x04\x08\x02\0\x08\
    \x12\x04\xa4\x01$B\n\x10\n\x08\x04\x08\x02\0\x08\xe9\xfb\x03\x12\x04\xa4\
    \x01%A\n^\n\x04\x04\x08\x02\x01\x12\x04\xa7\x01\x08D\x1aP\x20Poststart\
    \x20is\x20a\x20list\x20of\x20hooks\x20to\x20be\x20run\x20after\x20the\
    \x20container\x20process\x20is\x20started.\n\n\r\n\x05\x04\x08\x02\x01\
    \x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xa7\
    \x01\x11\x15\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa7\x01\x16\x1f\n\r\n\
    \x05\x04\x08\x02\x01\x03\x12\x04\xa7\x01\"#\n\r\n\x05\x04\x08\x02\x01\
    \x08\x12\x04\xa7\x01%C\n\x10\n\x08\x04\x08\x02\x01\x08\xe9\xfb\x03\x12\
    \x04\xa7\x01&B\nX\n\x04\x04\x08\x02\x02\x12\x04\xaa\x01\x08C\x1aJ\x20Pos\
    tstop\x20is\x20a\x20list\x20of\x20hooks\x20to\x20be\x20run\x20after\x20t\
    he\x20container\x20process\x20exits.\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\
    \x04\xaa\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xaa\x01\x11\
    \x15\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xaa\x01\x16\x1e\n\r\n\x05\x04\
    \x08\x02\x02\x03\x12\x04\xaa\x01!\"\n\r\n\x05\x04\x08\x02\x02\x08\x12\
    \x04\xaa\x01$B\n\x10\n\x08\x04\x08\x02\x02\x08\xe9\xfb\x03\x12\x04\xaa\
    \x01%A\n\x0c\n\x02\x04\t\x12\x06\xad\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\t\
    \x01\x12\x04\xad\x01\x08\x0c\n\x0c\n\x04\x04\t\x02\0\x12\x04\xae\x01\x08\
    \x18\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xae\x01\x08\xad\x01\x0e\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xae\x01\x08\x0e\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xae\x01\x0f\x13\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xae\x01\x16\
    \x17\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xaf\x01\x08!\n\r\n\x05\x04\t\x02\
    \x01\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xaf\
    \x01\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xaf\x01\x18\x1c\n\r\n\
    \x05\x04\t\x02\x01\x03\x12\x04\xaf\x01\x1f\x20\n\x0c\n\x04\x04\t\x02\x02\
    \x12\x04\xb0\x01\x08\x20\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xb0\x01\x08\
    \x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xb0\x01\x11\x17\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\xb0\x01\x18\x1b\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \xb0\x01\x1e\x1f\n\x0c\n\x04\x04\t\x02\x03\x12\x04\xb1\x01\x08\x1a\n\x0f\
    \n\x05\x04\t\x02\x03\x04\x12\x06\xb1\x01\x08\xb0\x01\x20\n\r\n\x05\x04\t\
    \x02\x03\x05\x12\x04\xb1\x01\x08\r\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\
    \xb1\x01\x0e\x15\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xb1\x01\x18\x19\n\
    \x0c\n\x02\x04\n\x12\x06\xb4\x01\0\xdf\x01\x01\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xb4\x01\x08\r\nR\n\x04\x04\n\x02\0\x12\x04\xb6\x01\x08P\x1aD\x20UID\
    Mapping\x20specifies\x20user\x20mappings\x20for\x20supporting\x20user\
    \x20namespaces.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb6\x01\x08\x10\n\r\
    \n\x05\x04\n\x02\0\x06\x12\x04\xb6\x01\x11\x1f\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xb6\x01\x20+\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb6\x01./\n\r\n\
    \x05\x04\n\x02\0\x08\x12\x04\xb6\x011O\n\x10\n\x08\x04\n\x02\0\x08\xe9\
    \xfb\x03\x12\x04\xb6\x012N\nS\n\x04\x04\n\x02\x01\x12\x04\xb9\x01\x08P\
    \x1aE\x20GIDMapping\x20specifies\x20group\x20mappings\x20for\x20supporti\
    ng\x20user\x20namespaces.\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xb9\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xb9\x01\x11\x1f\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xb9\x01\x20+\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xb9\x01./\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\xb9\x011O\n\x10\n\x08\
    \x04\n\x02\x01\x08\xe9\xfb\x03\x12\x04\xb9\x012N\n[\n\x04\x04\n\x02\x02\
    \x12\x04\xbc\x01\x08'\x1aM\x20Sysctl\x20are\x20a\x20set\x20of\x20key\x20\
    value\x20pairs\x20that\x20are\x20set\x20for\x20the\x20container\x20on\
    \x20start\n\n\x0f\n\x05\x04\n\x02\x02\x04\x12\x06\xbc\x01\x08\xb9\x01P\n\
    \r\n\x05\x04\n\x02\x02\x06\x12\x04\xbc\x01\x08\x1b\n\r\n\x05\x04\n\x02\
    \x02\x01\x12\x04\xbc\x01\x1c\"\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xbc\
    \x01%&\ni\n\x04\x04\n\x02\x03\x12\x04\xc0\x01\x08%\x1a[\x20Resources\x20\
    contain\x20cgroup\x20information\x20for\x20handling\x20resource\x20const\
    raints\n\x20for\x20the\x20container\n\n\x0f\n\x05\x04\n\x02\x03\x04\x12\
    \x06\xc0\x01\x08\xbc\x01'\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xc0\x01\
    \x08\x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xc0\x01\x17\x20\n\r\n\x05\
    \x04\n\x02\x03\x03\x12\x04\xc0\x01#$\n\x87\x02\n\x04\x04\n\x02\x04\x12\
    \x04\xc5\x01\x08\x1f\x1a\xf8\x01\x20CgroupsPath\x20specifies\x20the\x20p\
    ath\x20to\x20cgroups\x20that\x20are\x20created\x20and/or\x20joined\x20by\
    \x20the\x20container.\n\x20The\x20path\x20is\x20expected\x20to\x20be\x20\
    relative\x20to\x20the\x20cgroups\x20mountpoint.\n\x20If\x20resources\x20\
    are\x20specified,\x20the\x20cgroups\x20at\x20CgroupsPath\x20will\x20be\
    \x20updated\x20based\x20on\x20resources.\n\n\x0f\n\x05\x04\n\x02\x04\x04\
    \x12\x06\xc5\x01\x08\xc0\x01%\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xc5\
    \x01\x08\x0e\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xc5\x01\x0f\x1a\n\r\n\
    \x05\x04\n\x02\x04\x03\x12\x04\xc5\x01\x1d\x1e\nb\n\x04\x04\n\x02\x05\
    \x12\x04\xc8\x01\x08O\x1aT\x20Namespaces\x20contains\x20the\x20namespace\
    s\x20that\x20are\x20created\x20and/or\x20joined\x20by\x20the\x20containe\
    r\n\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\n\
    \x02\x05\x06\x12\x04\xc8\x01\x11\x1f\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\
    \xc8\x01\x20*\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xc8\x01-.\n\r\n\x05\
    \x04\n\x02\x05\x08\x12\x04\xc8\x010N\n\x10\n\x08\x04\n\x02\x05\x08\xe9\
    \xfb\x03\x12\x04\xc8\x011M\nU\n\x04\x04\n\x02\x06\x12\x04\xcb\x01\x08I\
    \x1aG\x20Devices\x20are\x20a\x20list\x20of\x20device\x20nodes\x20that\
    \x20are\x20created\x20for\x20the\x20container\n\n\r\n\x05\x04\n\x02\x06\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\n\x02\x06\x06\x12\x04\xcb\x01\
    \x11\x1c\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xcb\x01\x1d$\n\r\n\x05\x04\
    \n\x02\x06\x03\x12\x04\xcb\x01'(\n\r\n\x05\x04\n\x02\x06\x08\x12\x04\xcb\
    \x01*H\n\x10\n\x08\x04\n\x02\x06\x08\xe9\xfb\x03\x12\x04\xcb\x01+G\nR\n\
    \x04\x04\n\x02\x07\x12\x04\xce\x01\x08!\x1aD\x20Seccomp\x20specifies\x20\
    the\x20seccomp\x20security\x20settings\x20for\x20the\x20container.\n\n\
    \x0f\n\x05\x04\n\x02\x07\x04\x12\x06\xce\x01\x08\xcb\x01I\n\r\n\x05\x04\
    \n\x02\x07\x06\x12\x04\xce\x01\x08\x14\n\r\n\x05\x04\n\x02\x07\x01\x12\
    \x04\xce\x01\x15\x1c\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\xce\x01\x1f\x20\
    \nY\n\x04\x04\n\x02\x08\x12\x04\xd1\x01\x08%\x1aK\x20RootfsPropagation\
    \x20is\x20the\x20rootfs\x20mount\x20propagation\x20mode\x20for\x20the\
    \x20container.\n\n\x0f\n\x05\x04\n\x02\x08\x04\x12\x06\xd1\x01\x08\xce\
    \x01!\n\r\n\x05\x04\n\x02\x08\x05\x12\x04\xd1\x01\x08\x0e\n\r\n\x05\x04\
    \n\x02\x08\x01\x12\x04\xd1\x01\x0f\x20\n\r\n\x05\x04\n\x02\x08\x03\x12\
    \x04\xd1\x01#$\nO\n\x04\x04\n\x02\t\x12\x04\xd4\x01\x08)\x1aA\x20MaskedP\
    aths\x20masks\x20over\x20the\x20provided\x20paths\x20inside\x20the\x20co\
    ntainer.\n\n\r\n\x05\x04\n\x02\t\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\t\x05\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\n\x02\t\x01\x12\
    \x04\xd4\x01\x18#\n\r\n\x05\x04\n\x02\t\x03\x12\x04\xd4\x01&(\nQ\n\x04\
    \x04\n\x02\n\x12\x04\xd7\x01\x08+\x1aC\x20ReadonlyPaths\x20sets\x20the\
    \x20provided\x20paths\x20as\x20RO\x20inside\x20the\x20container.\n\n\r\n\
    \x05\x04\n\x02\n\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\n\x02\n\x05\
    \x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\n\x02\n\x01\x12\x04\xd7\x01\x18%\
    \n\r\n\x05\x04\n\x02\n\x03\x12\x04\xd7\x01(*\nY\n\x04\x04\n\x02\x0b\x12\
    \x04\xda\x01\x08\x1f\x1aK\x20MountLabel\x20specifies\x20the\x20selinux\
    \x20context\x20for\x20the\x20mounts\x20in\x20the\x20container.\n\n\x0f\n\
    \x05\x04\n\x02\x0b\x04\x12\x06\xda\x01\x08\xd7\x01+\n\r\n\x05\x04\n\x02\
    \x0b\x05\x12\x04\xda\x01\x08\x0e\n\r\n\x05\x04\n\x02\x0b\x01\x12\x04\xda\
    \x01\x0f\x19\n\r\n\x05\x04\n\x02\x0b\x03\x12\x04\xda\x01\x1c\x1e\n\x9d\
    \x01\n\x04\x04\n\x02\x0c\x12\x04\xde\x01\x08$\x1a\x8e\x01\x20IntelRdt\
    \x20contains\x20Intel\x20Resource\x20Director\x20Technology\x20(RDT)\x20\
    information\n\x20for\x20handling\x20resource\x20constraints\x20(e.g.,\
    \x20L3\x20cache)\x20for\x20the\x20container\n\n\x0f\n\x05\x04\n\x02\x0c\
    \x04\x12\x06\xde\x01\x08\xda\x01\x1f\n\r\n\x05\x04\n\x02\x0c\x06\x12\x04\
    \xde\x01\x08\x15\n\r\n\x05\x04\n\x02\x0c\x01\x12\x04\xde\x01\x16\x1e\n\r\
    \n\x05\x04\n\x02\x0c\x03\x12\x04\xde\x01!#\n\x0c\n\x02\x04\x0b\x12\x06\
    \xe1\x01\0\xe4\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xe1\x01\x08\x0f\n\
    )\n\x04\x04\x0b\x02\0\x12\x04\xe3\x01\x08\x19\x1a\x1b\x20Dummy\x20string\
    ,\x20never\x20used.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xe3\x01\x08\
    \xe1\x01\x11\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xe3\x01\x08\x0e\n\r\n\
    \x05\x04\x0b\x02\0\x01\x12\x04\xe3\x01\x0f\x14\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\xe3\x01\x17\x18\n\x0c\n\x02\x04\x0c\x12\x06\xe6\x01\0\xe9\
    \x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xe6\x01\x08\x0f\n)\n\x04\x04\
    \x0c\x02\0\x12\x04\xe8\x01\x08\x19\x1a\x1b\x20Dummy\x20string,\x20never\
    \x20used.\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xe8\x01\x08\xe6\x01\
    \x11\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xe8\x01\x08\x0e\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\xe8\x01\x0f\x14\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\xe8\x01\x17\x18\n\x0c\n\x02\x04\r\x12\x06\xeb\x01\0\xf4\x01\x01\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xeb\x01\x08\x16\nX\n\x04\x04\r\x02\0\x12\
    \x04\xed\x01\x08\x1a\x1aJ\x20HostID\x20is\x20the\x20starting\x20UID/GID\
    \x20on\x20the\x20host\x20to\x20be\x20mapped\x20to\x20'ContainerID'\n\n\
    \x0f\n\x05\x04\r\x02\0\x04\x12\x06\xed\x01\x08\xeb\x01\x18\n\r\n\x05\x04\
    \r\x02\0\x05\x12\x04\xed\x01\x08\x0e\n\r\n\x05\x04\r\x02\0\x01\x12\x04\
    \xed\x01\x0f\x15\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xed\x01\x18\x19\nD\n\
    \x04\x04\r\x02\x01\x12\x04\xf0\x01\x08\x1f\x1a6\x20ContainerID\x20is\x20\
    the\x20starting\x20UID/GID\x20in\x20the\x20container\n\n\x0f\n\x05\x04\r\
    \x02\x01\x04\x12\x06\xf0\x01\x08\xed\x01\x1a\n\r\n\x05\x04\r\x02\x01\x05\
    \x12\x04\xf0\x01\x08\x0e\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xf0\x01\x0f\
    \x1a\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xf0\x01\x1d\x1e\n6\n\x04\x04\r\
    \x02\x02\x12\x04\xf3\x01\x08\x18\x1a(\x20Size\x20is\x20the\x20number\x20\
    of\x20IDs\x20to\x20be\x20mapped\n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\
    \xf3\x01\x08\xf0\x01\x1f\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xf3\x01\x08\
    \x0e\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xf3\x01\x0f\x13\n\r\n\x05\x04\r\
    \x02\x02\x03\x12\x04\xf3\x01\x16\x17\n\x0c\n\x02\x04\x0e\x12\x06\xf6\x01\
    \0\xfd\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xf6\x01\x08\x16\n-\n\x04\
    \x04\x0e\x02\0\x12\x04\xf8\x01\x08\x18\x1a\x1f\x20Type\x20is\x20the\x20t\
    ype\x20of\x20namespace\n\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xf8\x01\
    \x08\xf6\x01\x18\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xf8\x01\x08\x0e\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xf8\x01\x0f\x13\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xf8\x01\x16\x17\nu\n\x04\x04\x0e\x02\x01\x12\x04\xfc\x01\
    \x08\x18\x1ag\x20Path\x20is\x20a\x20path\x20to\x20an\x20existing\x20name\
    space\x20persisted\x20on\x20disk\x20that\x20can\x20be\x20joined\n\x20and\
    \x20is\x20of\x20the\x20same\x20type\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\
    \x12\x06\xfc\x01\x08\xf8\x01\x18\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \xfc\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xfc\x01\x0f\x13\n\
    \r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xfc\x01\x16\x17\n\x0c\n\x02\x04\x0f\
    \x12\x06\xff\x01\0\x94\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xff\x01\
    \x08\x13\n#\n\x04\x04\x0f\x02\0\x12\x04\x81\x02\x08\x18\x1a\x15\x20Path\
    \x20to\x20the\x20device.\n\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\x81\x02\
    \x08\xff\x01\x15\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x81\x02\x08\x0e\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\x81\x02\x0f\x13\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\x81\x02\x16\x17\n.\n\x04\x04\x0f\x02\x01\x12\x04\x84\x02\
    \x08\x18\x1a\x20\x20Device\x20type,\x20block,\x20char,\x20etc.\n\n\x0f\n\
    \x05\x04\x0f\x02\x01\x04\x12\x06\x84\x02\x08\x81\x02\x18\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\x84\x02\x08\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\x84\x02\x0f\x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x84\x02\
    \x16\x17\n3\n\x04\x04\x0f\x02\x02\x12\x04\x87\x02\x08\x18\x1a%\x20Major\
    \x20is\x20the\x20device's\x20major\x20number.\n\n\x0f\n\x05\x04\x0f\x02\
    \x02\x04\x12\x06\x87\x02\x08\x84\x02\x18\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\x87\x02\x08\r\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x87\x02\x0e\
    \x13\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x87\x02\x16\x17\n3\n\x04\x04\
    \x0f\x02\x03\x12\x04\x8a\x02\x08\x18\x1a%\x20Minor\x20is\x20the\x20devic\
    e's\x20minor\x20number.\n\n\x0f\n\x05\x04\x0f\x02\x03\x04\x12\x06\x8a\
    \x02\x08\x87\x02\x18\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x8a\x02\x08\r\
    \n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x8a\x02\x0e\x13\n\r\n\x05\x04\x0f\
    \x02\x03\x03\x12\x04\x8a\x02\x16\x17\n8\n\x04\x04\x0f\x02\x04\x12\x04\
    \x8d\x02\x08\x1c\x1a*\x20FileMode\x20permission\x20bits\x20for\x20the\
    \x20device.\n\n\x0f\n\x05\x04\x0f\x02\x04\x04\x12\x06\x8d\x02\x08\x8a\
    \x02\x18\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x8d\x02\x08\x0e\n\r\n\x05\
    \x04\x0f\x02\x04\x01\x12\x04\x8d\x02\x0f\x17\n\r\n\x05\x04\x0f\x02\x04\
    \x03\x12\x04\x8d\x02\x1a\x1b\n\"\n\x04\x04\x0f\x02\x05\x12\x04\x90\x02\
    \x08\x17\x1a\x14\x20UID\x20of\x20the\x20device.\n\n\x0f\n\x05\x04\x0f\
    \x02\x05\x04\x12\x06\x90\x02\x08\x8d\x02\x1c\n\r\n\x05\x04\x0f\x02\x05\
    \x05\x12\x04\x90\x02\x08\x0e\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x90\
    \x02\x0f\x12\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x90\x02\x15\x16\n\"\n\
    \x04\x04\x0f\x02\x06\x12\x04\x93\x02\x08\x17\x1a\x14\x20Gid\x20of\x20the\
    \x20device.\n\n\x0f\n\x05\x04\x0f\x02\x06\x04\x12\x06\x93\x02\x08\x90\
    \x02\x17\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\x93\x02\x08\x0e\n\r\n\x05\
    \x04\x0f\x02\x06\x01\x12\x04\x93\x02\x0f\x12\n\r\n\x05\x04\x0f\x02\x06\
    \x03\x12\x04\x93\x02\x15\x16\n\x0c\n\x02\x04\x10\x12\x06\x96\x02\0\xab\
    \x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x96\x02\x08\x16\n8\n\x04\x04\
    \x10\x02\0\x12\x04\x98\x02\x08O\x1a*\x20Devices\x20configures\x20the\x20\
    device\x20whitelist.\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x98\x02\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\x98\x02\x11\"\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\x98\x02#*\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x98\x02\
    -.\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\x98\x020N\n\x10\n\x08\x04\x10\x02\
    \0\x08\xe9\xfb\x03\x12\x04\x98\x021M\n0\n\x04\x04\x10\x02\x01\x12\x04\
    \x9b\x02\x08\x1f\x1a\"\x20Memory\x20restriction\x20configuration\n\n\x0f\
    \n\x05\x04\x10\x02\x01\x04\x12\x06\x9b\x02\x08\x98\x02O\n\r\n\x05\x04\
    \x10\x02\x01\x06\x12\x04\x9b\x02\x08\x13\n\r\n\x05\x04\x10\x02\x01\x01\
    \x12\x04\x9b\x02\x14\x1a\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9b\x02\
    \x1d\x1e\n6\n\x04\x04\x10\x02\x02\x12\x04\x9e\x02\x08\x19\x1a(\x20CPU\
    \x20resource\x20restriction\x20configuration\n\n\x0f\n\x05\x04\x10\x02\
    \x02\x04\x12\x06\x9e\x02\x08\x9b\x02\x1f\n\r\n\x05\x04\x10\x02\x02\x06\
    \x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x9e\x02\
    \x11\x14\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x9e\x02\x17\x18\n8\n\x04\
    \x04\x10\x02\x03\x12\x04\xa1\x02\x08\x1b\x1a*\x20Task\x20resource\x20res\
    triction\x20configuration.\n\n\x0f\n\x05\x04\x10\x02\x03\x04\x12\x06\xa1\
    \x02\x08\x9e\x02\x19\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\xa1\x02\x08\
    \x11\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xa1\x02\x12\x16\n\r\n\x05\x04\
    \x10\x02\x03\x03\x12\x04\xa1\x02\x19\x1a\n1\n\x04\x04\x10\x02\x04\x12\
    \x04\xa4\x02\x08!\x1a#\x20BlockIO\x20restriction\x20configuration\n\n\
    \x0f\n\x05\x04\x10\x02\x04\x04\x12\x06\xa4\x02\x08\xa1\x02\x1b\n\r\n\x05\
    \x04\x10\x02\x04\x06\x12\x04\xa4\x02\x08\x14\n\r\n\x05\x04\x10\x02\x04\
    \x01\x12\x04\xa4\x02\x15\x1c\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xa4\
    \x02\x1f\x20\n(\n\x04\x04\x10\x02\x05\x12\x04\xa7\x02\x08W\x1a\x1a\x20Hu\
    getlb\x20limit\x20(in\x20bytes)\n\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\
    \xa7\x02\x08\x10\n\r\n\x05\x04\x10\x02\x05\x06\x12\x04\xa7\x02\x11#\n\r\
    \n\x05\x04\x10\x02\x05\x01\x12\x04\xa7\x02$2\n\r\n\x05\x04\x10\x02\x05\
    \x03\x12\x04\xa7\x0256\n\r\n\x05\x04\x10\x02\x05\x08\x12\x04\xa7\x028V\n\
    \x10\n\x08\x04\x10\x02\x05\x08\xe9\xfb\x03\x12\x04\xa7\x029U\n1\n\x04\
    \x04\x10\x02\x06\x12\x04\xaa\x02\x08!\x1a#\x20Network\x20restriction\x20\
    configuration\n\n\x0f\n\x05\x04\x10\x02\x06\x04\x12\x06\xaa\x02\x08\xa7\
    \x02W\n\r\n\x05\x04\x10\x02\x06\x06\x12\x04\xaa\x02\x08\x14\n\r\n\x05\
    \x04\x10\x02\x06\x01\x12\x04\xaa\x02\x15\x1c\n\r\n\x05\x04\x10\x02\x06\
    \x03\x12\x04\xaa\x02\x1f\x20\n\x0c\n\x02\x04\x11\x12\x06\xad\x02\0\xc2\
    \x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xad\x02\x08\x13\n(\n\x04\x04\
    \x11\x02\0\x12\x04\xaf\x02\x08\x18\x1a\x1a\x20Memory\x20limit\x20(in\x20\
    bytes).\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xaf\x02\x08\xad\x02\x15\
    \n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xaf\x02\x08\r\n\r\n\x05\x04\x11\x02\
    \0\x01\x12\x04\xaf\x02\x0e\x13\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xaf\
    \x02\x16\x17\n<\n\x04\x04\x11\x02\x01\x12\x04\xb2\x02\x08\x1e\x1a.\x20Me\
    mory\x20reservation\x20or\x20soft_limit\x20(in\x20bytes).\n\n\x0f\n\x05\
    \x04\x11\x02\x01\x04\x12\x06\xb2\x02\x08\xaf\x02\x18\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xb2\x02\x08\r\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xb2\x02\x0e\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb2\x02\x1c\x1d\n\
    3\n\x04\x04\x11\x02\x02\x12\x04\xb5\x02\x08\x17\x1a%\x20Total\x20memory\
    \x20limit\x20(memory\x20+\x20swap).\n\n\x0f\n\x05\x04\x11\x02\x02\x04\
    \x12\x06\xb5\x02\x08\xb2\x02\x1e\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\
    \xb5\x02\x08\r\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb5\x02\x0e\x12\n\r\
    \n\x05\x04\x11\x02\x02\x03\x12\x04\xb5\x02\x15\x16\n/\n\x04\x04\x11\x02\
    \x03\x12\x04\xb8\x02\x08\x19\x1a!\x20Kernel\x20memory\x20limit\x20(in\
    \x20bytes).\n\n\x0f\n\x05\x04\x11\x02\x03\x04\x12\x06\xb8\x02\x08\xb5\
    \x02\x17\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xb8\x02\x08\r\n\r\n\x05\
    \x04\x11\x02\x03\x01\x12\x04\xb8\x02\x0e\x14\n\r\n\x05\x04\x11\x02\x03\
    \x03\x12\x04\xb8\x02\x17\x18\n6\n\x04\x04\x11\x02\x04\x12\x04\xbb\x02\
    \x08\x1c\x1a(\x20Kernel\x20memory\x20limit\x20for\x20tcp\x20(in\x20bytes\
    )\n\n\x0f\n\x05\x04\x11\x02\x04\x04\x12\x06\xbb\x02\x08\xb8\x02\x19\n\r\
    \n\x05\x04\x11\x02\x04\x05\x12\x04\xbb\x02\x08\r\n\r\n\x05\x04\x11\x02\
    \x04\x01\x12\x04\xbb\x02\x0e\x17\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\
    \xbb\x02\x1a\x1b\nA\n\x04\x04\x11\x02\x05\x12\x04\xbe\x02\x08\x1e\x1a3\
    \x20How\x20aggressive\x20the\x20kernel\x20will\x20swap\x20memory\x20page\
    s.\n\n\x0f\n\x05\x04\x11\x02\x05\x04\x12\x06\xbe\x02\x08\xbb\x02\x1c\n\r\
    \n\x05\x04\x11\x02\x05\x05\x12\x04\xbe\x02\x08\x0e\n\r\n\x05\x04\x11\x02\
    \x05\x01\x12\x04\xbe\x02\x0f\x19\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\
    \xbe\x02\x1c\x1d\nU\n\x04\x04\x11\x02\x06\x12\x04\xc1\x02\x08\"\x1aG\x20\
    DisableOOMKiller\x20disables\x20the\x20OOM\x20killer\x20for\x20out\x20of\
    \x20memory\x20conditions\n\n\x0f\n\x05\x04\x11\x02\x06\x04\x12\x06\xc1\
    \x02\x08\xbe\x02\x1e\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xc1\x02\x08\
    \x0c\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xc1\x02\r\x1d\n\r\n\x05\x04\
    \x11\x02\x06\x03\x12\x04\xc1\x02\x20!\n\x0c\n\x02\x04\x12\x12\x06\xc4\
    \x02\0\xd9\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xc4\x02\x08\x10\nW\n\
    \x04\x04\x12\x02\0\x12\x04\xc6\x02\x08\x1a\x1aI\x20CPU\x20shares\x20(rel\
    ative\x20weight\x20(ratio)\x20vs.\x20other\x20cgroups\x20with\x20cpu\x20\
    shares).\n\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\xc6\x02\x08\xc4\x02\x12\
    \n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xc6\x02\x08\x0e\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xc6\x02\x0f\x15\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \xc6\x02\x18\x19\nQ\n\x04\x04\x12\x02\x01\x12\x04\xc9\x02\x08\x18\x1aC\
    \x20CPU\x20hardcap\x20limit\x20(in\x20usecs).\x20Allowed\x20cpu\x20time\
    \x20in\x20a\x20given\x20period.\n\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\
    \x06\xc9\x02\x08\xc6\x02\x1a\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xc9\
    \x02\x08\r\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xc9\x02\x0e\x13\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\xc9\x02\x16\x17\nA\n\x04\x04\x12\x02\
    \x02\x12\x04\xcc\x02\x08\x1a\x1a3\x20CPU\x20period\x20to\x20be\x20used\
    \x20for\x20hardcapping\x20(in\x20usecs).\n\n\x0f\n\x05\x04\x12\x02\x02\
    \x04\x12\x06\xcc\x02\x08\xc9\x02\x18\n\r\n\x05\x04\x12\x02\x02\x05\x12\
    \x04\xcc\x02\x08\x0e\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xcc\x02\x0f\
    \x15\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xcc\x02\x18\x19\nE\n\x04\x04\
    \x12\x02\x03\x12\x04\xcf\x02\x08\"\x1a7\x20How\x20much\x20time\x20realti\
    me\x20scheduling\x20may\x20use\x20(in\x20usecs).\n\n\x0f\n\x05\x04\x12\
    \x02\x03\x04\x12\x06\xcf\x02\x08\xcc\x02\x1a\n\r\n\x05\x04\x12\x02\x03\
    \x05\x12\x04\xcf\x02\x08\r\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xcf\x02\
    \x0e\x1d\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xcf\x02\x20!\nI\n\x04\x04\
    \x12\x02\x04\x12\x04\xd2\x02\x08\"\x1a;\x20CPU\x20period\x20to\x20be\x20\
    used\x20for\x20realtime\x20scheduling\x20(in\x20usecs).\n\n\x0f\n\x05\
    \x04\x12\x02\x04\x04\x12\x06\xd2\x02\x08\xcf\x02\"\n\r\n\x05\x04\x12\x02\
    \x04\x05\x12\x04\xd2\x02\x08\x0e\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\
    \xd2\x02\x0f\x1d\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xd2\x02\x20!\nS\n\
    \x04\x04\x12\x02\x05\x12\x04\xd5\x02\x08\x18\x1aE\x20CPUs\x20to\x20use\
    \x20within\x20the\x20cpuset.\x20Default\x20is\x20to\x20use\x20any\x20CPU\
    \x20available.\n\n\x0f\n\x05\x04\x12\x02\x05\x04\x12\x06\xd5\x02\x08\xd2\
    \x02\"\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xd5\x02\x08\x0e\n\r\n\x05\
    \x04\x12\x02\x05\x01\x12\x04\xd5\x02\x0f\x13\n\r\n\x05\x04\x12\x02\x05\
    \x03\x12\x04\xd5\x02\x16\x17\n`\n\x04\x04\x12\x02\x06\x12\x04\xd8\x02\
    \x08\x18\x1aR\x20List\x20of\x20memory\x20nodes\x20in\x20the\x20cpuset.\
    \x20Default\x20is\x20to\x20use\x20any\x20available\x20memory\x20node.\n\
    \n\x0f\n\x05\x04\x12\x02\x06\x04\x12\x06\xd8\x02\x08\xd5\x02\x18\n\r\n\
    \x05\x04\x12\x02\x06\x05\x12\x04\xd8\x02\x08\x0e\n\r\n\x05\x04\x12\x02\
    \x06\x01\x12\x04\xd8\x02\x0f\x13\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\
    \xd8\x02\x16\x17\n\x0c\n\x02\x04\x13\x12\x06\xdb\x02\0\xe7\x02\x01\n\x0b\
    \n\x03\x04\x13\x01\x12\x04\xdb\x02\x08\x19\n3\n\x04\x04\x13\x02\0\x12\
    \x04\xdd\x02\x08\x18\x1a%\x20Major\x20is\x20the\x20device's\x20major\x20\
    number.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xdd\x02\x08\xdb\x02\x1b\
    \n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xdd\x02\x08\r\n\r\n\x05\x04\x13\x02\
    \0\x01\x12\x04\xdd\x02\x0e\x13\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xdd\
    \x02\x16\x17\n3\n\x04\x04\x13\x02\x01\x12\x04\xe0\x02\x08\x18\x1a%\x20Mi\
    nor\x20is\x20the\x20device's\x20minor\x20number.\n\n\x0f\n\x05\x04\x13\
    \x02\x01\x04\x12\x06\xe0\x02\x08\xdd\x02\x18\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xe0\x02\x08\r\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xe0\x02\
    \x0e\x13\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xe0\x02\x16\x17\n<\n\x04\
    \x04\x13\x02\x02\x12\x04\xe3\x02\x08\x1a\x1a.\x20Weight\x20is\x20the\x20\
    bandwidth\x20rate\x20for\x20the\x20device.\n\n\x0f\n\x05\x04\x13\x02\x02\
    \x04\x12\x06\xe3\x02\x08\xe0\x02\x18\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\xe3\x02\x08\x0e\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xe3\x02\x0f\
    \x15\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xe3\x02\x18\x19\n\x83\x01\n\
    \x04\x04\x13\x02\x03\x12\x04\xe6\x02\x08\x1e\x1au\x20LeafWeight\x20is\
    \x20the\x20bandwidth\x20rate\x20for\x20the\x20device\x20while\x20competi\
    ng\x20with\x20the\x20cgroup's\x20child\x20cgroups,\x20CFQ\x20scheduler\
    \x20only\n\n\x0f\n\x05\x04\x13\x02\x03\x04\x12\x06\xe6\x02\x08\xe3\x02\
    \x1a\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xe6\x02\x08\x0e\n\r\n\x05\x04\
    \x13\x02\x03\x01\x12\x04\xe6\x02\x0f\x19\n\r\n\x05\x04\x13\x02\x03\x03\
    \x12\x04\xe6\x02\x1c\x1d\n\x0c\n\x02\x04\x14\x12\x06\xe9\x02\0\xf2\x02\
    \x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xe9\x02\x08\x1b\n3\n\x04\x04\x14\
    \x02\0\x12\x04\xeb\x02\x08\x18\x1a%\x20Major\x20is\x20the\x20device's\
    \x20major\x20number.\n\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xeb\x02\x08\
    \xe9\x02\x1d\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xeb\x02\x08\r\n\r\n\x05\
    \x04\x14\x02\0\x01\x12\x04\xeb\x02\x0e\x13\n\r\n\x05\x04\x14\x02\0\x03\
    \x12\x04\xeb\x02\x16\x17\n3\n\x04\x04\x14\x02\x01\x12\x04\xee\x02\x08\
    \x18\x1a%\x20Minor\x20is\x20the\x20device's\x20minor\x20number.\n\n\x0f\
    \n\x05\x04\x14\x02\x01\x04\x12\x06\xee\x02\x08\xeb\x02\x18\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\xee\x02\x08\r\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xee\x02\x0e\x13\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xee\x02\x16\
    \x17\n?\n\x04\x04\x14\x02\x02\x12\x04\xf1\x02\x08\x18\x1a1\x20Rate\x20is\
    \x20the\x20IO\x20rate\x20limit\x20per\x20cgroup\x20per\x20device\n\n\x0f\
    \n\x05\x04\x14\x02\x02\x04\x12\x06\xf1\x02\x08\xee\x02\x18\n\r\n\x05\x04\
    \x14\x02\x02\x05\x12\x04\xf1\x02\x08\x0e\n\r\n\x05\x04\x14\x02\x02\x01\
    \x12\x04\xf1\x02\x0f\x13\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf1\x02\
    \x16\x17\n\x0c\n\x02\x04\x15\x12\x06\xf4\x02\0\x89\x03\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\xf4\x02\x08\x14\n+\n\x04\x04\x15\x02\0\x12\x04\xf6\
    \x02\x08\x1a\x1a\x1d\x20Specifies\x20per\x20cgroup\x20weight\n\n\x0f\n\
    \x05\x04\x15\x02\0\x04\x12\x06\xf6\x02\x08\xf4\x02\x16\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\xf6\x02\x08\x0e\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xf6\x02\x0f\x15\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf6\x02\x18\x19\n\
    \x7f\n\x04\x04\x15\x02\x01\x12\x04\xf9\x02\x08\x1e\x1aq\x20Specifies\x20\
    tasks'\x20weight\x20in\x20the\x20given\x20cgroup\x20while\x20competing\
    \x20with\x20the\x20cgroup's\x20child\x20cgroups,\x20CFQ\x20scheduler\x20\
    only\n\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xf9\x02\x08\xf6\x02\x1a\n\
    \r\n\x05\x04\x15\x02\x01\x05\x12\x04\xf9\x02\x08\x0e\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\xf9\x02\x0f\x19\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\xf9\x02\x1c\x1d\nF\n\x04\x04\x15\x02\x02\x12\x04\xfc\x02\x08T\x1a8\
    \x20Weight\x20per\x20cgroup\x20per\x20device,\x20can\x20override\x20Blki\
    oWeight\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xfc\x02\x08\x10\n\r\n\
    \x05\x04\x15\x02\x02\x06\x12\x04\xfc\x02\x11\"\n\r\n\x05\x04\x15\x02\x02\
    \x01\x12\x04\xfc\x02#/\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xfc\x0223\n\
    \r\n\x05\x04\x15\x02\x02\x08\x12\x04\xfc\x025S\n\x10\n\x08\x04\x15\x02\
    \x02\x08\xe9\xfb\x03\x12\x04\xfc\x026R\nJ\n\x04\x04\x15\x02\x03\x12\x04\
    \xff\x02\x08_\x1a<\x20IO\x20read\x20rate\x20limit\x20per\x20cgroup\x20pe\
    r\x20device,\x20bytes\x20per\x20second\n\n\r\n\x05\x04\x15\x02\x03\x04\
    \x12\x04\xff\x02\x08\x10\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\xff\x02\
    \x11$\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xff\x02%:\n\r\n\x05\x04\x15\
    \x02\x03\x03\x12\x04\xff\x02=>\n\r\n\x05\x04\x15\x02\x03\x08\x12\x04\xff\
    \x02@^\n\x10\n\x08\x04\x15\x02\x03\x08\xe9\xfb\x03\x12\x04\xff\x02A]\nK\
    \n\x04\x04\x15\x02\x04\x12\x04\x82\x03\x08`\x1a=\x20IO\x20write\x20rate\
    \x20limit\x20per\x20cgroup\x20per\x20device,\x20bytes\x20per\x20second\n\
    \n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\x82\x03\x08\x10\n\r\n\x05\x04\x15\
    \x02\x04\x06\x12\x04\x82\x03\x11$\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\
    \x82\x03%;\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\x82\x03>?\n\r\n\x05\x04\
    \x15\x02\x04\x08\x12\x04\x82\x03A_\n\x10\n\x08\x04\x15\x02\x04\x08\xe9\
    \xfb\x03\x12\x04\x82\x03B^\nG\n\x04\x04\x15\x02\x05\x12\x04\x85\x03\x08`\
    \x1a9\x20IO\x20read\x20rate\x20limit\x20per\x20cgroup\x20per\x20device,\
    \x20IO\x20per\x20second\n\n\r\n\x05\x04\x15\x02\x05\x04\x12\x04\x85\x03\
    \x08\x10\n\r\n\x05\x04\x15\x02\x05\x06\x12\x04\x85\x03\x11$\n\r\n\x05\
    \x04\x15\x02\x05\x01\x12\x04\x85\x03%;\n\r\n\x05\x04\x15\x02\x05\x03\x12\
    \x04\x85\x03>?\n\r\n\x05\x04\x15\x02\x05\x08\x12\x04\x85\x03A_\n\x10\n\
    \x08\x04\x15\x02\x05\x08\xe9\xfb\x03\x12\x04\x85\x03B^\nH\n\x04\x04\x15\
    \x02\x06\x12\x04\x88\x03\x08a\x1a:\x20IO\x20write\x20rate\x20limit\x20pe\
    r\x20cgroup\x20per\x20device,\x20IO\x20per\x20second\n\n\r\n\x05\x04\x15\
    \x02\x06\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x15\x02\x06\x06\x12\
    \x04\x88\x03\x11$\n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\x88\x03%<\n\r\n\
    \x05\x04\x15\x02\x06\x03\x12\x04\x88\x03?@\n\r\n\x05\x04\x15\x02\x06\x08\
    \x12\x04\x88\x03B`\n\x10\n\x08\x04\x15\x02\x06\x08\xe9\xfb\x03\x12\x04\
    \x88\x03C_\n\x0c\n\x02\x04\x16\x12\x06\x8b\x03\0\x8e\x03\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\x8b\x03\x08\x11\n>\n\x04\x04\x16\x02\0\x12\x04\x8d\
    \x03\x08\x18\x1a0\x20Maximum\x20number\x20of\x20PIDs.\x20Default\x20is\
    \x20\"no\x20limit\".\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\x8d\x03\x08\
    \x8b\x03\x13\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x8d\x03\x08\r\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\x8d\x03\x0e\x13\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\x8d\x03\x16\x17\n\x0c\n\x02\x04\x17\x12\x06\x90\x03\0\x9f\x03\
    \x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x90\x03\x08\x19\n\x1d\n\x04\x04\x17\
    \x02\0\x12\x04\x92\x03\x08\x17\x1a\x0f\x20Allow\x20or\x20deny\n\n\x0f\n\
    \x05\x04\x17\x02\0\x04\x12\x06\x92\x03\x08\x90\x03\x1b\n\r\n\x05\x04\x17\
    \x02\0\x05\x12\x04\x92\x03\x08\x0c\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\
    \x92\x03\r\x12\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x92\x03\x15\x16\n.\n\
    \x04\x04\x17\x02\x01\x12\x04\x95\x03\x08\x18\x1a\x20\x20Device\x20type,\
    \x20block,\x20char,\x20etc.\n\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\
    \x95\x03\x08\x92\x03\x17\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\x95\x03\
    \x08\x0e\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x95\x03\x0f\x13\n\r\n\x05\
    \x04\x17\x02\x01\x03\x12\x04\x95\x03\x16\x17\n3\n\x04\x04\x17\x02\x02\
    \x12\x04\x98\x03\x08\x18\x1a%\x20Major\x20is\x20the\x20device's\x20major\
    \x20number.\n\n\x0f\n\x05\x04\x17\x02\x02\x04\x12\x06\x98\x03\x08\x95\
    \x03\x18\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\x98\x03\x08\r\n\r\n\x05\
    \x04\x17\x02\x02\x01\x12\x04\x98\x03\x0e\x13\n\r\n\x05\x04\x17\x02\x02\
    \x03\x12\x04\x98\x03\x16\x17\n3\n\x04\x04\x17\x02\x03\x12\x04\x9b\x03\
    \x08\x18\x1a%\x20Minor\x20is\x20the\x20device's\x20minor\x20number.\n\n\
    \x0f\n\x05\x04\x17\x02\x03\x04\x12\x06\x9b\x03\x08\x98\x03\x18\n\r\n\x05\
    \x04\x17\x02\x03\x05\x12\x04\x9b\x03\x08\r\n\r\n\x05\x04\x17\x02\x03\x01\
    \x12\x04\x9b\x03\x0e\x13\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x9b\x03\
    \x16\x17\n6\n\x04\x04\x17\x02\x04\x12\x04\x9e\x03\x08\x1a\x1a(\x20Cgroup\
    \x20access\x20permissions\x20format,\x20rwm.\n\n\x0f\n\x05\x04\x17\x02\
    \x04\x04\x12\x06\x9e\x03\x08\x9b\x03\x18\n\r\n\x05\x04\x17\x02\x04\x05\
    \x12\x04\x9e\x03\x08\x0e\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\x9e\x03\
    \x0f\x15\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x9e\x03\x18\x19\n\x0c\n\
    \x02\x04\x18\x12\x06\xa1\x03\0\xa7\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xa1\x03\x08\x14\nD\n\x04\x04\x18\x02\0\x12\x04\xa3\x03\x08\x1b\x1a6\
    \x20Set\x20class\x20identifier\x20for\x20container's\x20network\x20packe\
    ts\n\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xa3\x03\x08\xa1\x03\x16\n\r\n\
    \x05\x04\x18\x02\0\x05\x12\x04\xa3\x03\x08\x0e\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xa3\x03\x0f\x16\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xa3\x03\
    \x19\x1a\n=\n\x04\x04\x18\x02\x01\x12\x04\xa6\x03\x08W\x1a/\x20Set\x20pr\
    iority\x20of\x20network\x20traffic\x20for\x20container\n\n\r\n\x05\x04\
    \x18\x02\x01\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04\x18\x02\x01\x06\
    \x12\x04\xa6\x03\x11'\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xa6\x03(2\n\
    \r\n\x05\x04\x18\x02\x01\x03\x12\x04\xa6\x0356\n\r\n\x05\x04\x18\x02\x01\
    \x08\x12\x04\xa6\x038V\n\x10\n\x08\x04\x18\x02\x01\x08\xe9\xfb\x03\x12\
    \x04\xa6\x039U\n\x0c\n\x02\x04\x19\x12\x06\xa9\x03\0\xaf\x03\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xa9\x03\x08\x1a\n-\n\x04\x04\x19\x02\0\x12\x04\
    \xab\x03\x08\x1c\x1a\x1f\x20Pagesize\x20is\x20the\x20hugepage\x20size\n\
    \n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xab\x03\x08\xa9\x03\x1c\n\r\n\x05\
    \x04\x19\x02\0\x05\x12\x04\xab\x03\x08\x0e\n\r\n\x05\x04\x19\x02\0\x01\
    \x12\x04\xab\x03\x0f\x17\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xab\x03\x1a\
    \x1b\nB\n\x04\x04\x19\x02\x01\x12\x04\xae\x03\x08\x19\x1a4\x20Limit\x20i\
    s\x20the\x20limit\x20of\x20\"hugepagesize\"\x20hugetlb\x20usage\n\n\x0f\
    \n\x05\x04\x19\x02\x01\x04\x12\x06\xae\x03\x08\xab\x03\x1c\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\xae\x03\x08\x0e\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xae\x03\x0f\x14\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xae\x03\
    \x17\x18\n\x0c\n\x02\x04\x1a\x12\x06\xb1\x03\0\xb7\x03\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xb1\x03\x08\x1e\n9\n\x04\x04\x1a\x02\0\x12\x04\xb3\
    \x03\x08\x18\x1a+\x20Name\x20is\x20the\x20name\x20of\x20the\x20network\
    \x20interface\n\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\xb3\x03\x08\xb1\
    \x03\x20\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xb3\x03\x08\x0e\n\r\n\x05\
    \x04\x1a\x02\0\x01\x12\x04\xb3\x03\x0f\x13\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\xb3\x03\x16\x17\n*\n\x04\x04\x1a\x02\x01\x12\x04\xb6\x03\x08\
    \x1c\x1a\x1c\x20Priority\x20for\x20the\x20interface\n\n\x0f\n\x05\x04\
    \x1a\x02\x01\x04\x12\x06\xb6\x03\x08\xb3\x03\x18\n\r\n\x05\x04\x1a\x02\
    \x01\x05\x12\x04\xb6\x03\x08\x0e\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\
    \xb6\x03\x0f\x17\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xb6\x03\x1a\x1b\n\
    \x0c\n\x02\x04\x1b\x12\x06\xb9\x03\0\xbd\x03\x01\n\x0b\n\x03\x04\x1b\x01\
    \x12\x04\xb9\x03\x08\x14\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xba\x03\x08!\
    \n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xba\x03\x08\xb9\x03\x16\n\r\n\x05\
    \x04\x1b\x02\0\x05\x12\x04\xba\x03\x08\x0e\n\r\n\x05\x04\x1b\x02\0\x01\
    \x12\x04\xba\x03\x0f\x1c\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xba\x03\x1f\
    \x20\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xbb\x03\x08*\n\r\n\x05\x04\x1b\
    \x02\x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\
    \x04\xbb\x03\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xbb\x03\x18%\
    \n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xbb\x03()\n\x0c\n\x04\x04\x1b\x02\
    \x02\x12\x04\xbc\x03\x08K\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\xbc\x03\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\xbc\x03\x11\x1d\n\r\n\x05\
    \x04\x1b\x02\x02\x01\x12\x04\xbc\x03\x1e&\n\r\n\x05\x04\x1b\x02\x02\x03\
    \x12\x04\xbc\x03)*\n\r\n\x05\x04\x1b\x02\x02\x08\x12\x04\xbc\x03,J\n\x10\
    \n\x08\x04\x1b\x02\x02\x08\xe9\xfb\x03\x12\x04\xbc\x03-I\n\x0c\n\x02\x04\
    \x1c\x12\x06\xbf\x03\0\xc4\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xbf\
    \x03\x08\x17\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xc0\x03\x08\x19\n\x0f\n\
    \x05\x04\x1c\x02\0\x04\x12\x06\xc0\x03\x08\xbf\x03\x19\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\xc0\x03\x08\x0e\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xc0\x03\x0f\x14\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xc0\x03\x17\x18\n\
    \x0c\n\x04\x04\x1c\x02\x01\x12\x04\xc1\x03\x08\x19\n\x0f\n\x05\x04\x1c\
    \x02\x01\x04\x12\x06\xc1\x03\x08\xc0\x03\x19\n\r\n\x05\x04\x1c\x02\x01\
    \x05\x12\x04\xc1\x03\x08\x0e\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xc1\
    \x03\x0f\x14\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xc1\x03\x17\x18\n\x0c\
    \n\x04\x04\x1c\x02\x02\x12\x04\xc2\x03\x08\x1c\n\x0f\n\x05\x04\x1c\x02\
    \x02\x04\x12\x06\xc2\x03\x08\xc1\x03\x19\n\r\n\x05\x04\x1c\x02\x02\x05\
    \x12\x04\xc2\x03\x08\x0e\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xc2\x03\
    \x0f\x17\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xc2\x03\x1a\x1b\n\x0c\n\
    \x04\x04\x1c\x02\x03\x12\x04\xc3\x03\x08\x16\n\x0f\n\x05\x04\x1c\x02\x03\
    \x04\x12\x06\xc3\x03\x08\xc2\x03\x1c\n\r\n\x05\x04\x1c\x02\x03\x05\x12\
    \x04\xc3\x03\x08\x0e\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xc3\x03\x0f\
    \x11\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xc3\x03\x14\x15\n\x0c\n\x02\
    \x04\x1d\x12\x06\xc6\x03\0\xca\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xc6\x03\x08\x14\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xc7\x03\x08\"\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xc7\x03\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xc7\x03\
    \x18\x1d\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xc7\x03\x20!\n\x0c\n\x04\
    \x04\x1d\x02\x01\x12\x04\xc8\x03\x08\x1a\n\x0f\n\x05\x04\x1d\x02\x01\x04\
    \x12\x06\xc8\x03\x08\xc7\x03\"\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xc8\
    \x03\x08\x0e\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xc8\x03\x0f\x15\n\r\n\
    \x05\x04\x1d\x02\x01\x03\x12\x04\xc8\x03\x18\x19\n\x0c\n\x04\x04\x1d\x02\
    \x02\x12\x04\xc9\x03\x08J\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xc9\x03\
    \x08\x10\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\xc9\x03\x11\x20\n\r\n\x05\
    \x04\x1d\x02\x02\x01\x12\x04\xc9\x03!%\n\r\n\x05\x04\x1d\x02\x02\x03\x12\
    \x04\xc9\x03()\n\r\n\x05\x04\x1d\x02\x02\x08\x12\x04\xc9\x03+I\n\x10\n\
    \x08\x04\x1d\x02\x02\x08\xe9\xfb\x03\x12\x04\xc9\x03,H\n\x0c\n\x02\x04\
    \x1e\x12\x06\xcc\x03\0\xd0\x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xcc\
    \x03\x08\x15\n}\n\x04\x04\x1e\x02\0\x12\x04\xcf\x03\x08!\x1ao\x20The\x20\
    schema\x20for\x20L3\x20cache\x20id\x20and\x20capacity\x20bitmask\x20(CBM\
    )\n\x20Format:\x20\"L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;...\"\n\n\
    \x0f\n\x05\x04\x1e\x02\0\x04\x12\x06\xcf\x03\x08\xcc\x03\x17\n\r\n\x05\
    \x04\x1e\x02\0\x05\x12\x04\xcf\x03\x08\x0e\n\r\n\x05\x04\x1e\x02\0\x01\
    \x12\x04\xcf\x03\x0f\x1c\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xcf\x03\x1f\
    \x20b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
