// Copyright (c) 2023 Red Hat
//
// SPDX-License-Identifier: Apache-2.0
//

use crate::utils::{clear_cloexec, create_vhost_net_fds, open_named_tuntap};
use crate::{kernel_param::KernelParams, Address, HypervisorConfig};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use kata_types::config::hypervisor::VIRTIO_SCSI;
use std::collections::HashMap;
use std::fmt::Display;
use std::fs::{read_to_string, File};
use std::os::fd::{AsRawFd, FromRawFd, IntoRawFd};
use std::os::unix::net::UnixListener;
use std::path::PathBuf;
use tokio;

// These should have been called MiB and GiB for better readability but the
// more fitting names unfortunately generate linter warnings.
const MI_B: u64 = 1024 * 1024;
const GI_B: u64 = 1024 * MI_B;

pub const QMP_SOCKET_FILE: &str = "qmp.sock";
const DEBUG_MONITOR_SOCKET: &str = "debug-monitor.sock";

// The approach taken here is inspired by govmm.  We build structs, each
// corresponding to a qemu command line parameter, like Kernel, or a device,
// for instance MemoryBackendFile.  Members of these structs mostly directly
// correspond to appropriate arguments of qemu parameters and are named
// the same except for '-' which are replaced with '_' in struct member names.
// The structs use a simple Builder pattern when necessary where mandatory
// arguments are passed to a constructor and setters are provided for the rest.
// All structs implement a simple ToQemuParams interface which allows their
// user to convert them to actual qemu command line parameter strings.

// There's nothing inherently async about this interface.  Unfortunately it
// has to be async anyway just due to the fact that QemuCmdLine holds a
// container of these, *and* due to the way QemuCmdLine is used -
// QemuInner::start_vm() happens to call an async function while a QemuCmdLine
// instance is on stack which makes it necessary for QemuCmdLine to be
// Send + Sync, and for that ToQemuParams has to be Send + Sync. :-(
#[async_trait]
trait ToQemuParams: Send + Sync {
    // OsString could look as a better fit here, however since foreign strings
    // come to this code from the outside as Strings already and this code adds
    // nothing but UTF-8 (in fact probably just ASCII) switching to OsStrings
    // now seems pointless.
    async fn qemu_params(&self) -> Result<Vec<String>>;
}

#[derive(Debug, PartialEq, Clone, Copy)]
enum VirtioBusType {
    Pci,
    Ccw,
}

impl VirtioBusType {
    fn as_str(&self) -> &str {
        match self {
            VirtioBusType::Pci => "pci",
            VirtioBusType::Ccw => "ccw",
        }
    }
}

impl Display for VirtioBusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

fn bus_type(config: &HypervisorConfig) -> VirtioBusType {
    if config.machine_info.machine_type.contains("-ccw-") {
        VirtioBusType::Ccw
    } else {
        VirtioBusType::Pci
    }
}

// Conventions used in qemu command line generation
// ================================================
//
// While acknowledging govmm inspiration, this implementation differs in
// several important aspects.
//
// 1:1 correspondence between qemu switches and cmdline generator structs
// ----------------------------------------------------------------------
//
// There should mostly be a 1:1 mapping between qemu command line switches and
// objects (structs) that represent them.  That is, each struct's
// ToQemuParams::qemu_params() is expected to generate a single
// `-whatever <params...>`.  Notably, a lot of devices are assembled from a
// frontend (`-device`) and a backend (`-object`), each of which should be
// represented and generated by a separate object (struct).  If setting up
// a qemu construct (device or other) requires assembly from multiple such
// parts, this is expected to be done in a `QemuCmdLine::add_*()` function.
//
// As an example, a network device might consist of `-netdev tap` and
// `-device virtio-net-pci`.  The former is represented by struct Netdev,
// the latter by struct DeviceVirtioNet, both of which are instantiated &
// set up in QemuCmdLine::add_network_device().
//
// There is a couple of exceptions to this convention.  struct Kernel might
// be required to generate multiple qemu cmdline switches to perform full
// kernel set-up, struct Knobs (directly lifted from govmm) does that too
// due to its purpose of being a catch-all grabbag.  Both are singletons
// dictated mostly by nature of qemu's cmdline syntax.  Going forward, most
// if not all future additions to qemu cmdline generation are expected to
// follow this convention.
//
// This convention is a departure from govmm style which tends to lump all
// information necessary to set up a piece of VM equipment into a single
// object.  This might make sense at the first sight, after all a network
// device needs both its frontend and backend so why not represent it with
// a single struct.  However, as can be observed in govmm, the resulting
// structs tend to be big and hard to read since the frontend and backend
// params are distinct so the big struct is actually two separate structs
// really.  If a need ever arises to have explicit representation of a whole
// device it would still seem preferable to assemble it from the explicit
// individual representations of frontend and backend.
//
// Naming conventions
// ------------------
//
// The idea is to name entities in this qemu cmdline generator as close
// as possible to the qemu cmdline switches and params that they represent.
// This is to reduce the intellectual overhead of having to map between names
// on qemu command line and in this source code.
//
// Most of the cmdline switch generating structs in this file are expected
// to generate a single qemu cmdline switch as detailed above.  It follows
// that most member fields of these objects will represent additional params
// of the qemu switches and their names should ideally be as close to the
// corresponding qemu switch params as possible, within reason and Rust
// syntax limitations (e.g. dashes in qemu param names obviously need to be
// converted to underscores for code to even compile).  As an example,
// struct MemoryBackendFile members' names are identical to qemu's
// `-object memory-backend-file,...` params, with the exception of `mem-path`
// which is called `mem_path` to comply with Rust syntax.
//
// The struct names should follow the same logic, their names should ideally
// be as close as possible to the qemu switch they represent (e.g. `-smp` is
// generated by struct Smp), or to common parlance if that's not descriptive
// enough.  This applies above all to devices which are commonly set up by
// `-device` & `-object`.  In those cases, e.g. `-chardev socket` might be
// referred to as "chardev socket" in common speech so the corresponding struct
// is called ChardevSocket, or `-device vhost-user-fs-pci` will likely be
// pronounced as "device vhost user fs" so its struct is called
// DeviceVhostUserFs, too.  Admittedly, this approach can be rather squishy and
// a matter of taste ultimately, but it should still be useful to keep in mind
// that the idea is to keep the names in this source code as close as possible
// to what folks working with qemu in kata are likely to use and be familiar
// with already.

#[derive(Debug)]
struct Kernel {
    // PathBuf would seem more appropriae but since we get the kernel path
    // from config as String already and we do no path operations on it,
    // converting to PathBuf and then back to String seems futile
    path: String,
    initrd_path: String,
    params: KernelParams,
}

impl Kernel {
    fn new(config: &HypervisorConfig) -> Result<Kernel> {
        // get kernel params
        let mut kernel_params = KernelParams::new(config.debug_info.enable_debug);

        if config.boot_info.initrd.is_empty() {
            // QemuConfig::validate() has already made sure that if initrd is
            // empty, image cannot be so we don't need to re-check that here

            kernel_params.append(
                &mut KernelParams::new_rootfs_kernel_params(
                    &config.boot_info.vm_rootfs_driver,
                    &config.boot_info.rootfs_type,
                )
                .context("adding rootfs params failed")?,
            );
        }

        kernel_params.append(&mut KernelParams::from_string(
            &config.boot_info.kernel_params,
        ));
        kernel_params.append(&mut KernelParams::from_string(&format!(
            "selinux={}",
            if config.disable_guest_selinux { 0 } else { 1 }
        )));

        Ok(Kernel {
            path: config.boot_info.kernel.clone(),
            initrd_path: config.boot_info.initrd.clone(),
            params: kernel_params,
        })
    }
}

#[async_trait]
impl ToQemuParams for Kernel {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut result = Vec::new();

        // QemuConfig::adjust_config() ensures that kernel path is never empty
        result.push("-kernel".to_owned());
        result.push(self.path.clone());

        if !self.initrd_path.is_empty() {
            result.push("-initrd".to_owned());
            result.push(self.initrd_path.clone());
        }

        let kernel_params = self.params.to_string()?;
        if !kernel_params.is_empty() {
            result.push("-append".to_owned());
            result.push(kernel_params);
        }

        Ok(result)
    }
}

fn format_memory(mem_size: u64) -> String {
    if mem_size % GI_B == 0 {
        format!("{}G", mem_size / GI_B)
    } else if mem_size % MI_B == 0 {
        format!("{}M", mem_size / MI_B)
    } else {
        format!("{}", mem_size)
    }
}

#[derive(Debug)]
struct Memory {
    // 'size' and 'max_size' are stored in bytes
    size: u64,
    num_slots: u32,
    max_size: u64,
    memory_backend_file: Option<MemoryBackendFile>,
}

impl Memory {
    fn new(config: &HypervisorConfig) -> Memory {
        // Move this to QemuConfig::adjust_config()?

        let mut mem_size = config.memory_info.default_memory as u64;
        let mut max_mem_size = config.memory_info.default_maxmemory as u64;

        if let Ok(sysinfo) = nix::sys::sysinfo::sysinfo() {
            let host_memory = sysinfo.ram_total() >> 20;

            if mem_size > host_memory {
                info!(sl!(), "'default_memory' given in configuration.toml is greater than host memory, adjusting to host memory");
                mem_size = host_memory
            }

            if max_mem_size == 0 || max_mem_size > host_memory {
                max_mem_size = host_memory
            }
        } else {
            warn!(sl!(), "Failed to get host memory size, cannot verify or adjust configuration.toml's 'default_maxmemory'");

            if max_mem_size == 0 {
                max_mem_size = mem_size;
            };
        }

        // Memory sizes are given in megabytes in configuration.toml so we
        // need to convert them to bytes for storage.
        Memory {
            size: mem_size * MI_B,
            num_slots: config.memory_info.memory_slots,
            max_size: max_mem_size * MI_B,
            memory_backend_file: None,
        }
    }

    fn set_memory_backend_file(&mut self, mem_file: &MemoryBackendFile) -> &mut Self {
        if let Some(existing) = &self.memory_backend_file {
            if *existing != *mem_file {
                warn!(sl!(), "Memory: memory backend file already exists ({:?}) while trying to set a different one ({:?}), ignoring", existing, mem_file);
                return self;
            }
        }
        self.memory_backend_file = Some(mem_file.clone());
        self
    }
}

#[async_trait]
impl ToQemuParams for Memory {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();

        if self.size.trailing_zeros() < 19 {
            return Err(anyhow!(
                "bad memory size (must be given in whole megabytes): {}",
                self.size
            ));
        }
        params.push(format_memory(self.size));

        if self.num_slots != 0 {
            params.push(format!("slots={}", self.num_slots));
        }
        if self.max_size != 0 {
            params.push(format!("maxmem={}", format_memory(self.max_size)));
        }

        let mut retval = vec!["-m".to_owned(), params.join(",")];

        if let Some(mem_file) = &self.memory_backend_file {
            retval.append(&mut mem_file.qemu_params().await?);
        }
        Ok(retval)
    }
}

#[derive(Debug)]
struct Smp {
    num_vcpus: u32,
    max_num_vcpus: u32,
}

impl Smp {
    fn new(config: &HypervisorConfig) -> Smp {
        Smp {
            num_vcpus: config.cpu_info.default_vcpus as u32,
            max_num_vcpus: config.cpu_info.default_maxvcpus,
        }
    }
}

#[async_trait]
impl ToQemuParams for Smp {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        // CpuInfo::adjust_config() seems to ensure that both vcpu numbers
        // will have sanitised non-zero values
        params.push(format!("{}", self.num_vcpus));
        params.push(format!("maxcpus={}", self.max_num_vcpus));

        Ok(vec!["-smp".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct Cpu {
    cpu_features: String,
}

impl Cpu {
    fn new(config: &HypervisorConfig) -> Cpu {
        Cpu {
            cpu_features: config.cpu_info.cpu_features.clone(),
        }
    }
}

#[async_trait]
impl ToQemuParams for Cpu {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        // '-cpu host' has always to be used when using KVM
        let mut params = vec!["host".to_owned()];
        params.push(self.cpu_features.clone());
        Ok(vec!["-cpu".to_owned(), params.join(",")])
    }
}

/// Error type for CCW Subchannel operations
#[derive(Debug)]
#[allow(dead_code)]
enum CcwError {
    DeviceAlreadyExists(String), // Error when trying to add an existing device
    #[allow(dead_code)]
    DeviceNotFound(String), // Error when trying to remove a nonexistent device
}

/// Represents a CCW subchannel for managing devices
#[derive(Debug)]
struct CcwSubChannel {
    devices: HashMap<String, u32>, // Maps device IDs to slot indices
    addr: u32,                     // Subchannel address
    next_slot: u32,                // Next available slot index
}

impl CcwSubChannel {
    fn new() -> Self {
        Self {
            devices: HashMap::new(),
            addr: 0,
            next_slot: 0,
        }
    }

    /// Adds a device to the subchannel.
    ///
    /// # Arguments
    /// - `dev_id`: device ID to add
    ///
    /// # Returns
    /// - `Result<u32, CcwError>`: slot index of the added device
    ///   or an error if the device already exists
    fn add_device(&mut self, dev_id: &str) -> Result<u32, CcwError> {
        if self.devices.contains_key(dev_id) {
            Err(CcwError::DeviceAlreadyExists(dev_id.to_owned()))
        } else {
            let slot = self.next_slot;
            self.devices.insert(dev_id.to_owned(), slot);
            self.next_slot += 1;
            Ok(slot)
        }
    }

    /// Removes a device from the subchannel by its ID.
    ///
    /// # Arguments
    /// - `dev_id`: device ID to remove
    ///
    /// # Returns
    /// - `Result<(), CcwError>`: Ok(()) if the device was removed
    ///   or an error if the device was not found
    #[allow(dead_code)]
    fn remove_device(&mut self, dev_id: &str) -> Result<(), CcwError> {
        if self.devices.remove(dev_id).is_some() {
            Ok(())
        } else {
            Err(CcwError::DeviceNotFound(dev_id.to_owned()))
        }
    }

    /// Formats the CCW address for a given slot
    ///
    /// # Arguments
    /// - `slot`: slot index
    ///
    /// # Returns
    /// - `String`: formatted CCW address (e.g. `fe.0.0000`)
    fn address_format_ccw(&self, slot: u32) -> String {
        format!("fe.{:x}.{:04x}", self.addr, slot)
    }

    /// Sets the address of the subchannel.
    /// # Arguments
    /// - `addr`: subchannel address to set
    #[allow(dead_code)]
    fn set_addr(&mut self, addr: u32) -> &mut Self {
        self.addr = addr;
        self
    }
}

#[derive(Debug)]
struct Machine {
    r#type: String,
    accel: String,
    options: String,
    nvdimm: bool,
    kernel_irqchip: Option<String>,

    is_nvdimm_supported: bool,
    memory_backend: Option<String>,
}

impl Machine {
    fn new(config: &HypervisorConfig) -> Machine {
        #[cfg(any(
            target_arch = "aarch64",
            all(target_arch = "powerpc64", target_endian = "little"),
            target_arch = "x86",
            target_arch = "x86_64",
        ))]
        let is_nvdimm_supported = config.machine_info.machine_type != "microvm";
        #[cfg(not(any(
            target_arch = "aarch64",
            all(target_arch = "powerpc64", target_endian = "little"),
            target_arch = "x86",
            target_arch = "x86_64",
        )))]
        let is_nvdimm_supported = false;

        Machine {
            r#type: config.machine_info.machine_type.clone(),
            accel: "kvm".to_owned(),
            options: config.machine_info.machine_accelerators.clone(),
            nvdimm: false,
            kernel_irqchip: None,
            is_nvdimm_supported,
            memory_backend: None,
        }
    }

    fn set_nvdimm(&mut self, is_on: bool) -> &mut Self {
        if is_on && !self.is_nvdimm_supported {
            warn!(sl!(), "called to enable nvdimm but nvdimm is not supported");
        }
        self.nvdimm = is_on && self.is_nvdimm_supported;
        self
    }

    fn set_memory_backend(&mut self, mem_backend: &str) -> &mut Self {
        self.memory_backend = Some(mem_backend.to_owned());
        self
    }

    fn set_kernel_irqchip(&mut self, kernel_irqchip: &str) -> &mut Self {
        self.kernel_irqchip = Some(kernel_irqchip.to_owned());
        self
    }
}

#[async_trait]
impl ToQemuParams for Machine {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(self.r#type.clone());
        params.push(format!("accel={}", self.accel));
        if !self.options.is_empty() {
            params.push(self.options.clone());
        }
        if self.nvdimm {
            params.push("nvdimm=on".to_owned());
        }
        if let Some(kernel_irqchip) = &self.kernel_irqchip {
            params.push(format!("kernel_irqchip={}", kernel_irqchip));
        }
        if let Some(mem_backend) = &self.memory_backend {
            params.push(format!("memory-backend={}", mem_backend));
        }
        Ok(vec!["-machine".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct Knobs {
    no_user_config: bool,
    nodefaults: bool,
    nographic: bool,
    no_reboot: bool,
    vga: String,
}

impl Knobs {
    fn new(_config: &HypervisorConfig) -> Knobs {
        Knobs {
            no_user_config: true,
            nodefaults: true,
            nographic: true,
            no_reboot: true,
            vga: "none".to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for Knobs {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut result = Vec::new();
        result.push("-vga".to_owned());
        result.push(self.vga.clone());
        if self.no_user_config {
            result.push("-no-user-config".to_owned());
        }
        if self.nodefaults {
            result.push("-nodefaults".to_owned());
        }
        if self.nographic {
            result.push("-nographic".to_owned());
        }
        if self.no_reboot {
            result.push("-no-reboot".to_owned());
        }
        Ok(result)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct MemoryBackendFile {
    id: String,
    mem_path: String,
    size: u64,
    share: bool,
    readonly: bool,
}

impl MemoryBackendFile {
    fn new(id: &str, mem_path: &str, size: u64) -> MemoryBackendFile {
        MemoryBackendFile {
            id: id.to_string(),
            mem_path: mem_path.to_string(),
            size,
            share: false,
            readonly: false,
        }
    }

    fn set_share(&mut self, share: bool) -> &mut Self {
        self.share = share;
        self
    }

    fn set_readonly(&mut self, readonly: bool) -> &mut Self {
        self.readonly = readonly;
        self
    }
}

#[async_trait]
impl ToQemuParams for MemoryBackendFile {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("memory-backend-file".to_owned());
        params.push(format!("id={}", self.id));
        params.push(format!("mem-path={}", self.mem_path));
        params.push(format!("size={}", format_memory(self.size)));
        params.push(format!("share={}", if self.share { "on" } else { "off" }));
        params.push(format!(
            "readonly={}",
            if self.readonly { "on" } else { "off" }
        ));

        Ok(vec!["-object".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct TcpSocketOpts {
    host: String,
    // 'port' is required for a TCP socket
    port: String,
}

#[async_trait]
impl ToQemuParams for TcpSocketOpts {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        if !self.host.is_empty() {
            params.push(format!("host={}", self.host));
        }
        params.push(format!("port={}", self.port));
        Ok(params)
    }
}

#[derive(Debug)]
struct UnixSocketOpts {
    // 'path' is a required parameter for a unix socket
    path: String,
}

#[async_trait]
impl ToQemuParams for UnixSocketOpts {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("path={}", self.path));
        Ok(params)
    }
}

#[derive(Debug)]
enum ProtocolOptions {
    None,
    #[allow(dead_code)]
    Tcp(TcpSocketOpts),
    Unix(UnixSocketOpts),
}

#[async_trait]
impl ToQemuParams for ProtocolOptions {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let result = match self {
            ProtocolOptions::Tcp(tcp_opts) => tcp_opts.qemu_params().await?,
            ProtocolOptions::Unix(unix_opts) => unix_opts.qemu_params().await?,
            ProtocolOptions::None => Vec::new(),
        };
        Ok(result)
    }
}

#[derive(Debug)]
struct ChardevSocket {
    id: String,
    server: bool,
    wait: bool,
    protocol_options: ProtocolOptions,
}

impl ChardevSocket {
    fn new(id: &str) -> ChardevSocket {
        ChardevSocket {
            id: id.to_owned(),
            server: false,
            wait: true,
            protocol_options: ProtocolOptions::None,
        }
    }

    fn set_server(&mut self, server: bool) -> &mut Self {
        self.server = server;
        self
    }

    fn set_wait(&mut self, wait: bool) -> &mut Self {
        self.wait = wait;
        self
    }

    fn set_socket_opts(&mut self, opts: ProtocolOptions) -> &mut Self {
        self.protocol_options = opts;
        self
    }
}

#[async_trait]
impl ToQemuParams for ChardevSocket {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("socket".to_owned());
        params.push(format!("id={}", self.id));
        if self.server {
            params.push("server=on".to_owned());
            if self.wait {
                params.push("wait=on".to_owned());
            } else {
                params.push("wait=off".to_owned());
            }
        }
        params.append(&mut self.protocol_options.qemu_params().await?);
        Ok(vec!["-chardev".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceVhostUserFs {
    bus_type: VirtioBusType,
    chardev: String,
    tag: String,
    queue_size: u64,
    romfile: String,
    iommu_platform: bool,
    devno: Option<String>,
}

impl DeviceVhostUserFs {
    fn new(
        chardev: &str,
        tag: &str,
        bus_type: VirtioBusType,
        devno: Option<String>,
    ) -> DeviceVhostUserFs {
        DeviceVhostUserFs {
            bus_type,
            chardev: chardev.to_owned(),
            tag: tag.to_owned(),
            queue_size: 0,
            romfile: String::new(),
            iommu_platform: false,
            devno,
        }
    }

    fn set_queue_size(&mut self, queue_size: u64) -> &mut Self {
        if queue_size <= 1024 && queue_size.is_power_of_two() {
            self.queue_size = queue_size;
        } else if queue_size != 0 {
            // zero is not an error here as it's treated as "value not set"
            // throughout runtime-rs
            warn!(
                sl!(),
                "bad vhost-user-fs-{} queue_size (must be power of two): {}, ignoring",
                self.bus_type,
                queue_size
            );
        }
        self
    }

    #[allow(dead_code)]
    fn set_romfile(&mut self, romfile: &str) -> &mut Self {
        self.romfile = romfile.to_owned();
        self
    }

    fn set_iommu_platform(&mut self, iommu_platform: bool) -> &mut Self {
        self.iommu_platform = iommu_platform;
        self
    }
}

#[async_trait]
impl ToQemuParams for DeviceVhostUserFs {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("vhost-user-fs-{}", self.bus_type));
        params.push(format!("chardev={}", self.chardev));
        params.push(format!("tag={}", self.tag));
        if self.queue_size != 0 {
            params.push(format!("queue-size={}", self.queue_size));
        }
        if !self.romfile.is_empty() {
            params.push(format!("romfile={}", self.romfile));
        }
        if self.iommu_platform {
            params.push("iommu_platform=on".to_owned());
        }
        if let Some(devno) = &self.devno {
            params.push(format!("devno={}", devno));
        }
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceNvdimm {
    memdev: String,
    unarmed: bool,
}

impl DeviceNvdimm {
    fn new(memdev: &str, unarmed: bool) -> DeviceNvdimm {
        DeviceNvdimm {
            memdev: memdev.to_owned(),
            unarmed,
        }
    }
}

#[async_trait]
impl ToQemuParams for DeviceNvdimm {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("nvdimm".to_owned());
        params.push(format!("memdev={}", self.memdev));
        if self.unarmed {
            params.push("unarmed=on".to_owned());
        }
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct BlockBackend {
    driver: String,
    id: String,
    path: String,
    aio: String,
    cache_direct: bool,
    cache_no_flush: bool,
    read_only: bool,
}

impl BlockBackend {
    fn new(id: &str, path: &str, cache_direct: bool) -> BlockBackend {
        BlockBackend {
            driver: "file".to_owned(),
            id: id.to_owned(),
            path: path.to_owned(),
            aio: "threads".to_owned(),
            cache_direct,
            cache_no_flush: false,
            read_only: true,
        }
    }

    #[allow(dead_code)]
    fn set_driver(&mut self, driver: &str) -> &mut Self {
        self.driver = driver.to_owned();
        self
    }

    #[allow(dead_code)]
    fn set_aio(&mut self, aio: &str) -> &mut Self {
        self.aio = aio.to_owned();
        self
    }

    #[allow(dead_code)]
    fn set_cache_direct(&mut self, cache_direct: bool) -> &mut Self {
        self.cache_direct = cache_direct;
        self
    }

    #[allow(dead_code)]
    fn set_cache_no_flush(&mut self, cache_no_flush: bool) -> &mut Self {
        self.cache_no_flush = cache_no_flush;
        self
    }

    #[allow(dead_code)]
    fn set_read_only(&mut self, read_only: bool) -> &mut Self {
        self.read_only = read_only;
        self
    }
}

#[async_trait]
impl ToQemuParams for BlockBackend {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("driver={}", self.driver));
        params.push(format!("node-name=image-{}", self.id));
        params.push(format!("filename={}", self.path));
        params.push(format!("aio={}", self.aio));
        if self.cache_direct {
            params.push("cache.direct=on".to_owned());
        } else {
            params.push("cache.direct=off".to_owned());
        }
        if self.cache_no_flush {
            params.push("cache.no-flush=on".to_owned());
        } else {
            params.push("cache.no-flush=off".to_owned());
        }
        if self.read_only {
            params.push("auto-read-only=on".to_owned());
        } else {
            params.push("auto-read-only=off".to_owned());
        }
        Ok(vec!["-blockdev".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceVirtioBlk {
    bus_type: VirtioBusType,
    id: String,
    config_wce: bool,
    share_rw: bool,
    devno: Option<String>,
}

impl DeviceVirtioBlk {
    fn new(id: &str, bus_type: VirtioBusType, devno: Option<String>) -> DeviceVirtioBlk {
        DeviceVirtioBlk {
            bus_type,
            id: id.to_owned(),
            config_wce: false,
            share_rw: true,
            devno,
        }
    }

    #[allow(dead_code)]
    fn set_config_wce(&mut self, config_wce: bool) -> &mut Self {
        self.config_wce = config_wce;
        self
    }

    #[allow(dead_code)]
    fn set_share_rw(&mut self, share_rw: bool) -> &mut Self {
        self.share_rw = share_rw;
        self
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtioBlk {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("virtio-blk-{}", self.bus_type));
        params.push(format!("drive=image-{}", self.id));
        if self.config_wce {
            params.push("config-wce=on".to_owned());
        } else {
            params.push("config-wce=off".to_owned());
        }
        if self.share_rw {
            params.push("share-rw=on".to_owned());
        } else {
            params.push("share-rw=off".to_owned());
        }
        params.push(format!("serial=image-{}", self.id));
        if let Some(devno) = &self.devno {
            params.push(format!("devno={}", devno));
        }
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

struct VhostVsock {
    bus_type: VirtioBusType,
    vhostfd: tokio::fs::File,
    guest_cid: u32,
    disable_modern: bool,
    iommu_platform: bool,
    devno: Option<String>,
}

impl VhostVsock {
    fn new(
        vhostfd: tokio::fs::File,
        guest_cid: u32,
        bus_type: VirtioBusType,
        devno: Option<String>,
    ) -> VhostVsock {
        VhostVsock {
            bus_type,
            vhostfd,
            guest_cid,
            disable_modern: false,
            iommu_platform: false,
            devno,
        }
    }

    fn set_disable_modern(&mut self, disable_modern: bool) -> &mut Self {
        self.disable_modern = disable_modern;
        self
    }

    fn set_iommu_platform(&mut self, iommu_platform: bool) -> &mut Self {
        self.iommu_platform = iommu_platform;
        self
    }
}

#[async_trait]
impl ToQemuParams for VhostVsock {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("vhost-vsock-{}", self.bus_type));
        if self.disable_modern {
            params.push("disable-modern=true".to_owned());
        }
        if self.iommu_platform {
            params.push("iommu_platform=on".to_owned());
        }
        if let Some(devno) = &self.devno {
            params.push(format!("devno={}", devno));
        }
        params.push(format!("vhostfd={}", self.vhostfd.as_raw_fd()));
        params.push(format!("guest-cid={}", self.guest_cid));

        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct NumaNode {
    memdev: String,
}

impl NumaNode {
    fn new(memdev: &str) -> NumaNode {
        NumaNode {
            memdev: memdev.to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for NumaNode {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("node".to_owned());
        params.push(format!("memdev={}", self.memdev));

        Ok(vec!["-numa".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct Serial {
    character_device: String,
}

impl Serial {
    #[allow(dead_code)]
    fn new(character_device: &str) -> Serial {
        Serial {
            character_device: character_device.to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for Serial {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        Ok(vec!["-serial".to_owned(), self.character_device.clone()])
    }
}

fn format_fds(files: &[File]) -> String {
    files
        .iter()
        .map(|file| file.as_raw_fd().to_string())
        .collect::<Vec<String>>()
        .join(":")
}

#[derive(Debug)]
pub struct Netdev {
    id: String,

    // File descriptors for vhost multi-queue support.
    // {
    //      queue_fds: Vec<File>,
    //      vhost_fds: Vec<File>,
    // }
    fds: HashMap<String, Vec<File>>,

    // disable_vhost_net disables virtio device emulation from the host kernel instead of from qemu.
    disable_vhost_net: bool,
}

impl Netdev {
    fn new(id: &str, host_if_name: &str, num_queues: u32) -> Result<Netdev> {
        let fds = HashMap::from([
            (
                "fds".to_owned(),
                open_named_tuntap(host_if_name, num_queues)?,
            ),
            ("vhostfds".to_owned(), create_vhost_net_fds(num_queues)?),
        ]);
        for file in fds.values().flatten() {
            clear_cloexec(file.as_raw_fd()).context("clearing O_CLOEXEC failed")?;
        }

        Ok(Netdev {
            id: id.to_owned(),
            fds,
            disable_vhost_net: false,
        })
    }

    fn set_disable_vhost_net(&mut self, disable_vhost_net: bool) -> &mut Self {
        self.disable_vhost_net = disable_vhost_net;
        self
    }

    pub fn get_id(&self) -> &String {
        &self.id
    }

    pub fn get_fds(&self) -> &Vec<File> {
        &self.fds["fds"]
    }

    pub fn get_vhostfds(&self) -> &Vec<File> {
        &self.fds["vhostfds"]
    }
}

#[async_trait]
impl ToQemuParams for Netdev {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params: Vec<String> = Vec::new();
        params.push("tap".to_owned());
        params.push(format!("id={}", self.id));

        if !self.disable_vhost_net {
            params.push("vhost=on".to_owned());
            if let Some(vhost_fds) = self.fds.get("vhostfds") {
                params.push(format!("vhostfds={}", format_fds(vhost_fds)));
            }
        }

        if let Some(tuntap_fds) = self.fds.get("fds") {
            params.push(format!("fds={}", format_fds(tuntap_fds)));
        }

        Ok(vec!["-netdev".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
pub struct DeviceVirtioNet {
    // driver is the qemu device driver
    device_driver: String,

    // id is the corresponding backend net device identifier.
    netdev_id: String,

    // mac_address is the guest-side networking device interface MAC address.
    mac_address: Address,

    // disable_modern prevents qemu from relying on fast MMIO.
    disable_modern: bool,

    num_queues: u32,
    iommu_platform: bool,
}

impl DeviceVirtioNet {
    fn new(netdev_id: &str, mac_address: Address) -> DeviceVirtioNet {
        DeviceVirtioNet {
            device_driver: "virtio-net-pci".to_owned(),
            netdev_id: netdev_id.to_owned(),
            mac_address,
            disable_modern: false,
            num_queues: 1,
            iommu_platform: false,
        }
    }

    fn set_disable_modern(&mut self, disable_modern: bool) -> &mut Self {
        self.disable_modern = disable_modern;
        self
    }

    fn set_num_queues(&mut self, num_queues: u32) -> &mut Self {
        self.num_queues = num_queues;
        self
    }

    fn set_iommu_platform(&mut self, iommu_platform: bool) -> &mut Self {
        self.iommu_platform = iommu_platform;
        self
    }

    pub fn get_netdev_id(&self) -> &String {
        &self.netdev_id
    }

    pub fn get_device_driver(&self) -> &String {
        &self.device_driver
    }

    pub fn get_mac_addr(&self) -> String {
        format!("{:?}", self.mac_address)
    }

    pub fn get_num_queues(&self) -> u32 {
        self.num_queues
    }

    pub fn get_disable_modern(&self) -> bool {
        self.disable_modern
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtioNet {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params: Vec<String> = Vec::new();

        //params.push(format!("driver={}", &self.device_driver.to_string()));
        params.push(self.device_driver.clone());
        params.push(format!("netdev={}", &self.netdev_id));

        params.push(format!("mac={:?}", self.mac_address));

        if self.disable_modern {
            params.push("disable-modern=true".to_owned());
        }
        if self.iommu_platform {
            params.push("iommu_platform=on".to_owned());
        }

        params.push("mq=on".to_owned());
        params.push(format!("vectors={}", 2 * self.num_queues + 2));

        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceVirtioSerial {
    id: String,
    bus_type: VirtioBusType,
    iommu_platform: bool,
    devno: Option<String>,
}

impl DeviceVirtioSerial {
    fn new(id: &str, bus_type: VirtioBusType, devno: Option<String>) -> DeviceVirtioSerial {
        DeviceVirtioSerial {
            id: id.to_owned(),
            bus_type,
            iommu_platform: false,
            devno,
        }
    }

    fn set_iommu_platform(&mut self, iommu_platform: bool) -> &mut Self {
        self.iommu_platform = iommu_platform;
        self
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtioSerial {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("virtio-serial-{}", self.bus_type));
        params.push(format!("id={}", self.id));
        if self.iommu_platform {
            params.push("iommu_platform=on".to_owned());
        }
        if let Some(devno) = &self.devno {
            params.push(format!("devno={}", devno));
        }
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceVirtconsole {
    id: String,
    chardev: String,
}

impl DeviceVirtconsole {
    fn new(id: &str, chardev: &str) -> DeviceVirtconsole {
        DeviceVirtconsole {
            id: id.to_owned(),
            chardev: chardev.to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtconsole {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("virtconsole".to_owned());
        params.push(format!("id={}", self.id));
        params.push(format!("chardev={}", self.chardev));
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

// RTC represents a qemu Real Time Clock configuration.
#[derive(Debug)]
struct Rtc {
    // Base is the RTC start time.
    base: String,

    // Clock is the is the RTC clock driver.
    clock: String,

    // DriftFix is the drift fixing mechanism.
    driftfix: String,
}

impl Rtc {
    fn new() -> Rtc {
        Rtc {
            base: "utc".to_owned(),
            clock: "host".to_owned(),
            driftfix: "slew".to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for Rtc {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("base={}", self.base));
        params.push(format!("clock={}", self.clock));
        params.push(format!("driftfix={}", self.driftfix));
        Ok(vec!["-rtc".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct ObjectRngRandom {
    // id is the device ID
    id: String,

    // filename is the entropy source on the host
    filename: String,
}

impl ObjectRngRandom {
    fn new() -> ObjectRngRandom {
        ObjectRngRandom {
            id: "rng0".to_owned(),
            filename: "/dev/urandom".to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for ObjectRngRandom {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut object_params = Vec::new();

        object_params.push("rng-random".to_owned());
        object_params.push(format!("id={}", self.id));
        object_params.push(format!("filename={}", self.filename));

        Ok(vec!["-object".to_owned(), object_params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceRng {
    // transport is the virtio transport for this device.
    transport: String,
}

impl DeviceRng {
    fn new() -> DeviceRng {
        DeviceRng {
            transport: "virtio-rng-pci".to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for DeviceRng {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut device_params = Vec::new();

        device_params.push(self.transport.clone());
        device_params.push(format!("rng={}", "rng0".to_owned()));

        Ok(vec!["-device".to_owned(), device_params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceIntelIommu {
    intremap: bool,
    device_iotlb: bool,
    caching_mode: bool,
}

impl DeviceIntelIommu {
    fn new() -> DeviceIntelIommu {
        DeviceIntelIommu {
            intremap: true,
            device_iotlb: true,
            caching_mode: true,
        }
    }
}

#[async_trait]
impl ToQemuParams for DeviceIntelIommu {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("intel-iommu".to_owned());
        let to_onoff = |b| if b { "on" } else { "off" };
        params.push(format!("intremap={}", to_onoff(self.intremap)));
        params.push(format!("device-iotlb={}", to_onoff(self.device_iotlb)));
        params.push(format!("caching-mode={}", to_onoff(self.caching_mode)));
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct DevicePciBridge {
    driver: String,
    bus: String,
    id: String,
    chassis_nr: u32,
    shpc: bool,
    addr: u32,
    io_reserve: String,
    mem_reserve: String,
    pref64_reserve: String,
}

impl DevicePciBridge {
    fn new(config: &HypervisorConfig, bridge_idx: u32) -> DevicePciBridge {
        DevicePciBridge {
            // The go runtime doesn't support bridges other than PCI although
            // PCIe should also be available.  Stick with the legacy behaviour
            // of ignoring PCIe since it's not clear to me how to decide
            // between the two.
            driver: "pci-bridge".to_owned(),
            bus: match config.machine_info.machine_type.as_str() {
                "q35" | "virt" => "pcie.0",
                _ => "pci.0",
            }
            .to_owned(),
            id: format!("pci-bridge-{}", bridge_idx),
            // Each bridge is required to be assigned a unique chassis id > 0.
            chassis_nr: bridge_idx + 1,
            shpc: false,
            // 2 is documented by the go runtime as the first slot available
            // for a bridge (on x86_64)
            // (https://github.com/kata-containers/kata-containers/blob/99730256a2899c82d111400024621519d17ea15d/src/runtime/virtcontainers/qemu_arch_base.go#L212)
            addr: 2 + bridge_idx,
            // Values taken from the go runtime implementation which comments
            // the choices as follows:
            // Certain guest BIOS versions think !SHPC means no hotplug, and
            // won't reserve the IO and memory windows that will be needed for
            // devices added underneath this bridge.  This will only break for
            // certain combinations of exact qemu, BIOS and guest kernel
            // versions, but for consistency, just hint the usual default
            // windows for a bridge (as the BIOS would use with SHPC) so that
            // we can do ACPI hotplug.
            // (https://github.com/kata-containers/kata-containers/blob/99730256a2899c82d111400024621519d17ea15d/src/runtime/virtcontainers/qemu.go#L2474)
            io_reserve: "4k".to_owned(),
            mem_reserve: "1m".to_owned(),
            pref64_reserve: "1m".to_owned(),
        }
    }
}

#[async_trait]
impl ToQemuParams for DevicePciBridge {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(self.driver.clone());
        params.push(format!("bus={}", self.bus));
        params.push(format!("id={}", self.id));
        params.push(format!("chassis_nr={}", self.chassis_nr));
        params.push(format!("shpc={}", if self.shpc { "on" } else { "off" }));
        params.push(format!("addr={}", self.addr));
        params.push(format!("io-reserve={}", self.io_reserve));
        params.push(format!("mem-reserve={}", self.mem_reserve));
        params.push(format!("pref64-reserve={}", self.pref64_reserve));
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

// Qemu provides methods and types for managing QEMU instances.
// To manage a qemu instance after it has been launched you need
// to pass the -qmp option during launch requesting the qemu instance
// to create a QMP unix domain manageent socket, e.g.,
// -qmp unix:fd=SOCK_FD,server=on,wait=off.
// -monitor unix:path=SOCK_PATH,server=on,wait=off.
#[derive(Debug, Default, PartialEq)]
pub enum MonitorProtocol {
    // Socket using a human-friendly text-based protocol.
    Hmp,

    // Socket using a richer json-based protocol.
    #[default]
    Qmp,

    // Same as Qmp with pretty json formatting.
    QmpPretty,
}

impl MonitorProtocol {
    pub fn new(proto: &str) -> Self {
        match proto {
            "hmp" => MonitorProtocol::Hmp,
            "qmp-pretty" => MonitorProtocol::QmpPretty,
            _ => MonitorProtocol::Qmp,
        }
    }
}

impl std::fmt::Display for MonitorProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let to_string = match *self {
            MonitorProtocol::Hmp => "monitor".to_string(),
            MonitorProtocol::QmpPretty => "qmp-pretty".to_string(),
            _ => "qmp".to_string(),
        };
        write!(f, "{}", to_string)
    }
}

#[derive(Debug)]
enum QmpSockType {
    Fd(File),
    Path(PathBuf),
}

#[derive(Debug)]
pub struct QmpSocket {
    // protocol to be used on the socket.
    protocol: MonitorProtocol,
    // QMP unix socket to be passed to qemu
    address: QmpSockType,
    // server tells if this is a server socket.
    server: bool,
    // nowait tells if qemu should block waiting for a client to connect.
    nowait: bool,
}

impl QmpSocket {
    fn new(proto: MonitorProtocol) -> Result<Self> {
        let qmp_socket = match proto {
            MonitorProtocol::Qmp | MonitorProtocol::QmpPretty => {
                // let sock_path = root_path.join(QMP_SOCKET_FILE);
                let listener =
                    UnixListener::bind(QMP_SOCKET_FILE).context("unix listener bind failed.")?;
                let raw_fd = listener.into_raw_fd();
                clear_cloexec(raw_fd).context("clearing unix listenser O_CLOEXEC failed")?;
                let sock_file = unsafe { File::from_raw_fd(raw_fd) };
                // The default QMP socket or called base socket is qmp.sock.
                QmpSocket {
                    protocol: MonitorProtocol::new("qmp"),
                    address: QmpSockType::Fd(sock_file),
                    server: true,
                    nowait: true,
                }
            }
            MonitorProtocol::Hmp => {
                // If extra monitor needed, HMP socket with qmp-extra.sock will be added.
                QmpSocket {
                    protocol: MonitorProtocol::new("hmp"),
                    address: QmpSockType::Path(PathBuf::from(DEBUG_MONITOR_SOCKET)),
                    server: true,
                    nowait: true,
                }
            }
        };

        Ok(qmp_socket)
    }
}

#[async_trait]
impl ToQemuParams for QmpSocket {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let param_qmp = format!("-{}", self.protocol);

        let mut params: Vec<String> = Vec::new();

        match &self.address {
            // -qmp unix:fd=SOCK_FD,server=on,wait=off
            QmpSockType::Fd(f) => params.push(format!("unix:fd={}", f.as_raw_fd())),
            // -monitor unix:path=SOCK_PATH,server=on,wait=off
            QmpSockType::Path(p) => params.push(format!("unix:path={}", p.display())),
        }

        if self.server {
            params.push("server=on".to_owned());
            if self.nowait {
                params.push("wait=off".to_owned());
            }
        }

        Ok(vec![param_qmp, params.join(",")])
    }
}

#[derive(Debug)]
struct DeviceVirtioScsi {
    bus_type: VirtioBusType,
    id: String,
    disable_modern: bool,
    iothread: String,
    iommu_platform: bool,
    devno: Option<String>,
}

impl DeviceVirtioScsi {
    fn new(id: &str, disable_modern: bool, bus_type: VirtioBusType, devno: Option<String>) -> Self {
        DeviceVirtioScsi {
            bus_type,
            id: id.to_owned(),
            disable_modern,
            iothread: "".to_owned(),
            iommu_platform: false,
            devno,
        }
    }

    fn set_iothread(&mut self, iothread: &str) {
        self.iothread = iothread.to_owned();
    }

    fn set_iommu_platform(&mut self, iommu_platform: bool) -> &mut Self {
        self.iommu_platform = iommu_platform;
        self
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtioScsi {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push(format!("virtio-scsi-{}", self.bus_type));
        params.push(format!("id={}", self.id));
        if self.disable_modern {
            params.push("disable-modern=true".to_owned());
        }
        if !self.iothread.is_empty() {
            params.push(format!("iothread={}", self.iothread));
        }
        if self.iommu_platform {
            params.push("iommu_platform=on".to_owned());
        }
        if let Some(devno) = &self.devno {
            params.push(format!("devno={}", devno));
        }
        Ok(vec!["-device".to_owned(), params.join(",")])
    }
}

#[derive(Debug)]
struct ObjectIoThread {
    id: String,
}

impl ObjectIoThread {
    fn new(id: &str) -> Self {
        ObjectIoThread { id: id.to_owned() }
    }
}

#[async_trait]
impl ToQemuParams for ObjectIoThread {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        let mut params = Vec::new();
        params.push("iothread".to_owned());
        params.push(format!("id={}", self.id));
        Ok(vec!["-object".to_owned(), params.join(",")])
    }
}

fn is_running_in_vm() -> Result<bool> {
    let res = read_to_string("/proc/cpuinfo")?
        .lines()
        .find(|line| line.starts_with("flags"))
        .ok_or(anyhow!("flags line not found"))?
        .split(' ')
        .map(String::from)
        .skip(1)
        .any(|flag| flag == "hypervisor");
    Ok(res)
}

fn should_disable_modern() -> bool {
    match is_running_in_vm() {
        Ok(retval) => retval,
        Err(err) => {
            info!(
                sl!(),
                "unable to check if running in VM, assuming not: {}", err
            );
            false
        }
    }
}

pub struct QemuCmdLine<'a> {
    id: String,
    config: &'a HypervisorConfig,

    // In principle, all objects implementing ToQemuParams could be just stored
    // in the `devices` container.  However, there are several special cases
    // that might need to be set up in several steps after having been
    // initially constructed (from HypervisorConfig, mostly).  For instance,
    // adding an NVDIMM needs to modify Machine and query Memory, adding a
    // virtiofs share modifies both Memory and Machine, adding a serial console
    // modifies Kernel etc.  For convenience accessing them, we store these
    // singletons in named QemuCmdLine member.  The rest should go to the
    // anonymous `devices` container.
    kernel: Kernel,
    memory: Memory,
    smp: Smp,
    machine: Machine,
    cpu: Cpu,
    qmp_socket: QmpSocket,

    knobs: Knobs,

    devices: Vec<Box<dyn ToQemuParams>>,
    ccw_subchannel: Option<CcwSubChannel>,
}

impl<'a> QemuCmdLine<'a> {
    pub fn new(id: &str, config: &'a HypervisorConfig) -> Result<QemuCmdLine<'a>> {
        let ccw_subchannel = match bus_type(config) {
            VirtioBusType::Ccw => Some(CcwSubChannel::new()),
            _ => None,
        };
        let mut qemu_cmd_line = QemuCmdLine {
            id: id.to_string(),
            config,
            kernel: Kernel::new(config)?,
            memory: Memory::new(config),
            smp: Smp::new(config),
            machine: Machine::new(config),
            cpu: Cpu::new(config),
            qmp_socket: QmpSocket::new(MonitorProtocol::Qmp)?,
            knobs: Knobs::new(config),
            devices: Vec::new(),
            ccw_subchannel,
        };

        if config.device_info.enable_iommu {
            qemu_cmd_line.add_iommu();
        }

        if config.debug_info.enable_debug && !config.debug_info.dbg_monitor_socket.is_empty() {
            qemu_cmd_line.add_monitor(&config.debug_info.dbg_monitor_socket)?;
        }

        qemu_cmd_line.add_rtc();

        if bus_type(config) != VirtioBusType::Ccw {
            qemu_cmd_line.add_rng();
        }

        if bus_type(config) != VirtioBusType::Ccw && config.device_info.default_bridges > 0 {
            qemu_cmd_line.add_bridges(config.device_info.default_bridges);
        }

        if config.blockdev_info.block_device_driver == VIRTIO_SCSI {
            qemu_cmd_line.add_scsi_controller();
        }

        if config.device_info.reclaim_guest_freed_memory {
            qemu_cmd_line.add_virtio_balloon();
        }

        Ok(qemu_cmd_line)
    }

    fn add_monitor(&mut self, proto: &str) -> Result<()> {
        let monitor = QmpSocket::new(MonitorProtocol::new(proto))?;
        self.devices.push(Box::new(monitor));

        Ok(())
    }

    fn add_rtc(&mut self) {
        let rtc = Rtc::new();
        self.devices.push(Box::new(rtc));
    }

    fn add_rng(&mut self) {
        let rng_object = ObjectRngRandom::new();
        let rng_device = DeviceRng::new();

        self.devices.push(Box::new(rng_object));
        self.devices.push(Box::new(rng_device));
    }

    fn add_iommu(&mut self) {
        let dev_iommu = DeviceIntelIommu::new();
        self.devices.push(Box::new(dev_iommu));

        self.kernel
            .params
            .append(&mut KernelParams::from_string("intel_iommu=on iommu=pt"));

        self.machine.set_kernel_irqchip("split");
    }

    fn add_bridges(&mut self, count: u32) {
        for idx in 0..count {
            let bridge = DevicePciBridge::new(self.config, idx);
            self.devices.push(Box::new(bridge));
        }
    }

    fn add_scsi_controller(&mut self) {
        let devno = get_devno_ccw(&mut self.ccw_subchannel, "scsi0");
        let mut virtio_scsi = DeviceVirtioScsi::new(
            "scsi0",
            should_disable_modern(),
            bus_type(self.config),
            devno,
        );

        if self.config.device_info.enable_iommu_platform
            && bus_type(self.config) == VirtioBusType::Ccw
        {
            virtio_scsi.set_iommu_platform(true);
        }

        if self.config.enable_iothreads {
            let iothread_id = "scsi-io-thread";
            let iothread = ObjectIoThread::new(iothread_id);
            virtio_scsi.set_iothread(iothread_id);
            self.devices.push(Box::new(iothread));
        }
        self.devices.push(Box::new(virtio_scsi));
    }

    pub fn add_virtiofs_share(
        &mut self,
        virtiofsd_socket_path: &str,
        mount_tag: &str,
        queue_size: u64,
    ) {
        let chardev_name = "virtiofsd-chardev";

        // virtiofsd socket device
        let mut virtiofsd_socket_chardev = ChardevSocket::new(chardev_name);
        virtiofsd_socket_chardev.set_socket_opts(ProtocolOptions::Unix(UnixSocketOpts {
            path: virtiofsd_socket_path.to_owned(),
        }));

        self.devices.push(Box::new(virtiofsd_socket_chardev));

        let bus_type = bus_type(self.config);
        let devno = get_devno_ccw(&mut self.ccw_subchannel, chardev_name);
        let mut virtiofs_device = DeviceVhostUserFs::new(chardev_name, mount_tag, bus_type, devno);
        virtiofs_device.set_queue_size(queue_size);
        if self.config.device_info.enable_iommu_platform && bus_type == VirtioBusType::Ccw {
            virtiofs_device.set_iommu_platform(true);
        }
        self.devices.push(Box::new(virtiofs_device));

        let mut mem_file =
            MemoryBackendFile::new("entire-guest-memory-share", "/dev/shm", self.memory.size);
        mem_file.set_share(true);

        // don't put the /dev/shm memory backend file into the anonymous container,
        // there has to be at most one of those so keep it by name in Memory instead
        //self.devices.push(Box::new(mem_file));
        self.memory.set_memory_backend_file(&mem_file);

        match bus_type {
            VirtioBusType::Pci => {
                self.machine.set_nvdimm(true);
                self.devices.push(Box::new(NumaNode::new(&mem_file.id)));
            }
            VirtioBusType::Ccw => {
                self.machine.set_memory_backend(&mem_file.id);
            }
        }
    }

    pub fn add_vsock(&mut self, vhostfd: tokio::fs::File, guest_cid: u32) -> Result<()> {
        clear_cloexec(vhostfd.as_raw_fd()).context("clearing O_CLOEXEC failed on vsock fd")?;

        let devno = get_devno_ccw(&mut self.ccw_subchannel, "vsock-0");
        let mut vhost_vsock_pci = VhostVsock::new(vhostfd, guest_cid, bus_type(self.config), devno);

        if !self.config.disable_nesting_checks && should_disable_modern() {
            vhost_vsock_pci.set_disable_modern(true);
        }

        if self.config.device_info.enable_iommu_platform
            && bus_type(self.config) == VirtioBusType::Ccw
        {
            vhost_vsock_pci.set_iommu_platform(true);
        }

        self.devices.push(Box::new(vhost_vsock_pci));
        Ok(())
    }

    pub fn add_nvdimm(&mut self, path: &str, is_readonly: bool) -> Result<()> {
        self.machine.set_nvdimm(true);
        if self.memory.max_size == 0 || self.memory.num_slots == 0 {
            info!(
                sl!(),
                "both memory max size and num slots must be set for nvdimm"
            );
            return Err(anyhow!(
                "both memory max size and num slots must be set for nvdimm"
            ));
        }

        let filesize = match std::fs::metadata(path) {
            Ok(metadata) => metadata.len(),
            Err(err) => {
                info!(sl!(), "couldn't get size of {}: {}", path, err);
                return Err(err.into());
            }
        };

        let mut mem_file = MemoryBackendFile::new("TODO", path, filesize);
        mem_file.set_readonly(is_readonly);
        self.devices.push(Box::new(mem_file));

        let nvdimm = DeviceNvdimm::new("TODO", is_readonly);
        self.devices.push(Box::new(nvdimm));

        Ok(())
    }

    pub fn add_block_device(&mut self, device_id: &str, path: &str, is_direct: bool) -> Result<()> {
        self.devices
            .push(Box::new(BlockBackend::new(device_id, path, is_direct)));
        let devno = get_devno_ccw(&mut self.ccw_subchannel, device_id);
        self.devices.push(Box::new(DeviceVirtioBlk::new(
            device_id,
            bus_type(self.config),
            devno,
        )));
        Ok(())
    }

    #[allow(dead_code)]
    pub fn add_serial_console(&mut self, character_device_file_path: &str) {
        let serial = Serial::new(character_device_file_path);
        self.devices.push(Box::new(serial));

        self.kernel.params.append(&mut KernelParams::from_string(
            "systemd.log_target=console console=ttyS0",
        ));
    }

    pub fn add_network_device(&mut self, host_dev_name: &str, guest_mac: Address) -> Result<()> {
        let (netdev, virtio_net_device) =
            get_network_device(self.config, host_dev_name, guest_mac)?;

        self.devices.push(Box::new(netdev));
        self.devices.push(Box::new(virtio_net_device));
        Ok(())
    }

    pub fn add_console(&mut self, console_socket_path: &str) {
        let devno = get_devno_ccw(&mut self.ccw_subchannel, "serial0");
        let mut serial_dev = DeviceVirtioSerial::new("serial0", bus_type(self.config), devno);
        if self.config.device_info.enable_iommu_platform
            && bus_type(self.config) == VirtioBusType::Ccw
        {
            serial_dev.set_iommu_platform(true);
        }
        self.devices.push(Box::new(serial_dev));

        let chardev_name = "charconsole0";
        let console_device = DeviceVirtconsole::new("console0", chardev_name);
        self.devices.push(Box::new(console_device));

        let mut console_socket_chardev = ChardevSocket::new(chardev_name);
        console_socket_chardev.set_socket_opts(ProtocolOptions::Unix(UnixSocketOpts {
            path: console_socket_path.to_owned(),
        }));
        console_socket_chardev.set_server(true);
        console_socket_chardev.set_wait(false);
        self.devices.push(Box::new(console_socket_chardev));
    }

    pub fn add_virtio_balloon(&mut self) {
        let balloon_device = DeviceVirtioBalloon::new();
        self.devices.push(Box::new(balloon_device));
    }

    pub async fn build(&self) -> Result<Vec<String>> {
        let mut result = Vec::new();

        result.append(&mut vec![
            "-name".to_owned(),
            format!("sandbox-{}", self.id),
        ]);
        result.append(&mut self.kernel.qemu_params().await?);
        result.append(&mut self.smp.qemu_params().await?);
        result.append(&mut self.machine.qemu_params().await?);
        result.append(&mut self.cpu.qemu_params().await?);
        result.append(&mut self.memory.qemu_params().await?);
        result.append(&mut self.qmp_socket.qemu_params().await?);

        for device in &self.devices {
            result.append(&mut device.qemu_params().await?);
        }

        result.append(&mut self.knobs.qemu_params().await?);

        Ok(result)
    }
}

pub fn get_network_device(
    config: &HypervisorConfig,
    host_dev_name: &str,
    guest_mac: Address,
) -> Result<(Netdev, DeviceVirtioNet)> {
    let mut netdev = Netdev::new(
        &format!("network-{}", host_dev_name),
        host_dev_name,
        config.network_info.network_queues,
    )?;
    if config.network_info.disable_vhost_net {
        netdev.set_disable_vhost_net(true);
    }

    let mut virtio_net_device = DeviceVirtioNet::new(&netdev.id, guest_mac);

    if should_disable_modern() {
        virtio_net_device.set_disable_modern(true);
    }
    if config.device_info.enable_iommu_platform && bus_type(config) == VirtioBusType::Ccw {
        virtio_net_device.set_iommu_platform(true);
    }
    if config.network_info.network_queues > 1 {
        virtio_net_device.set_num_queues(config.network_info.network_queues);
    }

    Ok((netdev, virtio_net_device))
}

fn get_devno_ccw(ccw_subchannel: &mut Option<CcwSubChannel>, device_name: &str) -> Option<String> {
    ccw_subchannel.as_mut().and_then(|subchannel| {
        subchannel.add_device(device_name).map_or_else(
            |err| {
                info!(sl!(), "failed to add device to subchannel: {:?}", err);
                None
            },
            |slot| Some(subchannel.address_format_ccw(slot)),
        )
    })
}

#[derive(Debug)]
struct DeviceVirtioBalloon {}

impl DeviceVirtioBalloon {
    fn new() -> Self {
        DeviceVirtioBalloon {}
    }
}

#[async_trait]
impl ToQemuParams for DeviceVirtioBalloon {
    async fn qemu_params(&self) -> Result<Vec<String>> {
        Ok(vec![
            "-device".to_owned(),
            "virtio-balloon,free-page-reporting=on".to_owned(),
        ])
    }
}
