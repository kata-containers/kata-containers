// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `github.com/containerd/cgroups/stats/v1/metrics.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Metrics {
    // message fields
    pub hugetlb: ::protobuf::RepeatedField<HugetlbStat>,
    pub pids: ::protobuf::SingularPtrField<PidsStat>,
    pub cpu: ::protobuf::SingularPtrField<CPUStat>,
    pub memory: ::protobuf::SingularPtrField<MemoryStat>,
    pub blkio: ::protobuf::SingularPtrField<BlkIOStat>,
    pub rdma: ::protobuf::SingularPtrField<RdmaStat>,
    pub network: ::protobuf::RepeatedField<NetworkStat>,
    pub cgroup_stats: ::protobuf::SingularPtrField<CgroupStats>,
    pub memory_oom_control: ::protobuf::SingularPtrField<MemoryOomControl>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metrics {
    fn default() -> &'a Metrics {
        <Metrics as ::protobuf::Message>::default_instance()
    }
}

impl Metrics {
    pub fn new() -> Metrics {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.HugetlbStat hugetlb = 1;


    pub fn get_hugetlb(&self) -> &[HugetlbStat] {
        &self.hugetlb
    }
    pub fn clear_hugetlb(&mut self) {
        self.hugetlb.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugetlb(&mut self, v: ::protobuf::RepeatedField<HugetlbStat>) {
        self.hugetlb = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugetlb(&mut self) -> &mut ::protobuf::RepeatedField<HugetlbStat> {
        &mut self.hugetlb
    }

    // Take field
    pub fn take_hugetlb(&mut self) -> ::protobuf::RepeatedField<HugetlbStat> {
        ::std::mem::replace(&mut self.hugetlb, ::protobuf::RepeatedField::new())
    }

    // .io.containerd.cgroups.v1.PidsStat pids = 2;


    pub fn get_pids(&self) -> &PidsStat {
        self.pids.as_ref().unwrap_or_else(|| <PidsStat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pids(&mut self) {
        self.pids.clear();
    }

    pub fn has_pids(&self) -> bool {
        self.pids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pids(&mut self, v: PidsStat) {
        self.pids = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pids(&mut self) -> &mut PidsStat {
        if self.pids.is_none() {
            self.pids.set_default();
        }
        self.pids.as_mut().unwrap()
    }

    // Take field
    pub fn take_pids(&mut self) -> PidsStat {
        self.pids.take().unwrap_or_else(|| PidsStat::new())
    }

    // .io.containerd.cgroups.v1.CPUStat cpu = 3;


    pub fn get_cpu(&self) -> &CPUStat {
        self.cpu.as_ref().unwrap_or_else(|| <CPUStat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    pub fn has_cpu(&self) -> bool {
        self.cpu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: CPUStat) {
        self.cpu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu(&mut self) -> &mut CPUStat {
        if self.cpu.is_none() {
            self.cpu.set_default();
        }
        self.cpu.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu(&mut self) -> CPUStat {
        self.cpu.take().unwrap_or_else(|| CPUStat::new())
    }

    // .io.containerd.cgroups.v1.MemoryStat memory = 4;


    pub fn get_memory(&self) -> &MemoryStat {
        self.memory.as_ref().unwrap_or_else(|| <MemoryStat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_memory(&mut self) {
        self.memory.clear();
    }

    pub fn has_memory(&self) -> bool {
        self.memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: MemoryStat) {
        self.memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory(&mut self) -> &mut MemoryStat {
        if self.memory.is_none() {
            self.memory.set_default();
        }
        self.memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory(&mut self) -> MemoryStat {
        self.memory.take().unwrap_or_else(|| MemoryStat::new())
    }

    // .io.containerd.cgroups.v1.BlkIOStat blkio = 5;


    pub fn get_blkio(&self) -> &BlkIOStat {
        self.blkio.as_ref().unwrap_or_else(|| <BlkIOStat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blkio(&mut self) {
        self.blkio.clear();
    }

    pub fn has_blkio(&self) -> bool {
        self.blkio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio(&mut self, v: BlkIOStat) {
        self.blkio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio(&mut self) -> &mut BlkIOStat {
        if self.blkio.is_none() {
            self.blkio.set_default();
        }
        self.blkio.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkio(&mut self) -> BlkIOStat {
        self.blkio.take().unwrap_or_else(|| BlkIOStat::new())
    }

    // .io.containerd.cgroups.v1.RdmaStat rdma = 6;


    pub fn get_rdma(&self) -> &RdmaStat {
        self.rdma.as_ref().unwrap_or_else(|| <RdmaStat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rdma(&mut self) {
        self.rdma.clear();
    }

    pub fn has_rdma(&self) -> bool {
        self.rdma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rdma(&mut self, v: RdmaStat) {
        self.rdma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rdma(&mut self) -> &mut RdmaStat {
        if self.rdma.is_none() {
            self.rdma.set_default();
        }
        self.rdma.as_mut().unwrap()
    }

    // Take field
    pub fn take_rdma(&mut self) -> RdmaStat {
        self.rdma.take().unwrap_or_else(|| RdmaStat::new())
    }

    // repeated .io.containerd.cgroups.v1.NetworkStat network = 7;


    pub fn get_network(&self) -> &[NetworkStat] {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::protobuf::RepeatedField<NetworkStat>) {
        self.network = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network(&mut self) -> &mut ::protobuf::RepeatedField<NetworkStat> {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::protobuf::RepeatedField<NetworkStat> {
        ::std::mem::replace(&mut self.network, ::protobuf::RepeatedField::new())
    }

    // .io.containerd.cgroups.v1.CgroupStats cgroup_stats = 8;


    pub fn get_cgroup_stats(&self) -> &CgroupStats {
        self.cgroup_stats.as_ref().unwrap_or_else(|| <CgroupStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cgroup_stats(&mut self) {
        self.cgroup_stats.clear();
    }

    pub fn has_cgroup_stats(&self) -> bool {
        self.cgroup_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_stats(&mut self, v: CgroupStats) {
        self.cgroup_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_stats(&mut self) -> &mut CgroupStats {
        if self.cgroup_stats.is_none() {
            self.cgroup_stats.set_default();
        }
        self.cgroup_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_cgroup_stats(&mut self) -> CgroupStats {
        self.cgroup_stats.take().unwrap_or_else(|| CgroupStats::new())
    }

    // .io.containerd.cgroups.v1.MemoryOomControl memory_oom_control = 9;


    pub fn get_memory_oom_control(&self) -> &MemoryOomControl {
        self.memory_oom_control.as_ref().unwrap_or_else(|| <MemoryOomControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_memory_oom_control(&mut self) {
        self.memory_oom_control.clear();
    }

    pub fn has_memory_oom_control(&self) -> bool {
        self.memory_oom_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_oom_control(&mut self, v: MemoryOomControl) {
        self.memory_oom_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_oom_control(&mut self) -> &mut MemoryOomControl {
        if self.memory_oom_control.is_none() {
            self.memory_oom_control.set_default();
        }
        self.memory_oom_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory_oom_control(&mut self) -> MemoryOomControl {
        self.memory_oom_control.take().unwrap_or_else(|| MemoryOomControl::new())
    }
}

impl ::protobuf::Message for Metrics {
    fn is_initialized(&self) -> bool {
        for v in &self.hugetlb {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pids {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkio {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rdma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cgroup_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory_oom_control {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hugetlb)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkio)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rdma)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cgroup_stats)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory_oom_control)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hugetlb {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pids.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rdma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.network {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory_oom_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hugetlb {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pids.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkio.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rdma.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.network {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cgroup_stats.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory_oom_control.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metrics {
        Metrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HugetlbStat>>(
                "hugetlb",
                |m: &Metrics| { &m.hugetlb },
                |m: &mut Metrics| { &mut m.hugetlb },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PidsStat>>(
                "pids",
                |m: &Metrics| { &m.pids },
                |m: &mut Metrics| { &mut m.pids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPUStat>>(
                "cpu",
                |m: &Metrics| { &m.cpu },
                |m: &mut Metrics| { &mut m.cpu },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryStat>>(
                "memory",
                |m: &Metrics| { &m.memory },
                |m: &mut Metrics| { &mut m.memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOStat>>(
                "blkio",
                |m: &Metrics| { &m.blkio },
                |m: &mut Metrics| { &mut m.blkio },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RdmaStat>>(
                "rdma",
                |m: &Metrics| { &m.rdma },
                |m: &mut Metrics| { &mut m.rdma },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStat>>(
                "network",
                |m: &Metrics| { &m.network },
                |m: &mut Metrics| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CgroupStats>>(
                "cgroup_stats",
                |m: &Metrics| { &m.cgroup_stats },
                |m: &mut Metrics| { &mut m.cgroup_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryOomControl>>(
                "memory_oom_control",
                |m: &Metrics| { &m.memory_oom_control },
                |m: &mut Metrics| { &mut m.memory_oom_control },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metrics>(
                "Metrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metrics {
        static instance: ::protobuf::rt::LazyV2<Metrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metrics::new)
    }
}

impl ::protobuf::Clear for Metrics {
    fn clear(&mut self) {
        self.hugetlb.clear();
        self.pids.clear();
        self.cpu.clear();
        self.memory.clear();
        self.blkio.clear();
        self.rdma.clear();
        self.network.clear();
        self.cgroup_stats.clear();
        self.memory_oom_control.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HugetlbStat {
    // message fields
    pub usage: u64,
    pub max: u64,
    pub failcnt: u64,
    pub pagesize: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HugetlbStat {
    fn default() -> &'a HugetlbStat {
        <HugetlbStat as ::protobuf::Message>::default_instance()
    }
}

impl HugetlbStat {
    pub fn new() -> HugetlbStat {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max = 2;


    pub fn get_max(&self) -> u64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u64) {
        self.max = v;
    }

    // uint64 failcnt = 3;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    // string pagesize = 4;


    pub fn get_pagesize(&self) -> &str {
        &self.pagesize
    }
    pub fn clear_pagesize(&mut self) {
        self.pagesize.clear();
    }

    // Param is passed by value, moved
    pub fn set_pagesize(&mut self, v: ::std::string::String) {
        self.pagesize = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagesize(&mut self) -> &mut ::std::string::String {
        &mut self.pagesize
    }

    // Take field
    pub fn take_pagesize(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pagesize, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HugetlbStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pagesize)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pagesize.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pagesize);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max != 0 {
            os.write_uint64(2, self.max)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        if !self.pagesize.is_empty() {
            os.write_string(4, &self.pagesize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HugetlbStat {
        HugetlbStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "usage",
                |m: &HugetlbStat| { &m.usage },
                |m: &mut HugetlbStat| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max",
                |m: &HugetlbStat| { &m.max },
                |m: &mut HugetlbStat| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "failcnt",
                |m: &HugetlbStat| { &m.failcnt },
                |m: &mut HugetlbStat| { &mut m.failcnt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pagesize",
                |m: &HugetlbStat| { &m.pagesize },
                |m: &mut HugetlbStat| { &mut m.pagesize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HugetlbStat>(
                "HugetlbStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HugetlbStat {
        static instance: ::protobuf::rt::LazyV2<HugetlbStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HugetlbStat::new)
    }
}

impl ::protobuf::Clear for HugetlbStat {
    fn clear(&mut self) {
        self.usage = 0;
        self.max = 0;
        self.failcnt = 0;
        self.pagesize.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HugetlbStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugetlbStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PidsStat {
    // message fields
    pub current: u64,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PidsStat {
    fn default() -> &'a PidsStat {
        <PidsStat as ::protobuf::Message>::default_instance()
    }
}

impl PidsStat {
    pub fn new() -> PidsStat {
        ::std::default::Default::default()
    }

    // uint64 current = 1;


    pub fn get_current(&self) -> u64 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PidsStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PidsStat {
        PidsStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "current",
                |m: &PidsStat| { &m.current },
                |m: &mut PidsStat| { &mut m.current },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "limit",
                |m: &PidsStat| { &m.limit },
                |m: &mut PidsStat| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PidsStat>(
                "PidsStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PidsStat {
        static instance: ::protobuf::rt::LazyV2<PidsStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PidsStat::new)
    }
}

impl ::protobuf::Clear for PidsStat {
    fn clear(&mut self) {
        self.current = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PidsStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPUStat {
    // message fields
    pub usage: ::protobuf::SingularPtrField<CPUUsage>,
    pub throttling: ::protobuf::SingularPtrField<Throttle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPUStat {
    fn default() -> &'a CPUStat {
        <CPUStat as ::protobuf::Message>::default_instance()
    }
}

impl CPUStat {
    pub fn new() -> CPUStat {
        ::std::default::Default::default()
    }

    // .io.containerd.cgroups.v1.CPUUsage usage = 1;


    pub fn get_usage(&self) -> &CPUUsage {
        self.usage.as_ref().unwrap_or_else(|| <CPUUsage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: CPUUsage) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut CPUUsage {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> CPUUsage {
        self.usage.take().unwrap_or_else(|| CPUUsage::new())
    }

    // .io.containerd.cgroups.v1.Throttle throttling = 2;


    pub fn get_throttling(&self) -> &Throttle {
        self.throttling.as_ref().unwrap_or_else(|| <Throttle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_throttling(&mut self) {
        self.throttling.clear();
    }

    pub fn has_throttling(&self) -> bool {
        self.throttling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling(&mut self, v: Throttle) {
        self.throttling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_throttling(&mut self) -> &mut Throttle {
        if self.throttling.is_none() {
            self.throttling.set_default();
        }
        self.throttling.as_mut().unwrap()
    }

    // Take field
    pub fn take_throttling(&mut self) -> Throttle {
        self.throttling.take().unwrap_or_else(|| Throttle::new())
    }
}

impl ::protobuf::Message for CPUStat {
    fn is_initialized(&self) -> bool {
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.throttling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.throttling)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.throttling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.throttling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPUStat {
        CPUStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPUUsage>>(
                "usage",
                |m: &CPUStat| { &m.usage },
                |m: &mut CPUStat| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Throttle>>(
                "throttling",
                |m: &CPUStat| { &m.throttling },
                |m: &mut CPUStat| { &mut m.throttling },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPUStat>(
                "CPUStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPUStat {
        static instance: ::protobuf::rt::LazyV2<CPUStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPUStat::new)
    }
}

impl ::protobuf::Clear for CPUStat {
    fn clear(&mut self) {
        self.usage.clear();
        self.throttling.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPUStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPUStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPUUsage {
    // message fields
    pub total: u64,
    pub kernel: u64,
    pub user: u64,
    pub per_cpu: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPUUsage {
    fn default() -> &'a CPUUsage {
        <CPUUsage as ::protobuf::Message>::default_instance()
    }
}

impl CPUUsage {
    pub fn new() -> CPUUsage {
        ::std::default::Default::default()
    }

    // uint64 total = 1;


    pub fn get_total(&self) -> u64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u64) {
        self.total = v;
    }

    // uint64 kernel = 2;


    pub fn get_kernel(&self) -> u64 {
        self.kernel
    }
    pub fn clear_kernel(&mut self) {
        self.kernel = 0;
    }

    // Param is passed by value, moved
    pub fn set_kernel(&mut self, v: u64) {
        self.kernel = v;
    }

    // uint64 user = 3;


    pub fn get_user(&self) -> u64 {
        self.user
    }
    pub fn clear_user(&mut self) {
        self.user = 0;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: u64) {
        self.user = v;
    }

    // repeated uint64 per_cpu = 4;


    pub fn get_per_cpu(&self) -> &[u64] {
        &self.per_cpu
    }
    pub fn clear_per_cpu(&mut self) {
        self.per_cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_per_cpu(&mut self, v: ::std::vec::Vec<u64>) {
        self.per_cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_per_cpu(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.per_cpu
    }

    // Take field
    pub fn take_per_cpu(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.per_cpu, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPUUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kernel = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.user = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.per_cpu)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.kernel != 0 {
            my_size += ::protobuf::rt::value_size(2, self.kernel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.user != 0 {
            my_size += ::protobuf::rt::value_size(3, self.user, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.per_cpu {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_uint64(1, self.total)?;
        }
        if self.kernel != 0 {
            os.write_uint64(2, self.kernel)?;
        }
        if self.user != 0 {
            os.write_uint64(3, self.user)?;
        }
        for v in &self.per_cpu {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPUUsage {
        CPUUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total",
                |m: &CPUUsage| { &m.total },
                |m: &mut CPUUsage| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "kernel",
                |m: &CPUUsage| { &m.kernel },
                |m: &mut CPUUsage| { &mut m.kernel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "user",
                |m: &CPUUsage| { &m.user },
                |m: &mut CPUUsage| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "per_cpu",
                |m: &CPUUsage| { &m.per_cpu },
                |m: &mut CPUUsage| { &mut m.per_cpu },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPUUsage>(
                "CPUUsage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPUUsage {
        static instance: ::protobuf::rt::LazyV2<CPUUsage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPUUsage::new)
    }
}

impl ::protobuf::Clear for CPUUsage {
    fn clear(&mut self) {
        self.total = 0;
        self.kernel = 0;
        self.user = 0;
        self.per_cpu.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPUUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPUUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Throttle {
    // message fields
    pub periods: u64,
    pub throttled_periods: u64,
    pub throttled_time: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Throttle {
    fn default() -> &'a Throttle {
        <Throttle as ::protobuf::Message>::default_instance()
    }
}

impl Throttle {
    pub fn new() -> Throttle {
        ::std::default::Default::default()
    }

    // uint64 periods = 1;


    pub fn get_periods(&self) -> u64 {
        self.periods
    }
    pub fn clear_periods(&mut self) {
        self.periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_periods(&mut self, v: u64) {
        self.periods = v;
    }

    // uint64 throttled_periods = 2;


    pub fn get_throttled_periods(&self) -> u64 {
        self.throttled_periods
    }
    pub fn clear_throttled_periods(&mut self) {
        self.throttled_periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_periods(&mut self, v: u64) {
        self.throttled_periods = v;
    }

    // uint64 throttled_time = 3;


    pub fn get_throttled_time(&self) -> u64 {
        self.throttled_time
    }
    pub fn clear_throttled_time(&mut self) {
        self.throttled_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_time(&mut self, v: u64) {
        self.throttled_time = v;
    }
}

impl ::protobuf::Message for Throttle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.periods = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_periods = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttled_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.periods != 0 {
            my_size += ::protobuf::rt::value_size(1, self.periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_periods != 0 {
            my_size += ::protobuf::rt::value_size(2, self.throttled_periods, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttled_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.throttled_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.periods != 0 {
            os.write_uint64(1, self.periods)?;
        }
        if self.throttled_periods != 0 {
            os.write_uint64(2, self.throttled_periods)?;
        }
        if self.throttled_time != 0 {
            os.write_uint64(3, self.throttled_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Throttle {
        Throttle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "periods",
                |m: &Throttle| { &m.periods },
                |m: &mut Throttle| { &mut m.periods },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "throttled_periods",
                |m: &Throttle| { &m.throttled_periods },
                |m: &mut Throttle| { &mut m.throttled_periods },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "throttled_time",
                |m: &Throttle| { &m.throttled_time },
                |m: &mut Throttle| { &mut m.throttled_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Throttle>(
                "Throttle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Throttle {
        static instance: ::protobuf::rt::LazyV2<Throttle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Throttle::new)
    }
}

impl ::protobuf::Clear for Throttle {
    fn clear(&mut self) {
        self.periods = 0;
        self.throttled_periods = 0;
        self.throttled_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Throttle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Throttle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryStat {
    // message fields
    pub cache: u64,
    pub rss: u64,
    pub rss_huge: u64,
    pub mapped_file: u64,
    pub dirty: u64,
    pub writeback: u64,
    pub pg_pg_in: u64,
    pub pg_pg_out: u64,
    pub pg_fault: u64,
    pub pg_maj_fault: u64,
    pub inactive_anon: u64,
    pub active_anon: u64,
    pub inactive_file: u64,
    pub active_file: u64,
    pub unevictable: u64,
    pub hierarchical_memory_limit: u64,
    pub hierarchical_swap_limit: u64,
    pub total_cache: u64,
    pub total_rss: u64,
    pub total_rss_huge: u64,
    pub total_mapped_file: u64,
    pub total_dirty: u64,
    pub total_writeback: u64,
    pub total_pg_pg_in: u64,
    pub total_pg_pg_out: u64,
    pub total_pg_fault: u64,
    pub total_pg_maj_fault: u64,
    pub total_inactive_anon: u64,
    pub total_active_anon: u64,
    pub total_inactive_file: u64,
    pub total_active_file: u64,
    pub total_unevictable: u64,
    pub usage: ::protobuf::SingularPtrField<MemoryEntry>,
    pub swap: ::protobuf::SingularPtrField<MemoryEntry>,
    pub kernel: ::protobuf::SingularPtrField<MemoryEntry>,
    pub kernel_tcp: ::protobuf::SingularPtrField<MemoryEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryStat {
    fn default() -> &'a MemoryStat {
        <MemoryStat as ::protobuf::Message>::default_instance()
    }
}

impl MemoryStat {
    pub fn new() -> MemoryStat {
        ::std::default::Default::default()
    }

    // uint64 cache = 1;


    pub fn get_cache(&self) -> u64 {
        self.cache
    }
    pub fn clear_cache(&mut self) {
        self.cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: u64) {
        self.cache = v;
    }

    // uint64 rss = 2;


    pub fn get_rss(&self) -> u64 {
        self.rss
    }
    pub fn clear_rss(&mut self) {
        self.rss = 0;
    }

    // Param is passed by value, moved
    pub fn set_rss(&mut self, v: u64) {
        self.rss = v;
    }

    // uint64 rss_huge = 3;


    pub fn get_rss_huge(&self) -> u64 {
        self.rss_huge
    }
    pub fn clear_rss_huge(&mut self) {
        self.rss_huge = 0;
    }

    // Param is passed by value, moved
    pub fn set_rss_huge(&mut self, v: u64) {
        self.rss_huge = v;
    }

    // uint64 mapped_file = 4;


    pub fn get_mapped_file(&self) -> u64 {
        self.mapped_file
    }
    pub fn clear_mapped_file(&mut self) {
        self.mapped_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_mapped_file(&mut self, v: u64) {
        self.mapped_file = v;
    }

    // uint64 dirty = 5;


    pub fn get_dirty(&self) -> u64 {
        self.dirty
    }
    pub fn clear_dirty(&mut self) {
        self.dirty = 0;
    }

    // Param is passed by value, moved
    pub fn set_dirty(&mut self, v: u64) {
        self.dirty = v;
    }

    // uint64 writeback = 6;


    pub fn get_writeback(&self) -> u64 {
        self.writeback
    }
    pub fn clear_writeback(&mut self) {
        self.writeback = 0;
    }

    // Param is passed by value, moved
    pub fn set_writeback(&mut self, v: u64) {
        self.writeback = v;
    }

    // uint64 pg_pg_in = 7;


    pub fn get_pg_pg_in(&self) -> u64 {
        self.pg_pg_in
    }
    pub fn clear_pg_pg_in(&mut self) {
        self.pg_pg_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_pg_in(&mut self, v: u64) {
        self.pg_pg_in = v;
    }

    // uint64 pg_pg_out = 8;


    pub fn get_pg_pg_out(&self) -> u64 {
        self.pg_pg_out
    }
    pub fn clear_pg_pg_out(&mut self) {
        self.pg_pg_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_pg_out(&mut self, v: u64) {
        self.pg_pg_out = v;
    }

    // uint64 pg_fault = 9;


    pub fn get_pg_fault(&self) -> u64 {
        self.pg_fault
    }
    pub fn clear_pg_fault(&mut self) {
        self.pg_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_fault(&mut self, v: u64) {
        self.pg_fault = v;
    }

    // uint64 pg_maj_fault = 10;


    pub fn get_pg_maj_fault(&self) -> u64 {
        self.pg_maj_fault
    }
    pub fn clear_pg_maj_fault(&mut self) {
        self.pg_maj_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_maj_fault(&mut self, v: u64) {
        self.pg_maj_fault = v;
    }

    // uint64 inactive_anon = 11;


    pub fn get_inactive_anon(&self) -> u64 {
        self.inactive_anon
    }
    pub fn clear_inactive_anon(&mut self) {
        self.inactive_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_inactive_anon(&mut self, v: u64) {
        self.inactive_anon = v;
    }

    // uint64 active_anon = 12;


    pub fn get_active_anon(&self) -> u64 {
        self.active_anon
    }
    pub fn clear_active_anon(&mut self) {
        self.active_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_anon(&mut self, v: u64) {
        self.active_anon = v;
    }

    // uint64 inactive_file = 13;


    pub fn get_inactive_file(&self) -> u64 {
        self.inactive_file
    }
    pub fn clear_inactive_file(&mut self) {
        self.inactive_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_inactive_file(&mut self, v: u64) {
        self.inactive_file = v;
    }

    // uint64 active_file = 14;


    pub fn get_active_file(&self) -> u64 {
        self.active_file
    }
    pub fn clear_active_file(&mut self) {
        self.active_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_file(&mut self, v: u64) {
        self.active_file = v;
    }

    // uint64 unevictable = 15;


    pub fn get_unevictable(&self) -> u64 {
        self.unevictable
    }
    pub fn clear_unevictable(&mut self) {
        self.unevictable = 0;
    }

    // Param is passed by value, moved
    pub fn set_unevictable(&mut self, v: u64) {
        self.unevictable = v;
    }

    // uint64 hierarchical_memory_limit = 16;


    pub fn get_hierarchical_memory_limit(&self) -> u64 {
        self.hierarchical_memory_limit
    }
    pub fn clear_hierarchical_memory_limit(&mut self) {
        self.hierarchical_memory_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_memory_limit(&mut self, v: u64) {
        self.hierarchical_memory_limit = v;
    }

    // uint64 hierarchical_swap_limit = 17;


    pub fn get_hierarchical_swap_limit(&self) -> u64 {
        self.hierarchical_swap_limit
    }
    pub fn clear_hierarchical_swap_limit(&mut self) {
        self.hierarchical_swap_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_swap_limit(&mut self, v: u64) {
        self.hierarchical_swap_limit = v;
    }

    // uint64 total_cache = 18;


    pub fn get_total_cache(&self) -> u64 {
        self.total_cache
    }
    pub fn clear_total_cache(&mut self) {
        self.total_cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_cache(&mut self, v: u64) {
        self.total_cache = v;
    }

    // uint64 total_rss = 19;


    pub fn get_total_rss(&self) -> u64 {
        self.total_rss
    }
    pub fn clear_total_rss(&mut self) {
        self.total_rss = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rss(&mut self, v: u64) {
        self.total_rss = v;
    }

    // uint64 total_rss_huge = 20;


    pub fn get_total_rss_huge(&self) -> u64 {
        self.total_rss_huge
    }
    pub fn clear_total_rss_huge(&mut self) {
        self.total_rss_huge = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rss_huge(&mut self, v: u64) {
        self.total_rss_huge = v;
    }

    // uint64 total_mapped_file = 21;


    pub fn get_total_mapped_file(&self) -> u64 {
        self.total_mapped_file
    }
    pub fn clear_total_mapped_file(&mut self) {
        self.total_mapped_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_mapped_file(&mut self, v: u64) {
        self.total_mapped_file = v;
    }

    // uint64 total_dirty = 22;


    pub fn get_total_dirty(&self) -> u64 {
        self.total_dirty
    }
    pub fn clear_total_dirty(&mut self) {
        self.total_dirty = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_dirty(&mut self, v: u64) {
        self.total_dirty = v;
    }

    // uint64 total_writeback = 23;


    pub fn get_total_writeback(&self) -> u64 {
        self.total_writeback
    }
    pub fn clear_total_writeback(&mut self) {
        self.total_writeback = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_writeback(&mut self, v: u64) {
        self.total_writeback = v;
    }

    // uint64 total_pg_pg_in = 24;


    pub fn get_total_pg_pg_in(&self) -> u64 {
        self.total_pg_pg_in
    }
    pub fn clear_total_pg_pg_in(&mut self) {
        self.total_pg_pg_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_pg_in(&mut self, v: u64) {
        self.total_pg_pg_in = v;
    }

    // uint64 total_pg_pg_out = 25;


    pub fn get_total_pg_pg_out(&self) -> u64 {
        self.total_pg_pg_out
    }
    pub fn clear_total_pg_pg_out(&mut self) {
        self.total_pg_pg_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_pg_out(&mut self, v: u64) {
        self.total_pg_pg_out = v;
    }

    // uint64 total_pg_fault = 26;


    pub fn get_total_pg_fault(&self) -> u64 {
        self.total_pg_fault
    }
    pub fn clear_total_pg_fault(&mut self) {
        self.total_pg_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_fault(&mut self, v: u64) {
        self.total_pg_fault = v;
    }

    // uint64 total_pg_maj_fault = 27;


    pub fn get_total_pg_maj_fault(&self) -> u64 {
        self.total_pg_maj_fault
    }
    pub fn clear_total_pg_maj_fault(&mut self) {
        self.total_pg_maj_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_maj_fault(&mut self, v: u64) {
        self.total_pg_maj_fault = v;
    }

    // uint64 total_inactive_anon = 28;


    pub fn get_total_inactive_anon(&self) -> u64 {
        self.total_inactive_anon
    }
    pub fn clear_total_inactive_anon(&mut self) {
        self.total_inactive_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_inactive_anon(&mut self, v: u64) {
        self.total_inactive_anon = v;
    }

    // uint64 total_active_anon = 29;


    pub fn get_total_active_anon(&self) -> u64 {
        self.total_active_anon
    }
    pub fn clear_total_active_anon(&mut self) {
        self.total_active_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_active_anon(&mut self, v: u64) {
        self.total_active_anon = v;
    }

    // uint64 total_inactive_file = 30;


    pub fn get_total_inactive_file(&self) -> u64 {
        self.total_inactive_file
    }
    pub fn clear_total_inactive_file(&mut self) {
        self.total_inactive_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_inactive_file(&mut self, v: u64) {
        self.total_inactive_file = v;
    }

    // uint64 total_active_file = 31;


    pub fn get_total_active_file(&self) -> u64 {
        self.total_active_file
    }
    pub fn clear_total_active_file(&mut self) {
        self.total_active_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_active_file(&mut self, v: u64) {
        self.total_active_file = v;
    }

    // uint64 total_unevictable = 32;


    pub fn get_total_unevictable(&self) -> u64 {
        self.total_unevictable
    }
    pub fn clear_total_unevictable(&mut self) {
        self.total_unevictable = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_unevictable(&mut self, v: u64) {
        self.total_unevictable = v;
    }

    // .io.containerd.cgroups.v1.MemoryEntry usage = 33;


    pub fn get_usage(&self) -> &MemoryEntry {
        self.usage.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: MemoryEntry) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut MemoryEntry {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> MemoryEntry {
        self.usage.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry swap = 34;


    pub fn get_swap(&self) -> &MemoryEntry {
        self.swap.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_swap(&mut self) {
        self.swap.clear();
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: MemoryEntry) {
        self.swap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap(&mut self) -> &mut MemoryEntry {
        if self.swap.is_none() {
            self.swap.set_default();
        }
        self.swap.as_mut().unwrap()
    }

    // Take field
    pub fn take_swap(&mut self) -> MemoryEntry {
        self.swap.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry kernel = 35;


    pub fn get_kernel(&self) -> &MemoryEntry {
        self.kernel.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kernel(&mut self) {
        self.kernel.clear();
    }

    pub fn has_kernel(&self) -> bool {
        self.kernel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel(&mut self, v: MemoryEntry) {
        self.kernel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel(&mut self) -> &mut MemoryEntry {
        if self.kernel.is_none() {
            self.kernel.set_default();
        }
        self.kernel.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel(&mut self) -> MemoryEntry {
        self.kernel.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry kernel_tcp = 36;


    pub fn get_kernel_tcp(&self) -> &MemoryEntry {
        self.kernel_tcp.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kernel_tcp(&mut self) {
        self.kernel_tcp.clear();
    }

    pub fn has_kernel_tcp(&self) -> bool {
        self.kernel_tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_tcp(&mut self, v: MemoryEntry) {
        self.kernel_tcp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_tcp(&mut self) -> &mut MemoryEntry {
        if self.kernel_tcp.is_none() {
            self.kernel_tcp.set_default();
        }
        self.kernel_tcp.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel_tcp(&mut self) -> MemoryEntry {
        self.kernel_tcp.take().unwrap_or_else(|| MemoryEntry::new())
    }
}

impl ::protobuf::Message for MemoryStat {
    fn is_initialized(&self) -> bool {
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.swap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kernel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kernel_tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cache = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rss = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rss_huge = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mapped_file = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dirty = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.writeback = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pg_pg_in = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pg_pg_out = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pg_fault = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pg_maj_fault = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inactive_anon = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.active_anon = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inactive_file = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.active_file = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unevictable = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hierarchical_memory_limit = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hierarchical_swap_limit = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_cache = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_rss = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_rss_huge = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_mapped_file = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_dirty = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_writeback = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_pg_pg_in = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_pg_pg_out = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_pg_fault = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_pg_maj_fault = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_inactive_anon = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_active_anon = tmp;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_inactive_file = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_active_file = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_unevictable = tmp;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.swap)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kernel)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kernel_tcp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cache != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cache, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rss != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rss, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rss_huge != 0 {
            my_size += ::protobuf::rt::value_size(3, self.rss_huge, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mapped_file != 0 {
            my_size += ::protobuf::rt::value_size(4, self.mapped_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dirty != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dirty, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.writeback != 0 {
            my_size += ::protobuf::rt::value_size(6, self.writeback, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pg_pg_in != 0 {
            my_size += ::protobuf::rt::value_size(7, self.pg_pg_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pg_pg_out != 0 {
            my_size += ::protobuf::rt::value_size(8, self.pg_pg_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pg_fault != 0 {
            my_size += ::protobuf::rt::value_size(9, self.pg_fault, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pg_maj_fault != 0 {
            my_size += ::protobuf::rt::value_size(10, self.pg_maj_fault, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inactive_anon != 0 {
            my_size += ::protobuf::rt::value_size(11, self.inactive_anon, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.active_anon != 0 {
            my_size += ::protobuf::rt::value_size(12, self.active_anon, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inactive_file != 0 {
            my_size += ::protobuf::rt::value_size(13, self.inactive_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.active_file != 0 {
            my_size += ::protobuf::rt::value_size(14, self.active_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unevictable != 0 {
            my_size += ::protobuf::rt::value_size(15, self.unevictable, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hierarchical_memory_limit != 0 {
            my_size += ::protobuf::rt::value_size(16, self.hierarchical_memory_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hierarchical_swap_limit != 0 {
            my_size += ::protobuf::rt::value_size(17, self.hierarchical_swap_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_cache != 0 {
            my_size += ::protobuf::rt::value_size(18, self.total_cache, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_rss != 0 {
            my_size += ::protobuf::rt::value_size(19, self.total_rss, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_rss_huge != 0 {
            my_size += ::protobuf::rt::value_size(20, self.total_rss_huge, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_mapped_file != 0 {
            my_size += ::protobuf::rt::value_size(21, self.total_mapped_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_dirty != 0 {
            my_size += ::protobuf::rt::value_size(22, self.total_dirty, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_writeback != 0 {
            my_size += ::protobuf::rt::value_size(23, self.total_writeback, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_pg_pg_in != 0 {
            my_size += ::protobuf::rt::value_size(24, self.total_pg_pg_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_pg_pg_out != 0 {
            my_size += ::protobuf::rt::value_size(25, self.total_pg_pg_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_pg_fault != 0 {
            my_size += ::protobuf::rt::value_size(26, self.total_pg_fault, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_pg_maj_fault != 0 {
            my_size += ::protobuf::rt::value_size(27, self.total_pg_maj_fault, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_inactive_anon != 0 {
            my_size += ::protobuf::rt::value_size(28, self.total_inactive_anon, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_active_anon != 0 {
            my_size += ::protobuf::rt::value_size(29, self.total_active_anon, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_inactive_file != 0 {
            my_size += ::protobuf::rt::value_size(30, self.total_inactive_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_active_file != 0 {
            my_size += ::protobuf::rt::value_size(31, self.total_active_file, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_unevictable != 0 {
            my_size += ::protobuf::rt::value_size(32, self.total_unevictable, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.swap.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kernel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kernel_tcp.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cache != 0 {
            os.write_uint64(1, self.cache)?;
        }
        if self.rss != 0 {
            os.write_uint64(2, self.rss)?;
        }
        if self.rss_huge != 0 {
            os.write_uint64(3, self.rss_huge)?;
        }
        if self.mapped_file != 0 {
            os.write_uint64(4, self.mapped_file)?;
        }
        if self.dirty != 0 {
            os.write_uint64(5, self.dirty)?;
        }
        if self.writeback != 0 {
            os.write_uint64(6, self.writeback)?;
        }
        if self.pg_pg_in != 0 {
            os.write_uint64(7, self.pg_pg_in)?;
        }
        if self.pg_pg_out != 0 {
            os.write_uint64(8, self.pg_pg_out)?;
        }
        if self.pg_fault != 0 {
            os.write_uint64(9, self.pg_fault)?;
        }
        if self.pg_maj_fault != 0 {
            os.write_uint64(10, self.pg_maj_fault)?;
        }
        if self.inactive_anon != 0 {
            os.write_uint64(11, self.inactive_anon)?;
        }
        if self.active_anon != 0 {
            os.write_uint64(12, self.active_anon)?;
        }
        if self.inactive_file != 0 {
            os.write_uint64(13, self.inactive_file)?;
        }
        if self.active_file != 0 {
            os.write_uint64(14, self.active_file)?;
        }
        if self.unevictable != 0 {
            os.write_uint64(15, self.unevictable)?;
        }
        if self.hierarchical_memory_limit != 0 {
            os.write_uint64(16, self.hierarchical_memory_limit)?;
        }
        if self.hierarchical_swap_limit != 0 {
            os.write_uint64(17, self.hierarchical_swap_limit)?;
        }
        if self.total_cache != 0 {
            os.write_uint64(18, self.total_cache)?;
        }
        if self.total_rss != 0 {
            os.write_uint64(19, self.total_rss)?;
        }
        if self.total_rss_huge != 0 {
            os.write_uint64(20, self.total_rss_huge)?;
        }
        if self.total_mapped_file != 0 {
            os.write_uint64(21, self.total_mapped_file)?;
        }
        if self.total_dirty != 0 {
            os.write_uint64(22, self.total_dirty)?;
        }
        if self.total_writeback != 0 {
            os.write_uint64(23, self.total_writeback)?;
        }
        if self.total_pg_pg_in != 0 {
            os.write_uint64(24, self.total_pg_pg_in)?;
        }
        if self.total_pg_pg_out != 0 {
            os.write_uint64(25, self.total_pg_pg_out)?;
        }
        if self.total_pg_fault != 0 {
            os.write_uint64(26, self.total_pg_fault)?;
        }
        if self.total_pg_maj_fault != 0 {
            os.write_uint64(27, self.total_pg_maj_fault)?;
        }
        if self.total_inactive_anon != 0 {
            os.write_uint64(28, self.total_inactive_anon)?;
        }
        if self.total_active_anon != 0 {
            os.write_uint64(29, self.total_active_anon)?;
        }
        if self.total_inactive_file != 0 {
            os.write_uint64(30, self.total_inactive_file)?;
        }
        if self.total_active_file != 0 {
            os.write_uint64(31, self.total_active_file)?;
        }
        if self.total_unevictable != 0 {
            os.write_uint64(32, self.total_unevictable)?;
        }
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.swap.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kernel.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kernel_tcp.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryStat {
        MemoryStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cache",
                |m: &MemoryStat| { &m.cache },
                |m: &mut MemoryStat| { &mut m.cache },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rss",
                |m: &MemoryStat| { &m.rss },
                |m: &mut MemoryStat| { &mut m.rss },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rss_huge",
                |m: &MemoryStat| { &m.rss_huge },
                |m: &mut MemoryStat| { &mut m.rss_huge },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "mapped_file",
                |m: &MemoryStat| { &m.mapped_file },
                |m: &mut MemoryStat| { &mut m.mapped_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dirty",
                |m: &MemoryStat| { &m.dirty },
                |m: &mut MemoryStat| { &mut m.dirty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "writeback",
                |m: &MemoryStat| { &m.writeback },
                |m: &mut MemoryStat| { &mut m.writeback },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pg_pg_in",
                |m: &MemoryStat| { &m.pg_pg_in },
                |m: &mut MemoryStat| { &mut m.pg_pg_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pg_pg_out",
                |m: &MemoryStat| { &m.pg_pg_out },
                |m: &mut MemoryStat| { &mut m.pg_pg_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pg_fault",
                |m: &MemoryStat| { &m.pg_fault },
                |m: &mut MemoryStat| { &mut m.pg_fault },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pg_maj_fault",
                |m: &MemoryStat| { &m.pg_maj_fault },
                |m: &mut MemoryStat| { &mut m.pg_maj_fault },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "inactive_anon",
                |m: &MemoryStat| { &m.inactive_anon },
                |m: &mut MemoryStat| { &mut m.inactive_anon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "active_anon",
                |m: &MemoryStat| { &m.active_anon },
                |m: &mut MemoryStat| { &mut m.active_anon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "inactive_file",
                |m: &MemoryStat| { &m.inactive_file },
                |m: &mut MemoryStat| { &mut m.inactive_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "active_file",
                |m: &MemoryStat| { &m.active_file },
                |m: &mut MemoryStat| { &mut m.active_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unevictable",
                |m: &MemoryStat| { &m.unevictable },
                |m: &mut MemoryStat| { &mut m.unevictable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "hierarchical_memory_limit",
                |m: &MemoryStat| { &m.hierarchical_memory_limit },
                |m: &mut MemoryStat| { &mut m.hierarchical_memory_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "hierarchical_swap_limit",
                |m: &MemoryStat| { &m.hierarchical_swap_limit },
                |m: &mut MemoryStat| { &mut m.hierarchical_swap_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_cache",
                |m: &MemoryStat| { &m.total_cache },
                |m: &mut MemoryStat| { &mut m.total_cache },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_rss",
                |m: &MemoryStat| { &m.total_rss },
                |m: &mut MemoryStat| { &mut m.total_rss },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_rss_huge",
                |m: &MemoryStat| { &m.total_rss_huge },
                |m: &mut MemoryStat| { &mut m.total_rss_huge },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_mapped_file",
                |m: &MemoryStat| { &m.total_mapped_file },
                |m: &mut MemoryStat| { &mut m.total_mapped_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_dirty",
                |m: &MemoryStat| { &m.total_dirty },
                |m: &mut MemoryStat| { &mut m.total_dirty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_writeback",
                |m: &MemoryStat| { &m.total_writeback },
                |m: &mut MemoryStat| { &mut m.total_writeback },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_pg_pg_in",
                |m: &MemoryStat| { &m.total_pg_pg_in },
                |m: &mut MemoryStat| { &mut m.total_pg_pg_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_pg_pg_out",
                |m: &MemoryStat| { &m.total_pg_pg_out },
                |m: &mut MemoryStat| { &mut m.total_pg_pg_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_pg_fault",
                |m: &MemoryStat| { &m.total_pg_fault },
                |m: &mut MemoryStat| { &mut m.total_pg_fault },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_pg_maj_fault",
                |m: &MemoryStat| { &m.total_pg_maj_fault },
                |m: &mut MemoryStat| { &mut m.total_pg_maj_fault },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_inactive_anon",
                |m: &MemoryStat| { &m.total_inactive_anon },
                |m: &mut MemoryStat| { &mut m.total_inactive_anon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_active_anon",
                |m: &MemoryStat| { &m.total_active_anon },
                |m: &mut MemoryStat| { &mut m.total_active_anon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_inactive_file",
                |m: &MemoryStat| { &m.total_inactive_file },
                |m: &mut MemoryStat| { &mut m.total_inactive_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_active_file",
                |m: &MemoryStat| { &m.total_active_file },
                |m: &mut MemoryStat| { &mut m.total_active_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_unevictable",
                |m: &MemoryStat| { &m.total_unevictable },
                |m: &mut MemoryStat| { &mut m.total_unevictable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryEntry>>(
                "usage",
                |m: &MemoryStat| { &m.usage },
                |m: &mut MemoryStat| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryEntry>>(
                "swap",
                |m: &MemoryStat| { &m.swap },
                |m: &mut MemoryStat| { &mut m.swap },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryEntry>>(
                "kernel",
                |m: &MemoryStat| { &m.kernel },
                |m: &mut MemoryStat| { &mut m.kernel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryEntry>>(
                "kernel_tcp",
                |m: &MemoryStat| { &m.kernel_tcp },
                |m: &mut MemoryStat| { &mut m.kernel_tcp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryStat>(
                "MemoryStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemoryStat {
        static instance: ::protobuf::rt::LazyV2<MemoryStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemoryStat::new)
    }
}

impl ::protobuf::Clear for MemoryStat {
    fn clear(&mut self) {
        self.cache = 0;
        self.rss = 0;
        self.rss_huge = 0;
        self.mapped_file = 0;
        self.dirty = 0;
        self.writeback = 0;
        self.pg_pg_in = 0;
        self.pg_pg_out = 0;
        self.pg_fault = 0;
        self.pg_maj_fault = 0;
        self.inactive_anon = 0;
        self.active_anon = 0;
        self.inactive_file = 0;
        self.active_file = 0;
        self.unevictable = 0;
        self.hierarchical_memory_limit = 0;
        self.hierarchical_swap_limit = 0;
        self.total_cache = 0;
        self.total_rss = 0;
        self.total_rss_huge = 0;
        self.total_mapped_file = 0;
        self.total_dirty = 0;
        self.total_writeback = 0;
        self.total_pg_pg_in = 0;
        self.total_pg_pg_out = 0;
        self.total_pg_fault = 0;
        self.total_pg_maj_fault = 0;
        self.total_inactive_anon = 0;
        self.total_active_anon = 0;
        self.total_inactive_file = 0;
        self.total_active_file = 0;
        self.total_unevictable = 0;
        self.usage.clear();
        self.swap.clear();
        self.kernel.clear();
        self.kernel_tcp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryEntry {
    // message fields
    pub limit: u64,
    pub usage: u64,
    pub max: u64,
    pub failcnt: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryEntry {
    fn default() -> &'a MemoryEntry {
        <MemoryEntry as ::protobuf::Message>::default_instance()
    }
}

impl MemoryEntry {
    pub fn new() -> MemoryEntry {
        ::std::default::Default::default()
    }

    // uint64 limit = 1;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // uint64 usage = 2;


    pub fn get_usage(&self) -> u64 {
        self.usage
    }
    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max = 3;


    pub fn get_max(&self) -> u64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u64) {
        self.max = v;
    }

    // uint64 failcnt = 4;


    pub fn get_failcnt(&self) -> u64 {
        self.failcnt
    }
    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }
}

impl ::protobuf::Message for MemoryEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failcnt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.failcnt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_uint64(1, self.limit)?;
        }
        if self.usage != 0 {
            os.write_uint64(2, self.usage)?;
        }
        if self.max != 0 {
            os.write_uint64(3, self.max)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(4, self.failcnt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryEntry {
        MemoryEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "limit",
                |m: &MemoryEntry| { &m.limit },
                |m: &mut MemoryEntry| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "usage",
                |m: &MemoryEntry| { &m.usage },
                |m: &mut MemoryEntry| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max",
                |m: &MemoryEntry| { &m.max },
                |m: &mut MemoryEntry| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "failcnt",
                |m: &MemoryEntry| { &m.failcnt },
                |m: &mut MemoryEntry| { &mut m.failcnt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryEntry>(
                "MemoryEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemoryEntry {
        static instance: ::protobuf::rt::LazyV2<MemoryEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemoryEntry::new)
    }
}

impl ::protobuf::Clear for MemoryEntry {
    fn clear(&mut self) {
        self.limit = 0;
        self.usage = 0;
        self.max = 0;
        self.failcnt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryOomControl {
    // message fields
    pub oom_kill_disable: u64,
    pub under_oom: u64,
    pub oom_kill: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryOomControl {
    fn default() -> &'a MemoryOomControl {
        <MemoryOomControl as ::protobuf::Message>::default_instance()
    }
}

impl MemoryOomControl {
    pub fn new() -> MemoryOomControl {
        ::std::default::Default::default()
    }

    // uint64 oom_kill_disable = 1;


    pub fn get_oom_kill_disable(&self) -> u64 {
        self.oom_kill_disable
    }
    pub fn clear_oom_kill_disable(&mut self) {
        self.oom_kill_disable = 0;
    }

    // Param is passed by value, moved
    pub fn set_oom_kill_disable(&mut self, v: u64) {
        self.oom_kill_disable = v;
    }

    // uint64 under_oom = 2;


    pub fn get_under_oom(&self) -> u64 {
        self.under_oom
    }
    pub fn clear_under_oom(&mut self) {
        self.under_oom = 0;
    }

    // Param is passed by value, moved
    pub fn set_under_oom(&mut self, v: u64) {
        self.under_oom = v;
    }

    // uint64 oom_kill = 3;


    pub fn get_oom_kill(&self) -> u64 {
        self.oom_kill
    }
    pub fn clear_oom_kill(&mut self) {
        self.oom_kill = 0;
    }

    // Param is passed by value, moved
    pub fn set_oom_kill(&mut self, v: u64) {
        self.oom_kill = v;
    }
}

impl ::protobuf::Message for MemoryOomControl {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.oom_kill_disable = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.under_oom = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.oom_kill = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.oom_kill_disable != 0 {
            my_size += ::protobuf::rt::value_size(1, self.oom_kill_disable, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.under_oom != 0 {
            my_size += ::protobuf::rt::value_size(2, self.under_oom, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oom_kill != 0 {
            my_size += ::protobuf::rt::value_size(3, self.oom_kill, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.oom_kill_disable != 0 {
            os.write_uint64(1, self.oom_kill_disable)?;
        }
        if self.under_oom != 0 {
            os.write_uint64(2, self.under_oom)?;
        }
        if self.oom_kill != 0 {
            os.write_uint64(3, self.oom_kill)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryOomControl {
        MemoryOomControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "oom_kill_disable",
                |m: &MemoryOomControl| { &m.oom_kill_disable },
                |m: &mut MemoryOomControl| { &mut m.oom_kill_disable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "under_oom",
                |m: &MemoryOomControl| { &m.under_oom },
                |m: &mut MemoryOomControl| { &mut m.under_oom },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "oom_kill",
                |m: &MemoryOomControl| { &m.oom_kill },
                |m: &mut MemoryOomControl| { &mut m.oom_kill },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryOomControl>(
                "MemoryOomControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemoryOomControl {
        static instance: ::protobuf::rt::LazyV2<MemoryOomControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemoryOomControl::new)
    }
}

impl ::protobuf::Clear for MemoryOomControl {
    fn clear(&mut self) {
        self.oom_kill_disable = 0;
        self.under_oom = 0;
        self.oom_kill = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryOomControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryOomControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkIOStat {
    // message fields
    pub io_service_bytes_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_serviced_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_queued_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_service_time_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_wait_time_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_merged_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub io_time_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    pub sectors_recursive: ::protobuf::RepeatedField<BlkIOEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkIOStat {
    fn default() -> &'a BlkIOStat {
        <BlkIOStat as ::protobuf::Message>::default_instance()
    }
}

impl BlkIOStat {
    pub fn new() -> BlkIOStat {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_service_bytes_recursive = 1;


    pub fn get_io_service_bytes_recursive(&self) -> &[BlkIOEntry] {
        &self.io_service_bytes_recursive
    }
    pub fn clear_io_service_bytes_recursive(&mut self) {
        self.io_service_bytes_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_service_bytes_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_service_bytes_recursive
    }

    // Take field
    pub fn take_io_service_bytes_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_service_bytes_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_serviced_recursive = 2;


    pub fn get_io_serviced_recursive(&self) -> &[BlkIOEntry] {
        &self.io_serviced_recursive
    }
    pub fn clear_io_serviced_recursive(&mut self) {
        self.io_serviced_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_serviced_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_serviced_recursive
    }

    // Take field
    pub fn take_io_serviced_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_serviced_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_queued_recursive = 3;


    pub fn get_io_queued_recursive(&self) -> &[BlkIOEntry] {
        &self.io_queued_recursive
    }
    pub fn clear_io_queued_recursive(&mut self) {
        self.io_queued_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_queued_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_queued_recursive
    }

    // Take field
    pub fn take_io_queued_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_queued_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_service_time_recursive = 4;


    pub fn get_io_service_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_service_time_recursive
    }
    pub fn clear_io_service_time_recursive(&mut self) {
        self.io_service_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_service_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_service_time_recursive
    }

    // Take field
    pub fn take_io_service_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_service_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_wait_time_recursive = 5;


    pub fn get_io_wait_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_wait_time_recursive
    }
    pub fn clear_io_wait_time_recursive(&mut self) {
        self.io_wait_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_wait_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_wait_time_recursive
    }

    // Take field
    pub fn take_io_wait_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_wait_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_merged_recursive = 6;


    pub fn get_io_merged_recursive(&self) -> &[BlkIOEntry] {
        &self.io_merged_recursive
    }
    pub fn clear_io_merged_recursive(&mut self) {
        self.io_merged_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_merged_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_merged_recursive
    }

    // Take field
    pub fn take_io_merged_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_merged_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_time_recursive = 7;


    pub fn get_io_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_time_recursive
    }
    pub fn clear_io_time_recursive(&mut self) {
        self.io_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_time_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.io_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_time_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.io_time_recursive
    }

    // Take field
    pub fn take_io_time_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_time_recursive, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry sectors_recursive = 8;


    pub fn get_sectors_recursive(&self) -> &[BlkIOEntry] {
        &self.sectors_recursive
    }
    pub fn clear_sectors_recursive(&mut self) {
        self.sectors_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_sectors_recursive(&mut self, v: ::protobuf::RepeatedField<BlkIOEntry>) {
        self.sectors_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sectors_recursive(&mut self) -> &mut ::protobuf::RepeatedField<BlkIOEntry> {
        &mut self.sectors_recursive
    }

    // Take field
    pub fn take_sectors_recursive(&mut self) -> ::protobuf::RepeatedField<BlkIOEntry> {
        ::std::mem::replace(&mut self.sectors_recursive, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlkIOStat {
    fn is_initialized(&self) -> bool {
        for v in &self.io_service_bytes_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_serviced_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_queued_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_service_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_wait_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_merged_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.io_time_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectors_recursive {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_bytes_recursive)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_serviced_recursive)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_queued_recursive)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_service_time_recursive)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_wait_time_recursive)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_merged_recursive)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.io_time_recursive)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sectors_recursive)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.io_service_bytes_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_serviced_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_queued_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_service_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_wait_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_merged_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.io_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sectors_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.io_service_bytes_recursive {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_serviced_recursive {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_queued_recursive {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_service_time_recursive {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_wait_time_recursive {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_merged_recursive {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.io_time_recursive {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sectors_recursive {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkIOStat {
        BlkIOStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_service_bytes_recursive",
                |m: &BlkIOStat| { &m.io_service_bytes_recursive },
                |m: &mut BlkIOStat| { &mut m.io_service_bytes_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_serviced_recursive",
                |m: &BlkIOStat| { &m.io_serviced_recursive },
                |m: &mut BlkIOStat| { &mut m.io_serviced_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_queued_recursive",
                |m: &BlkIOStat| { &m.io_queued_recursive },
                |m: &mut BlkIOStat| { &mut m.io_queued_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_service_time_recursive",
                |m: &BlkIOStat| { &m.io_service_time_recursive },
                |m: &mut BlkIOStat| { &mut m.io_service_time_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_wait_time_recursive",
                |m: &BlkIOStat| { &m.io_wait_time_recursive },
                |m: &mut BlkIOStat| { &mut m.io_wait_time_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_merged_recursive",
                |m: &BlkIOStat| { &m.io_merged_recursive },
                |m: &mut BlkIOStat| { &mut m.io_merged_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "io_time_recursive",
                |m: &BlkIOStat| { &m.io_time_recursive },
                |m: &mut BlkIOStat| { &mut m.io_time_recursive },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlkIOEntry>>(
                "sectors_recursive",
                |m: &BlkIOStat| { &m.sectors_recursive },
                |m: &mut BlkIOStat| { &mut m.sectors_recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlkIOStat>(
                "BlkIOStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlkIOStat {
        static instance: ::protobuf::rt::LazyV2<BlkIOStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlkIOStat::new)
    }
}

impl ::protobuf::Clear for BlkIOStat {
    fn clear(&mut self) {
        self.io_service_bytes_recursive.clear();
        self.io_serviced_recursive.clear();
        self.io_queued_recursive.clear();
        self.io_service_time_recursive.clear();
        self.io_wait_time_recursive.clear();
        self.io_merged_recursive.clear();
        self.io_time_recursive.clear();
        self.sectors_recursive.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkIOStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkIOStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlkIOEntry {
    // message fields
    pub op: ::std::string::String,
    pub device: ::std::string::String,
    pub major: u64,
    pub minor: u64,
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlkIOEntry {
    fn default() -> &'a BlkIOEntry {
        <BlkIOEntry as ::protobuf::Message>::default_instance()
    }
}

impl BlkIOEntry {
    pub fn new() -> BlkIOEntry {
        ::std::default::Default::default()
    }

    // string op = 1;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // string device = 2;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // uint64 major = 3;


    pub fn get_major(&self) -> u64 {
        self.major
    }
    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u64) {
        self.major = v;
    }

    // uint64 minor = 4;


    pub fn get_minor(&self) -> u64 {
        self.minor
    }
    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u64) {
        self.minor = v;
    }

    // uint64 value = 5;


    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for BlkIOEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.major = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minor = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device);
        }
        if self.major != 0 {
            my_size += ::protobuf::rt::value_size(3, self.major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::value_size(4, self.minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.op.is_empty() {
            os.write_string(1, &self.op)?;
        }
        if !self.device.is_empty() {
            os.write_string(2, &self.device)?;
        }
        if self.major != 0 {
            os.write_uint64(3, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint64(4, self.minor)?;
        }
        if self.value != 0 {
            os.write_uint64(5, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlkIOEntry {
        BlkIOEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op",
                |m: &BlkIOEntry| { &m.op },
                |m: &mut BlkIOEntry| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &BlkIOEntry| { &m.device },
                |m: &mut BlkIOEntry| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "major",
                |m: &BlkIOEntry| { &m.major },
                |m: &mut BlkIOEntry| { &mut m.major },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minor",
                |m: &BlkIOEntry| { &m.minor },
                |m: &mut BlkIOEntry| { &mut m.minor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "value",
                |m: &BlkIOEntry| { &m.value },
                |m: &mut BlkIOEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlkIOEntry>(
                "BlkIOEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlkIOEntry {
        static instance: ::protobuf::rt::LazyV2<BlkIOEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlkIOEntry::new)
    }
}

impl ::protobuf::Clear for BlkIOEntry {
    fn clear(&mut self) {
        self.op.clear();
        self.device.clear();
        self.major = 0;
        self.minor = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlkIOEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkIOEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RdmaStat {
    // message fields
    pub current: ::protobuf::RepeatedField<RdmaEntry>,
    pub limit: ::protobuf::RepeatedField<RdmaEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RdmaStat {
    fn default() -> &'a RdmaStat {
        <RdmaStat as ::protobuf::Message>::default_instance()
    }
}

impl RdmaStat {
    pub fn new() -> RdmaStat {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.RdmaEntry current = 1;


    pub fn get_current(&self) -> &[RdmaEntry] {
        &self.current
    }
    pub fn clear_current(&mut self) {
        self.current.clear();
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: ::protobuf::RepeatedField<RdmaEntry>) {
        self.current = v;
    }

    // Mutable pointer to the field.
    pub fn mut_current(&mut self) -> &mut ::protobuf::RepeatedField<RdmaEntry> {
        &mut self.current
    }

    // Take field
    pub fn take_current(&mut self) -> ::protobuf::RepeatedField<RdmaEntry> {
        ::std::mem::replace(&mut self.current, ::protobuf::RepeatedField::new())
    }

    // repeated .io.containerd.cgroups.v1.RdmaEntry limit = 2;


    pub fn get_limit(&self) -> &[RdmaEntry] {
        &self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::RepeatedField<RdmaEntry>) {
        self.limit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::RepeatedField<RdmaEntry> {
        &mut self.limit
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::RepeatedField<RdmaEntry> {
        ::std::mem::replace(&mut self.limit, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RdmaStat {
    fn is_initialized(&self) -> bool {
        for v in &self.current {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.current)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.current {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.limit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.current {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.limit {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RdmaStat {
        RdmaStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RdmaEntry>>(
                "current",
                |m: &RdmaStat| { &m.current },
                |m: &mut RdmaStat| { &mut m.current },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RdmaEntry>>(
                "limit",
                |m: &RdmaStat| { &m.limit },
                |m: &mut RdmaStat| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RdmaStat>(
                "RdmaStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RdmaStat {
        static instance: ::protobuf::rt::LazyV2<RdmaStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RdmaStat::new)
    }
}

impl ::protobuf::Clear for RdmaStat {
    fn clear(&mut self) {
        self.current.clear();
        self.limit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RdmaStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RdmaStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RdmaEntry {
    // message fields
    pub device: ::std::string::String,
    pub hca_handles: u32,
    pub hca_objects: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RdmaEntry {
    fn default() -> &'a RdmaEntry {
        <RdmaEntry as ::protobuf::Message>::default_instance()
    }
}

impl RdmaEntry {
    pub fn new() -> RdmaEntry {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // uint32 hca_handles = 2;


    pub fn get_hca_handles(&self) -> u32 {
        self.hca_handles
    }
    pub fn clear_hca_handles(&mut self) {
        self.hca_handles = 0;
    }

    // Param is passed by value, moved
    pub fn set_hca_handles(&mut self, v: u32) {
        self.hca_handles = v;
    }

    // uint32 hca_objects = 3;


    pub fn get_hca_objects(&self) -> u32 {
        self.hca_objects
    }
    pub fn clear_hca_objects(&mut self) {
        self.hca_objects = 0;
    }

    // Param is passed by value, moved
    pub fn set_hca_objects(&mut self, v: u32) {
        self.hca_objects = v;
    }
}

impl ::protobuf::Message for RdmaEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hca_handles = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hca_objects = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if self.hca_handles != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hca_handles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hca_objects != 0 {
            my_size += ::protobuf::rt::value_size(3, self.hca_objects, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if self.hca_handles != 0 {
            os.write_uint32(2, self.hca_handles)?;
        }
        if self.hca_objects != 0 {
            os.write_uint32(3, self.hca_objects)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RdmaEntry {
        RdmaEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &RdmaEntry| { &m.device },
                |m: &mut RdmaEntry| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hca_handles",
                |m: &RdmaEntry| { &m.hca_handles },
                |m: &mut RdmaEntry| { &mut m.hca_handles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hca_objects",
                |m: &RdmaEntry| { &m.hca_objects },
                |m: &mut RdmaEntry| { &mut m.hca_objects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RdmaEntry>(
                "RdmaEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RdmaEntry {
        static instance: ::protobuf::rt::LazyV2<RdmaEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RdmaEntry::new)
    }
}

impl ::protobuf::Clear for RdmaEntry {
    fn clear(&mut self) {
        self.device.clear();
        self.hca_handles = 0;
        self.hca_objects = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RdmaEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RdmaEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStat {
    // message fields
    pub name: ::std::string::String,
    pub rx_bytes: u64,
    pub rx_packets: u64,
    pub rx_errors: u64,
    pub rx_dropped: u64,
    pub tx_bytes: u64,
    pub tx_packets: u64,
    pub tx_errors: u64,
    pub tx_dropped: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStat {
    fn default() -> &'a NetworkStat {
        <NetworkStat as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStat {
    pub fn new() -> NetworkStat {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 rx_bytes = 2;


    pub fn get_rx_bytes(&self) -> u64 {
        self.rx_bytes
    }
    pub fn clear_rx_bytes(&mut self) {
        self.rx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes(&mut self, v: u64) {
        self.rx_bytes = v;
    }

    // uint64 rx_packets = 3;


    pub fn get_rx_packets(&self) -> u64 {
        self.rx_packets
    }
    pub fn clear_rx_packets(&mut self) {
        self.rx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets(&mut self, v: u64) {
        self.rx_packets = v;
    }

    // uint64 rx_errors = 4;


    pub fn get_rx_errors(&self) -> u64 {
        self.rx_errors
    }
    pub fn clear_rx_errors(&mut self) {
        self.rx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_errors(&mut self, v: u64) {
        self.rx_errors = v;
    }

    // uint64 rx_dropped = 5;


    pub fn get_rx_dropped(&self) -> u64 {
        self.rx_dropped
    }
    pub fn clear_rx_dropped(&mut self) {
        self.rx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dropped(&mut self, v: u64) {
        self.rx_dropped = v;
    }

    // uint64 tx_bytes = 6;


    pub fn get_tx_bytes(&self) -> u64 {
        self.tx_bytes
    }
    pub fn clear_tx_bytes(&mut self) {
        self.tx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes(&mut self, v: u64) {
        self.tx_bytes = v;
    }

    // uint64 tx_packets = 7;


    pub fn get_tx_packets(&self) -> u64 {
        self.tx_packets
    }
    pub fn clear_tx_packets(&mut self) {
        self.tx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets(&mut self, v: u64) {
        self.tx_packets = v;
    }

    // uint64 tx_errors = 8;


    pub fn get_tx_errors(&self) -> u64 {
        self.tx_errors
    }
    pub fn clear_tx_errors(&mut self) {
        self.tx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_errors(&mut self, v: u64) {
        self.tx_errors = v;
    }

    // uint64 tx_dropped = 9;


    pub fn get_tx_dropped(&self) -> u64 {
        self.tx_dropped
    }
    pub fn clear_tx_dropped(&mut self) {
        self.tx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_dropped(&mut self, v: u64) {
        self.tx_dropped = v;
    }
}

impl ::protobuf::Message for NetworkStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_packets = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_errors = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rx_dropped = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_bytes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_packets = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_errors = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_dropped = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.rx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_packets != 0 {
            my_size += ::protobuf::rt::value_size(3, self.rx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_errors != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tx_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_packets != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_packets, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_errors != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tx_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_dropped != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tx_dropped, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.rx_bytes != 0 {
            os.write_uint64(2, self.rx_bytes)?;
        }
        if self.rx_packets != 0 {
            os.write_uint64(3, self.rx_packets)?;
        }
        if self.rx_errors != 0 {
            os.write_uint64(4, self.rx_errors)?;
        }
        if self.rx_dropped != 0 {
            os.write_uint64(5, self.rx_dropped)?;
        }
        if self.tx_bytes != 0 {
            os.write_uint64(6, self.tx_bytes)?;
        }
        if self.tx_packets != 0 {
            os.write_uint64(7, self.tx_packets)?;
        }
        if self.tx_errors != 0 {
            os.write_uint64(8, self.tx_errors)?;
        }
        if self.tx_dropped != 0 {
            os.write_uint64(9, self.tx_dropped)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStat {
        NetworkStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NetworkStat| { &m.name },
                |m: &mut NetworkStat| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rx_bytes",
                |m: &NetworkStat| { &m.rx_bytes },
                |m: &mut NetworkStat| { &mut m.rx_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rx_packets",
                |m: &NetworkStat| { &m.rx_packets },
                |m: &mut NetworkStat| { &mut m.rx_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rx_errors",
                |m: &NetworkStat| { &m.rx_errors },
                |m: &mut NetworkStat| { &mut m.rx_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rx_dropped",
                |m: &NetworkStat| { &m.rx_dropped },
                |m: &mut NetworkStat| { &mut m.rx_dropped },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tx_bytes",
                |m: &NetworkStat| { &m.tx_bytes },
                |m: &mut NetworkStat| { &mut m.tx_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tx_packets",
                |m: &NetworkStat| { &m.tx_packets },
                |m: &mut NetworkStat| { &mut m.tx_packets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tx_errors",
                |m: &NetworkStat| { &m.tx_errors },
                |m: &mut NetworkStat| { &mut m.tx_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tx_dropped",
                |m: &NetworkStat| { &m.tx_dropped },
                |m: &mut NetworkStat| { &mut m.tx_dropped },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkStat>(
                "NetworkStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkStat {
        static instance: ::protobuf::rt::LazyV2<NetworkStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkStat::new)
    }
}

impl ::protobuf::Clear for NetworkStat {
    fn clear(&mut self) {
        self.name.clear();
        self.rx_bytes = 0;
        self.rx_packets = 0;
        self.rx_errors = 0;
        self.rx_dropped = 0;
        self.tx_bytes = 0;
        self.tx_packets = 0;
        self.tx_errors = 0;
        self.tx_dropped = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CgroupStats {
    // message fields
    pub nr_sleeping: u64,
    pub nr_running: u64,
    pub nr_stopped: u64,
    pub nr_uninterruptible: u64,
    pub nr_io_wait: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CgroupStats {
    fn default() -> &'a CgroupStats {
        <CgroupStats as ::protobuf::Message>::default_instance()
    }
}

impl CgroupStats {
    pub fn new() -> CgroupStats {
        ::std::default::Default::default()
    }

    // uint64 nr_sleeping = 1;


    pub fn get_nr_sleeping(&self) -> u64 {
        self.nr_sleeping
    }
    pub fn clear_nr_sleeping(&mut self) {
        self.nr_sleeping = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_sleeping(&mut self, v: u64) {
        self.nr_sleeping = v;
    }

    // uint64 nr_running = 2;


    pub fn get_nr_running(&self) -> u64 {
        self.nr_running
    }
    pub fn clear_nr_running(&mut self) {
        self.nr_running = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_running(&mut self, v: u64) {
        self.nr_running = v;
    }

    // uint64 nr_stopped = 3;


    pub fn get_nr_stopped(&self) -> u64 {
        self.nr_stopped
    }
    pub fn clear_nr_stopped(&mut self) {
        self.nr_stopped = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_stopped(&mut self, v: u64) {
        self.nr_stopped = v;
    }

    // uint64 nr_uninterruptible = 4;


    pub fn get_nr_uninterruptible(&self) -> u64 {
        self.nr_uninterruptible
    }
    pub fn clear_nr_uninterruptible(&mut self) {
        self.nr_uninterruptible = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_uninterruptible(&mut self, v: u64) {
        self.nr_uninterruptible = v;
    }

    // uint64 nr_io_wait = 5;


    pub fn get_nr_io_wait(&self) -> u64 {
        self.nr_io_wait
    }
    pub fn clear_nr_io_wait(&mut self) {
        self.nr_io_wait = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_io_wait(&mut self, v: u64) {
        self.nr_io_wait = v;
    }
}

impl ::protobuf::Message for CgroupStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nr_sleeping = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nr_running = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nr_stopped = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nr_uninterruptible = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nr_io_wait = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nr_sleeping != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nr_sleeping, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nr_running != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nr_running, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nr_stopped != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nr_stopped, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nr_uninterruptible != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nr_uninterruptible, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nr_io_wait != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nr_io_wait, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nr_sleeping != 0 {
            os.write_uint64(1, self.nr_sleeping)?;
        }
        if self.nr_running != 0 {
            os.write_uint64(2, self.nr_running)?;
        }
        if self.nr_stopped != 0 {
            os.write_uint64(3, self.nr_stopped)?;
        }
        if self.nr_uninterruptible != 0 {
            os.write_uint64(4, self.nr_uninterruptible)?;
        }
        if self.nr_io_wait != 0 {
            os.write_uint64(5, self.nr_io_wait)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CgroupStats {
        CgroupStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nr_sleeping",
                |m: &CgroupStats| { &m.nr_sleeping },
                |m: &mut CgroupStats| { &mut m.nr_sleeping },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nr_running",
                |m: &CgroupStats| { &m.nr_running },
                |m: &mut CgroupStats| { &mut m.nr_running },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nr_stopped",
                |m: &CgroupStats| { &m.nr_stopped },
                |m: &mut CgroupStats| { &mut m.nr_stopped },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nr_uninterruptible",
                |m: &CgroupStats| { &m.nr_uninterruptible },
                |m: &mut CgroupStats| { &mut m.nr_uninterruptible },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nr_io_wait",
                |m: &CgroupStats| { &m.nr_io_wait },
                |m: &mut CgroupStats| { &mut m.nr_io_wait },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CgroupStats>(
                "CgroupStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CgroupStats {
        static instance: ::protobuf::rt::LazyV2<CgroupStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CgroupStats::new)
    }
}

impl ::protobuf::Clear for CgroupStats {
    fn clear(&mut self) {
        self.nr_sleeping = 0;
        self.nr_running = 0;
        self.nr_stopped = 0;
        self.nr_uninterruptible = 0;
        self.nr_io_wait = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CgroupStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n4github.com/containerd/cgroups/stats/v1/metrics.proto\x12\x18io.contai\
    nerd.cgroups.v1\x1a\x14gogoproto/gogo.proto\"\xe8\x04\n\x07Metrics\x12A\
    \n\x07hugetlb\x18\x01\x20\x03(\x0b2%.io.containerd.cgroups.v1.HugetlbSta\
    tR\x07hugetlbB\0\x128\n\x04pids\x18\x02\x20\x01(\x0b2\".io.containerd.cg\
    roups.v1.PidsStatR\x04pidsB\0\x12<\n\x03cpu\x18\x03\x20\x01(\x0b2!.io.co\
    ntainerd.cgroups.v1.CPUStatR\x03cpuB\x07\xe2\xde\x1f\x03CPU\x12>\n\x06me\
    mory\x18\x04\x20\x01(\x0b2$.io.containerd.cgroups.v1.MemoryStatR\x06memo\
    ryB\0\x12;\n\x05blkio\x18\x05\x20\x01(\x0b2#.io.containerd.cgroups.v1.Bl\
    kIOStatR\x05blkioB\0\x128\n\x04rdma\x18\x06\x20\x01(\x0b2\".io.container\
    d.cgroups.v1.RdmaStatR\x04rdmaB\0\x12A\n\x07network\x18\x07\x20\x03(\x0b\
    2%.io.containerd.cgroups.v1.NetworkStatR\x07networkB\0\x12J\n\x0ccgroup_\
    stats\x18\x08\x20\x01(\x0b2%.io.containerd.cgroups.v1.CgroupStatsR\x0bcg\
    roupStatsB\0\x12Z\n\x12memory_oom_control\x18\t\x20\x01(\x0b2*.io.contai\
    nerd.cgroups.v1.MemoryOomControlR\x10memoryOomControlB\0:\0\"u\n\x0bHuge\
    tlbStat\x12\x16\n\x05usage\x18\x01\x20\x01(\x04R\x05usageB\0\x12\x12\n\
    \x03max\x18\x02\x20\x01(\x04R\x03maxB\0\x12\x1a\n\x07failcnt\x18\x03\x20\
    \x01(\x04R\x07failcntB\0\x12\x1c\n\x08pagesize\x18\x04\x20\x01(\tR\x08pa\
    gesizeB\0:\0\"@\n\x08PidsStat\x12\x1a\n\x07current\x18\x01\x20\x01(\x04R\
    \x07currentB\0\x12\x16\n\x05limit\x18\x02\x20\x01(\x04R\x05limitB\0:\0\"\
    \x8d\x01\n\x07CPUStat\x12:\n\x05usage\x18\x01\x20\x01(\x0b2\".io.contain\
    erd.cgroups.v1.CPUUsageR\x05usageB\0\x12D\n\nthrottling\x18\x02\x20\x01(\
    \x0b2\".io.containerd.cgroups.v1.ThrottleR\nthrottlingB\0:\0\"y\n\x08CPU\
    Usage\x12\x16\n\x05total\x18\x01\x20\x01(\x04R\x05totalB\0\x12\x18\n\x06\
    kernel\x18\x02\x20\x01(\x04R\x06kernelB\0\x12\x14\n\x04user\x18\x03\x20\
    \x01(\x04R\x04userB\0\x12#\n\x07per_cpu\x18\x04\x20\x03(\x04R\x06perCpuB\
    \n\xe2\xde\x1f\x06PerCPU:\0\"\x80\x01\n\x08Throttle\x12\x1a\n\x07periods\
    \x18\x01\x20\x01(\x04R\x07periodsB\0\x12-\n\x11throttled_periods\x18\x02\
    \x20\x01(\x04R\x10throttledPeriodsB\0\x12'\n\x0ethrottled_time\x18\x03\
    \x20\x01(\x04R\rthrottledTimeB\0:\0\"\x99\x0c\n\nMemoryStat\x12\x16\n\
    \x05cache\x18\x01\x20\x01(\x04R\x05cacheB\0\x12\x19\n\x03rss\x18\x02\x20\
    \x01(\x04R\x03rssB\x07\xe2\xde\x1f\x03RSS\x12&\n\x08rss_huge\x18\x03\x20\
    \x01(\x04R\x07rssHugeB\x0b\xe2\xde\x1f\x07RSSHuge\x12!\n\x0bmapped_file\
    \x18\x04\x20\x01(\x04R\nmappedFileB\0\x12\x16\n\x05dirty\x18\x05\x20\x01\
    (\x04R\x05dirtyB\0\x12\x1e\n\twriteback\x18\x06\x20\x01(\x04R\twriteback\
    B\0\x12\x1a\n\x08pg_pg_in\x18\x07\x20\x01(\x04R\x06pgPgInB\0\x12\x1c\n\t\
    pg_pg_out\x18\x08\x20\x01(\x04R\x07pgPgOutB\0\x12\x1b\n\x08pg_fault\x18\
    \t\x20\x01(\x04R\x07pgFaultB\0\x12\"\n\x0cpg_maj_fault\x18\n\x20\x01(\
    \x04R\npgMajFaultB\0\x12%\n\rinactive_anon\x18\x0b\x20\x01(\x04R\x0cinac\
    tiveAnonB\0\x12!\n\x0bactive_anon\x18\x0c\x20\x01(\x04R\nactiveAnonB\0\
    \x12%\n\rinactive_file\x18\r\x20\x01(\x04R\x0cinactiveFileB\0\x12!\n\x0b\
    active_file\x18\x0e\x20\x01(\x04R\nactiveFileB\0\x12\"\n\x0bunevictable\
    \x18\x0f\x20\x01(\x04R\x0bunevictableB\0\x12<\n\x19hierarchical_memory_l\
    imit\x18\x10\x20\x01(\x04R\x17hierarchicalMemoryLimitB\0\x128\n\x17hiera\
    rchical_swap_limit\x18\x11\x20\x01(\x04R\x15hierarchicalSwapLimitB\0\x12\
    !\n\x0btotal_cache\x18\x12\x20\x01(\x04R\ntotalCacheB\0\x12)\n\ttotal_rs\
    s\x18\x13\x20\x01(\x04R\x08totalRssB\x0c\xe2\xde\x1f\x08TotalRSS\x126\n\
    \x0etotal_rss_huge\x18\x14\x20\x01(\x04R\x0ctotalRssHugeB\x10\xe2\xde\
    \x1f\x0cTotalRSSHuge\x12,\n\x11total_mapped_file\x18\x15\x20\x01(\x04R\
    \x0ftotalMappedFileB\0\x12!\n\x0btotal_dirty\x18\x16\x20\x01(\x04R\ntota\
    lDirtyB\0\x12)\n\x0ftotal_writeback\x18\x17\x20\x01(\x04R\x0etotalWriteb\
    ackB\0\x12%\n\x0etotal_pg_pg_in\x18\x18\x20\x01(\x04R\x0btotalPgPgInB\0\
    \x12'\n\x0ftotal_pg_pg_out\x18\x19\x20\x01(\x04R\x0ctotalPgPgOutB\0\x12&\
    \n\x0etotal_pg_fault\x18\x1a\x20\x01(\x04R\x0ctotalPgFaultB\0\x12-\n\x12\
    total_pg_maj_fault\x18\x1b\x20\x01(\x04R\x0ftotalPgMajFaultB\0\x120\n\
    \x13total_inactive_anon\x18\x1c\x20\x01(\x04R\x11totalInactiveAnonB\0\
    \x12,\n\x11total_active_anon\x18\x1d\x20\x01(\x04R\x0ftotalActiveAnonB\0\
    \x120\n\x13total_inactive_file\x18\x1e\x20\x01(\x04R\x11totalInactiveFil\
    eB\0\x12,\n\x11total_active_file\x18\x1f\x20\x01(\x04R\x0ftotalActiveFil\
    eB\0\x12-\n\x11total_unevictable\x18\x20\x20\x01(\x04R\x10totalUnevictab\
    leB\0\x12=\n\x05usage\x18!\x20\x01(\x0b2%.io.containerd.cgroups.v1.Memor\
    yEntryR\x05usageB\0\x12;\n\x04swap\x18\"\x20\x01(\x0b2%.io.containerd.cg\
    roups.v1.MemoryEntryR\x04swapB\0\x12?\n\x06kernel\x18#\x20\x01(\x0b2%.io\
    .containerd.cgroups.v1.MemoryEntryR\x06kernelB\0\x12S\n\nkernel_tcp\x18$\
    \x20\x01(\x0b2%.io.containerd.cgroups.v1.MemoryEntryR\tkernelTcpB\r\xe2\
    \xde\x1f\tKernelTCP:\0\"o\n\x0bMemoryEntry\x12\x16\n\x05limit\x18\x01\
    \x20\x01(\x04R\x05limitB\0\x12\x16\n\x05usage\x18\x02\x20\x01(\x04R\x05u\
    sageB\0\x12\x12\n\x03max\x18\x03\x20\x01(\x04R\x03maxB\0\x12\x1a\n\x07fa\
    ilcnt\x18\x04\x20\x01(\x04R\x07failcntB\0:\0\"|\n\x10MemoryOomControl\
    \x12*\n\x10oom_kill_disable\x18\x01\x20\x01(\x04R\x0eoomKillDisableB\0\
    \x12\x1d\n\tunder_oom\x18\x02\x20\x01(\x04R\x08underOomB\0\x12\x1b\n\x08\
    oom_kill\x18\x03\x20\x01(\x04R\x07oomKillB\0:\0\"\xe7\x05\n\tBlkIOStat\
    \x12c\n\x1aio_service_bytes_recursive\x18\x01\x20\x03(\x0b2$.io.containe\
    rd.cgroups.v1.BlkIOEntryR\x17ioServiceBytesRecursiveB\0\x12Z\n\x15io_ser\
    viced_recursive\x18\x02\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEnt\
    ryR\x13ioServicedRecursiveB\0\x12V\n\x13io_queued_recursive\x18\x03\x20\
    \x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x11ioQueuedRecursiveB\0\
    \x12a\n\x19io_service_time_recursive\x18\x04\x20\x03(\x0b2$.io.container\
    d.cgroups.v1.BlkIOEntryR\x16ioServiceTimeRecursiveB\0\x12[\n\x16io_wait_\
    time_recursive\x18\x05\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntr\
    yR\x13ioWaitTimeRecursiveB\0\x12V\n\x13io_merged_recursive\x18\x06\x20\
    \x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x11ioMergedRecursiveB\0\
    \x12R\n\x11io_time_recursive\x18\x07\x20\x03(\x0b2$.io.containerd.cgroup\
    s.v1.BlkIOEntryR\x0fioTimeRecursiveB\0\x12S\n\x11sectors_recursive\x18\
    \x08\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x10sectorsRecur\
    siveB\0:\0\"\x82\x01\n\nBlkIOEntry\x12\x10\n\x02op\x18\x01\x20\x01(\tR\
    \x02opB\0\x12\x18\n\x06device\x18\x02\x20\x01(\tR\x06deviceB\0\x12\x16\n\
    \x05major\x18\x03\x20\x01(\x04R\x05majorB\0\x12\x16\n\x05minor\x18\x04\
    \x20\x01(\x04R\x05minorB\0\x12\x16\n\x05value\x18\x05\x20\x01(\x04R\x05v\
    alueB\0:\0\"\x8a\x01\n\x08RdmaStat\x12?\n\x07current\x18\x01\x20\x03(\
    \x0b2#.io.containerd.cgroups.v1.RdmaEntryR\x07currentB\0\x12;\n\x05limit\
    \x18\x02\x20\x03(\x0b2#.io.containerd.cgroups.v1.RdmaEntryR\x05limitB\0:\
    \0\"m\n\tRdmaEntry\x12\x18\n\x06device\x18\x01\x20\x01(\tR\x06deviceB\0\
    \x12!\n\x0bhca_handles\x18\x02\x20\x01(\rR\nhcaHandlesB\0\x12!\n\x0bhca_\
    objects\x18\x03\x20\x01(\rR\nhcaObjectsB\0:\0\"\xa1\x02\n\x0bNetworkStat\
    \x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12\x1b\n\x08rx_bytes\
    \x18\x02\x20\x01(\x04R\x07rxBytesB\0\x12\x1f\n\nrx_packets\x18\x03\x20\
    \x01(\x04R\trxPacketsB\0\x12\x1d\n\trx_errors\x18\x04\x20\x01(\x04R\x08r\
    xErrorsB\0\x12\x1f\n\nrx_dropped\x18\x05\x20\x01(\x04R\trxDroppedB\0\x12\
    \x1b\n\x08tx_bytes\x18\x06\x20\x01(\x04R\x07txBytesB\0\x12\x1f\n\ntx_pac\
    kets\x18\x07\x20\x01(\x04R\ttxPacketsB\0\x12\x1d\n\ttx_errors\x18\x08\
    \x20\x01(\x04R\x08txErrorsB\0\x12\x1f\n\ntx_dropped\x18\t\x20\x01(\x04R\
    \ttxDroppedB\0:\0\"\xc5\x01\n\x0bCgroupStats\x12!\n\x0bnr_sleeping\x18\
    \x01\x20\x01(\x04R\nnrSleepingB\0\x12\x1f\n\nnr_running\x18\x02\x20\x01(\
    \x04R\tnrRunningB\0\x12\x1f\n\nnr_stopped\x18\x03\x20\x01(\x04R\tnrStopp\
    edB\0\x12/\n\x12nr_uninterruptible\x18\x04\x20\x01(\x04R\x11nrUninterrup\
    tibleB\0\x12\x1e\n\nnr_io_wait\x18\x05\x20\x01(\x04R\x08nrIoWaitB\0:\0B\
    \0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
